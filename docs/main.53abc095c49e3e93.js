"use strict"; (self.webpackChunktasklink_frontend = self.webpackChunktasklink_frontend || []).push([[792], { 629: () => { function ne(e) { return "function" == typeof e } function mo(e) { const t = e(r => { Error.call(r), r.stack = (new Error).stack }); return t.prototype = Object.create(Error.prototype), t.prototype.constructor = t, t } const la = mo(e => function (t) { e(this), this.message = t ? `${t.length} errors occurred during unsubscription:\n${t.map((r, i) => `${i + 1}) ${r.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = t }); function Yr(e, n) { if (e) { const t = e.indexOf(n); 0 <= t && e.splice(t, 1) } } class Pe { constructor(n) { this.initialTeardown = n, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let n; if (!this.closed) { this.closed = !0; const { _parentage: t } = this; if (t) if (this._parentage = null, Array.isArray(t)) for (const o of t) o.remove(this); else t.remove(this); const { initialTeardown: r } = this; if (ne(r)) try { r() } catch (o) { n = o instanceof la ? o.errors : [o] } const { _finalizers: i } = this; if (i) { this._finalizers = null; for (const o of i) try { Zp(o) } catch (s) { n = n ?? [], s instanceof la ? n = [...n, ...s.errors] : n.push(s) } } if (n) throw new la(n) } } add(n) { var t; if (n && n !== this) if (this.closed) Zp(n); else { if (n instanceof Pe) { if (n.closed || n._hasParent(this)) return; n._addParent(this) } (this._finalizers = null !== (t = this._finalizers) && void 0 !== t ? t : []).push(n) } } _hasParent(n) { const { _parentage: t } = this; return t === n || Array.isArray(t) && t.includes(n) } _addParent(n) { const { _parentage: t } = this; this._parentage = Array.isArray(t) ? (t.push(n), t) : t ? [t, n] : n } _removeParent(n) { const { _parentage: t } = this; t === n ? this._parentage = null : Array.isArray(t) && Yr(t, n) } remove(n) { const { _finalizers: t } = this; t && Yr(t, n), n instanceof Pe && n._removeParent(this) } } Pe.EMPTY = (() => { const e = new Pe; return e.closed = !0, e })(); const qp = Pe.EMPTY; function Wp(e) { return e instanceof Pe || e && "closed" in e && ne(e.remove) && ne(e.add) && ne(e.unsubscribe) } function Zp(e) { ne(e) ? e() : e.unsubscribe() } const br = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, ca = { setTimeout(e, n, ...t) { const { delegate: r } = ca; return r?.setTimeout ? r.setTimeout(e, n, ...t) : setTimeout(e, n, ...t) }, clearTimeout(e) { const { delegate: n } = ca; return (n?.clearTimeout || clearTimeout)(e) }, delegate: void 0 }; function Kp(e) { ca.setTimeout(() => { const { onUnhandledError: n } = br; if (!n) throw e; n(e) }) } function Jc() { } const bE = eu("C", void 0, void 0); function eu(e, n, t) { return { kind: e, value: n, error: t } } let Dr = null; function ua(e) { if (br.useDeprecatedSynchronousErrorHandling) { const n = !Dr; if (n && (Dr = { errorThrown: !1, error: null }), e(), n) { const { errorThrown: t, error: r } = Dr; if (Dr = null, t) throw r } } else e() } class tu extends Pe { constructor(n) { super(), this.isStopped = !1, n ? (this.destination = n, Wp(n) && n.add(this)) : this.destination = TE } static create(n, t, r) { return new _o(n, t, r) } next(n) { this.isStopped ? ru(function CE(e) { return eu("N", e, void 0) }(n), this) : this._next(n) } error(n) { this.isStopped ? ru(function DE(e) { return eu("E", void 0, e) }(n), this) : (this.isStopped = !0, this._error(n)) } complete() { this.isStopped ? ru(bE, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(n) { this.destination.next(n) } _error(n) { try { this.destination.error(n) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } const EE = Function.prototype.bind; function nu(e, n) { return EE.call(e, n) } class IE { constructor(n) { this.partialObserver = n } next(n) { const { partialObserver: t } = this; if (t.next) try { t.next(n) } catch (r) { da(r) } } error(n) { const { partialObserver: t } = this; if (t.error) try { t.error(n) } catch (r) { da(r) } else da(n) } complete() { const { partialObserver: n } = this; if (n.complete) try { n.complete() } catch (t) { da(t) } } } class _o extends tu { constructor(n, t, r) { let i; if (super(), ne(n) || !n) i = { next: n ?? void 0, error: t ?? void 0, complete: r ?? void 0 }; else { let o; this && br.useDeprecatedNextContext ? (o = Object.create(n), o.unsubscribe = () => this.unsubscribe(), i = { next: n.next && nu(n.next, o), error: n.error && nu(n.error, o), complete: n.complete && nu(n.complete, o) }) : i = n } this.destination = new IE(i) } } function da(e) { br.useDeprecatedSynchronousErrorHandling ? function wE(e) { br.useDeprecatedSynchronousErrorHandling && Dr && (Dr.errorThrown = !0, Dr.error = e) }(e) : Kp(e) } function ru(e, n) { const { onStoppedNotification: t } = br; t && ca.setTimeout(() => t(e, n)) } const TE = { closed: !0, next: Jc, error: function SE(e) { throw e }, complete: Jc }, iu = "function" == typeof Symbol && Symbol.observable || "@@observable"; function Yn(e) { return e } function Yp(e) { return 0 === e.length ? Yn : 1 === e.length ? e[0] : function (t) { return e.reduce((r, i) => i(r), t) } } let be = (() => { class e { constructor(t) { t && (this._subscribe = t) } lift(t) { const r = new e; return r.source = this, r.operator = t, r } subscribe(t, r, i) { const o = function AE(e) { return e && e instanceof tu || function ME(e) { return e && ne(e.next) && ne(e.error) && ne(e.complete) }(e) && Wp(e) }(t) ? t : new _o(t, r, i); return ua(() => { const { operator: s, source: a } = this; o.add(s ? s.call(o, a) : a ? this._subscribe(o) : this._trySubscribe(o)) }), o } _trySubscribe(t) { try { return this._subscribe(t) } catch (r) { t.error(r) } } forEach(t, r) { return new (r = Qp(r))((i, o) => { const s = new _o({ next: a => { try { t(a) } catch (l) { o(l), s.unsubscribe() } }, error: o, complete: i }); this.subscribe(s) }) } _subscribe(t) { var r; return null === (r = this.source) || void 0 === r ? void 0 : r.subscribe(t) } [iu]() { return this } pipe(...t) { return Yp(t)(this) } toPromise(t) { return new (t = Qp(t))((r, i) => { let o; this.subscribe(s => o = s, s => i(s), () => r(o)) }) } } return e.create = n => new e(n), e })(); function Qp(e) { var n; return null !== (n = e ?? br.Promise) && void 0 !== n ? n : Promise } const kE = mo(e => function () { e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); let X = (() => { class e extends be { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(t) { const r = new Xp(this, this); return r.operator = t, r } _throwIfClosed() { if (this.closed) throw new kE } next(t) { ua(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (const r of this.currentObservers) r.next(t) } }) } error(t) { ua(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = t; const { observers: r } = this; for (; r.length;)r.shift().error(t) } }) } complete() { ua(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: t } = this; for (; t.length;)t.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var t; return (null === (t = this.observers) || void 0 === t ? void 0 : t.length) > 0 } _trySubscribe(t) { return this._throwIfClosed(), super._trySubscribe(t) } _subscribe(t) { return this._throwIfClosed(), this._checkFinalizedStatuses(t), this._innerSubscribe(t) } _innerSubscribe(t) { const { hasError: r, isStopped: i, observers: o } = this; return r || i ? qp : (this.currentObservers = null, o.push(t), new Pe(() => { this.currentObservers = null, Yr(o, t) })) } _checkFinalizedStatuses(t) { const { hasError: r, thrownError: i, isStopped: o } = this; r ? t.error(i) : o && t.complete() } asObservable() { const t = new be; return t.source = this, t } } return e.create = (n, t) => new Xp(n, t), e })(); class Xp extends X { constructor(n, t) { super(), this.destination = n, this.source = t } next(n) { var t, r; null === (r = null === (t = this.destination) || void 0 === t ? void 0 : t.next) || void 0 === r || r.call(t, n) } error(n) { var t, r; null === (r = null === (t = this.destination) || void 0 === t ? void 0 : t.error) || void 0 === r || r.call(t, n) } complete() { var n, t; null === (t = null === (n = this.destination) || void 0 === n ? void 0 : n.complete) || void 0 === t || t.call(n) } _subscribe(n) { var t, r; return null !== (r = null === (t = this.source) || void 0 === t ? void 0 : t.subscribe(n)) && void 0 !== r ? r : qp } } function Jp(e) { return ne(e?.lift) } function Ne(e) { return n => { if (Jp(n)) return n.lift(function (t) { try { return e(t, this) } catch (r) { this.error(r) } }); throw new TypeError("Unable to lift unknown Observable type") } } function xe(e, n, t, r, i) { return new RE(e, n, t, r, i) } class RE extends tu { constructor(n, t, r, i, o, s) { super(n), this.onFinalize = o, this.shouldUnsubscribe = s, this._next = t ? function (a) { try { t(a) } catch (l) { n.error(l) } } : super._next, this._error = i ? function (a) { try { i(a) } catch (l) { n.error(l) } finally { this.unsubscribe() } } : super._error, this._complete = r ? function () { try { r() } catch (a) { n.error(a) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var n; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { const { closed: t } = this; super.unsubscribe(), !t && (null === (n = this.onFinalize) || void 0 === n || n.call(this)) } } } function re(e, n) { return Ne((t, r) => { let i = 0; t.subscribe(xe(r, o => { r.next(e.call(n, o, i++)) })) }) } function Qn(e) { return this instanceof Qn ? (this.v = e, this) : new Qn(e) } function rg(e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var t, n = e[Symbol.asyncIterator]; return n ? n.call(e) : (e = function lu(e) { var n = "function" == typeof Symbol && Symbol.iterator, t = n && e[n], r = 0; if (t) return t.call(e); if (e && "number" == typeof e.length) return { next: function () { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e } } }; throw new TypeError(n ? "Object is not iterable." : "Symbol.iterator is not defined.") }(e), t = {}, r("next"), r("throw"), r("return"), t[Symbol.asyncIterator] = function () { return this }, t); function r(o) { t[o] = e[o] && function (s) { return new Promise(function (a, l) { !function i(o, s, a, l) { Promise.resolve(l).then(function (c) { o({ value: c, done: a }) }, s) }(a, l, (s = e[o](s)).done, s.value) }) } } } "function" == typeof SuppressedError && SuppressedError; const uu = e => e && "number" == typeof e.length && "function" != typeof e; function ig(e) { return ne(e?.then) } function og(e) { return ne(e[iu]) } function sg(e) { return Symbol.asyncIterator && ne(e?.[Symbol.asyncIterator]) } function ag(e) { return new TypeError(`You provided ${null !== e && "object" == typeof e ? "an invalid object" : `'${e}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } const lg = function oI() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" }(); function cg(e) { return ne(e?.[lg]) } function ug(e) { return function ng(e, n, t) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var i, r = t.apply(e, n || []), o = []; return i = Object.create(("function" == typeof AsyncIterator ? AsyncIterator : Object).prototype), a("next"), a("throw"), a("return", function s(m) { return function (v) { return Promise.resolve(v).then(m, d) } }), i[Symbol.asyncIterator] = function () { return this }, i; function a(m, v) { r[m] && (i[m] = function (y) { return new Promise(function (C, T) { o.push([m, y, C, T]) > 1 || l(m, y) }) }, v && (i[m] = v(i[m]))) } function l(m, v) { try { !function c(m) { m.value instanceof Qn ? Promise.resolve(m.value.v).then(u, d) : p(o[0][2], m) }(r[m](v)) } catch (y) { p(o[0][3], y) } } function u(m) { l("next", m) } function d(m) { l("throw", m) } function p(m, v) { m(v), o.shift(), o.length && l(o[0][0], o[0][1]) } }(this, arguments, function* () { const t = e.getReader(); try { for (; ;) { const { value: r, done: i } = yield Qn(t.read()); if (i) return yield Qn(void 0); yield yield Qn(r) } } finally { t.releaseLock() } }) } function dg(e) { return ne(e?.getReader) } function lt(e) { if (e instanceof be) return e; if (null != e) { if (og(e)) return function sI(e) { return new be(n => { const t = e[iu](); if (ne(t.subscribe)) return t.subscribe(n); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(e); if (uu(e)) return function aI(e) { return new be(n => { for (let t = 0; t < e.length && !n.closed; t++)n.next(e[t]); n.complete() }) }(e); if (ig(e)) return function lI(e) { return new be(n => { e.then(t => { n.closed || (n.next(t), n.complete()) }, t => n.error(t)).then(null, Kp) }) }(e); if (sg(e)) return fg(e); if (cg(e)) return function cI(e) { return new be(n => { for (const t of e) if (n.next(t), n.closed) return; n.complete() }) }(e); if (dg(e)) return function uI(e) { return fg(ug(e)) }(e) } throw ag(e) } function fg(e) { return new be(n => { (function dI(e, n) { var t, r, i, o; return function eg(e, n, t, r) { return new (t || (t = Promise))(function (o, s) { function a(u) { try { c(r.next(u)) } catch (d) { s(d) } } function l(u) { try { c(r.throw(u)) } catch (d) { s(d) } } function c(u) { u.done ? o(u.value) : function i(o) { return o instanceof t ? o : new t(function (s) { s(o) }) }(u.value).then(a, l) } c((r = r.apply(e, n || [])).next()) }) }(this, void 0, void 0, function* () { try { for (t = rg(e); !(r = yield t.next()).done;)if (n.next(r.value), n.closed) return } catch (s) { i = { error: s } } finally { try { r && !r.done && (o = t.return) && (yield o.call(t)) } finally { if (i) throw i.error } } n.complete() }) })(e, n).catch(t => n.error(t)) }) } function An(e, n, t, r = 0, i = !1) { const o = n.schedule(function () { t(), i ? e.add(this.schedule(null, r)) : this.unsubscribe() }, r); if (e.add(o), !i) return o } function Ze(e, n, t = 1 / 0) { return ne(n) ? Ze((r, i) => re((o, s) => n(r, o, i, s))(lt(e(r, i))), t) : ("number" == typeof n && (t = n), Ne((r, i) => function fI(e, n, t, r, i, o, s, a) { const l = []; let c = 0, u = 0, d = !1; const p = () => { d && !l.length && !c && n.complete() }, m = y => c < r ? v(y) : l.push(y), v = y => { o && n.next(y), c++; let C = !1; lt(t(y, u++)).subscribe(xe(n, T => { i?.(T), o ? m(T) : n.next(T) }, () => { C = !0 }, void 0, () => { if (C) try { for (c--; l.length && c < r;) { const T = l.shift(); s ? An(n, s, () => v(T)) : v(T) } p() } catch (T) { n.error(T) } })) }; return e.subscribe(xe(n, m, () => { d = !0, p() })), () => { a?.() } }(r, i, e, t))) } function Qr(e = 1 / 0) { return Ze(Yn, e) } const un = new be(e => e.complete()); function hg(e) { return e && ne(e.schedule) } function du(e) { return e[e.length - 1] } function pg(e) { return ne(du(e)) ? e.pop() : void 0 } function vo(e) { return hg(du(e)) ? e.pop() : void 0 } function gg(e, n = 0) { return Ne((t, r) => { t.subscribe(xe(r, i => An(r, e, () => r.next(i), n), () => An(r, e, () => r.complete(), n), i => An(r, e, () => r.error(i), n))) }) } function mg(e, n = 0) { return Ne((t, r) => { r.add(e.schedule(() => t.subscribe(r), n)) }) } function _g(e, n) { if (!e) throw new Error("Iterable cannot be null"); return new be(t => { An(t, n, () => { const r = e[Symbol.asyncIterator](); An(t, n, () => { r.next().then(i => { i.done ? t.complete() : t.next(i.value) }) }, 0, !0) }) }) } function He(e, n) { return n ? function bI(e, n) { if (null != e) { if (og(e)) return function gI(e, n) { return lt(e).pipe(mg(n), gg(n)) }(e, n); if (uu(e)) return function _I(e, n) { return new be(t => { let r = 0; return n.schedule(function () { r === e.length ? t.complete() : (t.next(e[r++]), t.closed || this.schedule()) }) }) }(e, n); if (ig(e)) return function mI(e, n) { return lt(e).pipe(mg(n), gg(n)) }(e, n); if (sg(e)) return _g(e, n); if (cg(e)) return function vI(e, n) { return new be(t => { let r; return An(t, n, () => { r = e[lg](), An(t, n, () => { let i, o; try { ({ value: i, done: o } = r.next()) } catch (s) { return void t.error(s) } o ? t.complete() : t.next(i) }, 0, !0) }), () => ne(r?.return) && r.return() }) }(e, n); if (dg(e)) return function yI(e, n) { return _g(ug(e), n) }(e, n) } throw ag(e) }(e, n) : lt(e) } function fa(...e) { const n = vo(e), t = function pI(e, n) { return "number" == typeof du(e) ? e.pop() : n }(e, 1 / 0), r = e; return r.length ? 1 === r.length ? lt(r[0]) : Qr(t)(He(r, n)) : un } class xt extends X { constructor(n) { super(), this._value = n } get value() { return this.getValue() } _subscribe(n) { const t = super._subscribe(n); return !t.closed && n.next(this._value), t } getValue() { const { hasError: n, thrownError: t, _value: r } = this; if (n) throw t; return this._throwIfClosed(), r } next(n) { super.next(this._value = n) } } function H(...e) { return He(e, vo(e)) } function vg(e = {}) { const { connector: n = (() => new X), resetOnError: t = !0, resetOnComplete: r = !0, resetOnRefCountZero: i = !0 } = e; return o => { let s, a, l, c = 0, u = !1, d = !1; const p = () => { a?.unsubscribe(), a = void 0 }, m = () => { p(), s = l = void 0, u = d = !1 }, v = () => { const y = s; m(), y?.unsubscribe() }; return Ne((y, C) => { c++, !d && !u && p(); const T = l = l ?? n(); C.add(() => { c--, 0 === c && !d && !u && (a = fu(v, i)) }), T.subscribe(C), !s && c > 0 && (s = new _o({ next: w => T.next(w), error: w => { d = !0, p(), a = fu(m, t, w), T.error(w) }, complete: () => { u = !0, p(), a = fu(m, r), T.complete() } }), lt(y).subscribe(s)) })(o) } } function fu(e, n, ...t) { if (!0 === n) return void e(); if (!1 === n) return; const r = new _o({ next: () => { r.unsubscribe(), e() } }); return lt(n(...t)).subscribe(r) } function Vt(e, n) { return Ne((t, r) => { let i = null, o = 0, s = !1; const a = () => s && !i && r.complete(); t.subscribe(xe(r, l => { i?.unsubscribe(); let c = 0; const u = o++; lt(e(l, u)).subscribe(i = xe(r, d => r.next(n ? n(l, d, u, c++) : d), () => { i = null, a() })) }, () => { s = !0, a() })) }) } function CI(e, n) { return e === n } function he(e) { for (let n in e) if (e[n] === he) return n; throw Error("Could not find renamed property on target object.") } function ha(e, n) { for (const t in n) n.hasOwnProperty(t) && !e.hasOwnProperty(t) && (e[t] = n[t]) } function $e(e) { if ("string" == typeof e) return e; if (Array.isArray(e)) return "[" + e.map($e).join(", ") + "]"; if (null == e) return "" + e; if (e.overriddenName) return `${e.overriddenName}`; if (e.name) return `${e.name}`; const n = e.toString(); if (null == n) return "" + n; const t = n.indexOf("\n"); return -1 === t ? n : n.substring(0, t) } function hu(e, n) { return null == e || "" === e ? null === n ? "" : n : null == n || "" === n ? e : e + " " + n } const wI = he({ __forward_ref__: he }); function De(e) { return e.__forward_ref__ = De, e.toString = function () { return $e(this()) }, e } function G(e) { return pu(e) ? e() : e } function pu(e) { return "function" == typeof e && e.hasOwnProperty(wI) && e.__forward_ref__ === De } function gu(e) { return e && !!e.\u0275providers } const yg = "https://g.co/ng/security#xss"; class x extends Error { constructor(n, t) { super(function pa(e, n) { return `NG0${Math.abs(e)}${n ? ": " + n : ""}` }(n, t)), this.code = n } } function q(e) { return "string" == typeof e ? e : null == e ? "" : String(e) } function mu(e, n) { throw new x(-201, !1) } function Bt(e, n) { null == e && function $(e, n, t, r) { throw new Error(`ASSERTION ERROR: ${e}` + (null == r ? "" : ` [Expected=> ${t} ${r} ${n} <=Actual]`)) }(n, e, null, "!=") } function F(e) { return { token: e.token, providedIn: e.providedIn || null, factory: e.factory, value: void 0 } } function ct(e) { return { providers: e.providers || [], imports: e.imports || [] } } function ga(e) { return bg(e, _a) || bg(e, Dg) } function bg(e, n) { return e.hasOwnProperty(n) ? e[n] : null } function ma(e) { return e && (e.hasOwnProperty(_u) || e.hasOwnProperty(kI)) ? e[_u] : null } const _a = he({ \u0275prov: he }), _u = he({ \u0275inj: he }), Dg = he({ ngInjectableDef: he }), kI = he({ ngInjectorDef: he }); var J = function (e) { return e[e.Default = 0] = "Default", e[e.Host = 1] = "Host", e[e.Self = 2] = "Self", e[e.SkipSelf = 4] = "SkipSelf", e[e.Optional = 8] = "Optional", e }(J || {}); let vu; function yt(e) { const n = vu; return vu = e, n } function wg(e, n, t) { const r = ga(e); return r && "root" == r.providedIn ? void 0 === r.value ? r.value = r.factory() : r.value : t & J.Optional ? null : void 0 !== n ? n : void mu($e(e)) } const Ce = globalThis; class A { constructor(n, t) { this._desc = n, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof t ? this.__NG_ELEMENT_ID__ = t : void 0 !== t && (this.\u0275prov = F({ token: this, providedIn: t.providedIn || "root", factory: t.factory })) } get multi() { return this } toString() { return `InjectionToken ${this._desc}` } } const yo = {}, wu = "__NG_DI_FLAG__", va = "ngTempTokenPath", NI = /\n/gm, Ig = "__source"; let Xr; function Xn(e) { const n = Xr; return Xr = e, n } function LI(e, n = J.Default) { if (void 0 === Xr) throw new x(-203, !1); return null === Xr ? wg(e, void 0, n) : Xr.get(e, n & J.Optional ? null : void 0, n) } function k(e, n = J.Default) { return (function Cg() { return vu }() || LI)(G(e), n) } function O(e, n = J.Default) { return k(e, ya(n)) } function ya(e) { return typeof e > "u" || "number" == typeof e ? e : 0 | (e.optional && 8) | (e.host && 1) | (e.self && 2) | (e.skipSelf && 4) } function Eu(e) { const n = []; for (let t = 0; t < e.length; t++) { const r = G(e[t]); if (Array.isArray(r)) { if (0 === r.length) throw new x(900, !1); let i, o = J.Default; for (let s = 0; s < r.length; s++) { const a = r[s], l = jI(a); "number" == typeof l ? -1 === l ? i = a.token : o |= l : i = a } n.push(k(i, o)) } else n.push(k(r)) } return n } function bo(e, n) { return e[wu] = n, e.prototype[wu] = n, e } function jI(e) { return e[wu] } function kn(e) { return { toString: e }.toString() } var ba = function (e) { return e[e.OnPush = 0] = "OnPush", e[e.Default = 1] = "Default", e }(ba || {}), Qt = function (e) { return e[e.Emulated = 0] = "Emulated", e[e.None = 2] = "None", e[e.ShadowDom = 3] = "ShadowDom", e }(Qt || {}); const dn = {}, ae = [], Da = he({ \u0275cmp: he }), Iu = he({ \u0275dir: he }), Su = he({ \u0275pipe: he }), Tg = he({ \u0275mod: he }), Rn = he({ \u0275fac: he }), Do = he({ __NG_ELEMENT_ID__: he }), xg = he({ __NG_ENV_ID__: he }); function Mg(e, n, t) { let r = e.length; for (; ;) { const i = e.indexOf(n, t); if (-1 === i) return i; if (0 === i || e.charCodeAt(i - 1) <= 32) { const o = n.length; if (i + o === r || e.charCodeAt(i + o) <= 32) return i } t = i + 1 } } function Tu(e, n, t) { let r = 0; for (; r < t.length;) { const i = t[r]; if ("number" == typeof i) { if (0 !== i) break; r++; const o = t[r++], s = t[r++], a = t[r++]; e.setAttribute(n, s, a, o) } else { const o = i, s = t[++r]; kg(o) ? e.setProperty(n, o, s) : e.setAttribute(n, o, s), r++ } } return r } function Ag(e) { return 3 === e || 4 === e || 6 === e } function kg(e) { return 64 === e.charCodeAt(0) } function Co(e, n) { if (null !== n && 0 !== n.length) if (null === e || 0 === e.length) e = n.slice(); else { let t = -1; for (let r = 0; r < n.length; r++) { const i = n[r]; "number" == typeof i ? t = i : 0 === t || Rg(e, t, i, null, -1 === t || 2 === t ? n[++r] : null) } } return e } function Rg(e, n, t, r, i) { let o = 0, s = e.length; if (-1 === n) s = -1; else for (; o < e.length;) { const a = e[o++]; if ("number" == typeof a) { if (a === n) { s = -1; break } if (a > n) { s = o - 1; break } } } for (; o < e.length;) { const a = e[o]; if ("number" == typeof a) break; if (a === t) { if (null === r) return void (null !== i && (e[o + 1] = i)); if (r === e[o + 1]) return void (e[o + 2] = i) } o++, null !== r && o++, null !== i && o++ } -1 !== s && (e.splice(s, 0, n), o = s + 1), e.splice(o++, 0, t), null !== r && e.splice(o++, 0, r), null !== i && e.splice(o++, 0, i) } const Pg = "ng-template"; function UI(e, n, t) { let r = 0, i = !0; for (; r < e.length;) { let o = e[r++]; if ("string" == typeof o && i) { const s = e[r++]; if (t && "class" === o && -1 !== Mg(s.toLowerCase(), n, 0)) return !0 } else { if (1 === o) { for (; r < e.length && "string" == typeof (o = e[r++]);)if (o.toLowerCase() === n) return !0; return !1 } "number" == typeof o && (i = !1) } } return !1 } function Ng(e) { return 4 === e.type && e.value !== Pg } function HI(e, n, t) { return n === (4 !== e.type || t ? e.value : Pg) } function $I(e, n, t) { let r = 4; const i = e.attrs || [], o = function qI(e) { for (let n = 0; n < e.length; n++)if (Ag(e[n])) return n; return e.length }(i); let s = !1; for (let a = 0; a < n.length; a++) { const l = n[a]; if ("number" != typeof l) { if (!s) if (4 & r) { if (r = 2 | 1 & r, "" !== l && !HI(e, l, t) || "" === l && 1 === n.length) { if (Xt(r)) return !1; s = !0 } } else { const c = 8 & r ? l : n[++a]; if (8 & r && null !== e.attrs) { if (!UI(e.attrs, c, t)) { if (Xt(r)) return !1; s = !0 } continue } const d = zI(8 & r ? "class" : l, i, Ng(e), t); if (-1 === d) { if (Xt(r)) return !1; s = !0; continue } if ("" !== c) { let p; p = d > o ? "" : i[d + 1].toLowerCase(); const m = 8 & r ? p : null; if (m && -1 !== Mg(m, c, 0) || 2 & r && c !== p) { if (Xt(r)) return !1; s = !0 } } } } else { if (!s && !Xt(r) && !Xt(l)) return !1; if (s && Xt(l)) continue; s = !1, r = l | 1 & r } } return Xt(r) || s } function Xt(e) { return 0 == (1 & e) } function zI(e, n, t, r) { if (null === n) return -1; let i = 0; if (r || !t) { let o = !1; for (; i < n.length;) { const s = n[i]; if (s === e) return i; if (3 === s || 6 === s) o = !0; else { if (1 === s || 2 === s) { let a = n[++i]; for (; "string" == typeof a;)a = n[++i]; continue } if (4 === s) break; if (0 === s) { i += 4; continue } } i += o ? 1 : 2 } return -1 } return function WI(e, n) { let t = e.indexOf(4); if (t > -1) for (t++; t < e.length;) { const r = e[t]; if ("number" == typeof r) return -1; if (r === n) return t; t++ } return -1 }(n, e) } function Og(e, n, t = !1) { for (let r = 0; r < n.length; r++)if ($I(e, n[r], t)) return !0; return !1 } function Fg(e, n) { return e ? ":not(" + n.trim() + ")" : n } function KI(e) { let n = e[0], t = 1, r = 2, i = "", o = !1; for (; t < e.length;) { let s = e[t]; if ("string" == typeof s) if (2 & r) { const a = e[++t]; i += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]" } else 8 & r ? i += "." + s : 4 & r && (i += " " + s); else "" !== i && !Xt(s) && (n += Fg(o, i), i = ""), r = s, o = o || !Xt(r); t++ } return "" !== i && (n += Fg(o, i)), n } function rt(e) { return kn(() => { const n = jg(e), t = { ...n, decls: e.decls, vars: e.vars, template: e.template, consts: e.consts || null, ngContentSelectors: e.ngContentSelectors, onPush: e.changeDetection === ba.OnPush, directiveDefs: null, pipeDefs: null, dependencies: n.standalone && e.dependencies || null, getStandaloneInjector: null, signals: e.signals ?? !1, data: e.data || {}, encapsulation: e.encapsulation || Qt.Emulated, styles: e.styles || ae, _: null, schemas: e.schemas || null, tView: null, id: "" }; Vg(t); const r = e.dependencies; return t.directiveDefs = Ca(r, !1), t.pipeDefs = Ca(r, !0), t.id = function rS(e) { let n = 0; const t = [e.selectors, e.ngContentSelectors, e.hostVars, e.hostAttrs, e.consts, e.vars, e.decls, e.encapsulation, e.standalone, e.signals, e.exportAs, JSON.stringify(e.inputs), JSON.stringify(e.outputs), Object.getOwnPropertyNames(e.type.prototype), !!e.contentQueries, !!e.viewQuery].join("|"); for (const i of t) n = Math.imul(31, n) + i.charCodeAt(0) << 0; return n += 2147483648, "c" + n }(t), t }) } function JI(e) { return ie(e) || Ye(e) } function eS(e) { return null !== e } function bt(e) { return kn(() => ({ type: e.type, bootstrap: e.bootstrap || ae, declarations: e.declarations || ae, imports: e.imports || ae, exports: e.exports || ae, transitiveCompileScopes: null, schemas: e.schemas || null, id: e.id || null })) } function Lg(e, n) { if (null == e) return dn; const t = {}; for (const r in e) if (e.hasOwnProperty(r)) { let i = e[r], o = i; Array.isArray(i) && (o = i[1], i = i[0]), t[i] = r, n && (n[i] = o) } return t } function j(e) { return kn(() => { const n = jg(e); return Vg(n), n }) } function Dt(e) { return { type: e.type, name: e.name, factory: null, pure: !1 !== e.pure, standalone: !0 === e.standalone, onDestroy: e.type.prototype.ngOnDestroy || null } } function ie(e) { return e[Da] || null } function Ye(e) { return e[Iu] || null } function ut(e) { return e[Su] || null } function At(e, n) { const t = e[Tg] || null; if (!t && !0 === n) throw new Error(`Type ${$e(e)} does not have '\u0275mod' property.`); return t } function jg(e) { const n = {}; return { type: e.type, providersResolver: null, factory: null, hostBindings: e.hostBindings || null, hostVars: e.hostVars || 0, hostAttrs: e.hostAttrs || null, contentQueries: e.contentQueries || null, declaredInputs: n, inputTransforms: null, inputConfig: e.inputs || dn, exportAs: e.exportAs || null, standalone: !0 === e.standalone, signals: !0 === e.signals, selectors: e.selectors || ae, viewQuery: e.viewQuery || null, features: e.features || null, setInput: null, findHostDirectiveDefs: null, hostDirectives: null, inputs: Lg(e.inputs, n), outputs: Lg(e.outputs) } } function Vg(e) { e.features?.forEach(n => n(e)) } function Ca(e, n) { if (!e) return null; const t = n ? ut : JI; return () => ("function" == typeof e ? e() : e).map(r => t(r)).filter(eS) } const Ae = 0, N = 1, K = 2, Te = 3, Jt = 4, wo = 5, it = 6, ei = 7, Oe = 8, Jn = 9, ti = 10, W = 11, Eo = 12, Bg = 13, ni = 14, Fe = 15, Io = 16, ri = 17, fn = 18, So = 19, Ug = 20, er = 21, Pn = 22, To = 23, xo = 24, ee = 25, xu = 1, Hg = 2, hn = 7, ii = 9, Qe = 11; function Ct(e) { return Array.isArray(e) && "object" == typeof e[xu] } function dt(e) { return Array.isArray(e) && !0 === e[xu] } function Mu(e) { return 0 != (4 & e.flags) } function wr(e) { return e.componentOffset > -1 } function Ea(e) { return 1 == (1 & e.flags) } function en(e) { return !!e.template } function Au(e) { return 0 != (512 & e[K]) } function Er(e, n) { return e.hasOwnProperty(Rn) ? e[Rn] : null } let Xe = null, Ia = !1; function Ut(e) { const n = Xe; return Xe = e, n } const Gg = { version: 0, dirty: !1, producerNode: void 0, producerLastReadVersion: void 0, producerIndexOfThis: void 0, nextProducerIndex: 0, liveConsumerNode: void 0, liveConsumerIndexOfThis: void 0, consumerAllowSignalWrites: !1, consumerIsAlwaysLive: !1, producerMustRecompute: () => !1, producerRecomputeValue: () => { }, consumerMarkedDirty: () => { } }; function Wg(e) { if (!Ao(e) || e.dirty) { if (!e.producerMustRecompute(e) && !Yg(e)) return void (e.dirty = !1); e.producerRecomputeValue(e), e.dirty = !1 } } function Kg(e) { e.dirty = !0, function Zg(e) { if (void 0 === e.liveConsumerNode) return; const n = Ia; Ia = !0; try { for (const t of e.liveConsumerNode) t.dirty || Kg(t) } finally { Ia = n } }(e), e.consumerMarkedDirty?.(e) } function Ru(e) { return e && (e.nextProducerIndex = 0), Ut(e) } function Pu(e, n) { if (Ut(n), e && void 0 !== e.producerNode && void 0 !== e.producerIndexOfThis && void 0 !== e.producerLastReadVersion) { if (Ao(e)) for (let t = e.nextProducerIndex; t < e.producerNode.length; t++)Sa(e.producerNode[t], e.producerIndexOfThis[t]); for (; e.producerNode.length > e.nextProducerIndex;)e.producerNode.pop(), e.producerLastReadVersion.pop(), e.producerIndexOfThis.pop() } } function Yg(e) { oi(e); for (let n = 0; n < e.producerNode.length; n++) { const t = e.producerNode[n], r = e.producerLastReadVersion[n]; if (r !== t.version || (Wg(t), r !== t.version)) return !0 } return !1 } function Qg(e) { if (oi(e), Ao(e)) for (let n = 0; n < e.producerNode.length; n++)Sa(e.producerNode[n], e.producerIndexOfThis[n]); e.producerNode.length = e.producerLastReadVersion.length = e.producerIndexOfThis.length = 0, e.liveConsumerNode && (e.liveConsumerNode.length = e.liveConsumerIndexOfThis.length = 0) } function Sa(e, n) { if (function Jg(e) { e.liveConsumerNode ??= [], e.liveConsumerIndexOfThis ??= [] }(e), oi(e), 1 === e.liveConsumerNode.length) for (let r = 0; r < e.producerNode.length; r++)Sa(e.producerNode[r], e.producerIndexOfThis[r]); const t = e.liveConsumerNode.length - 1; if (e.liveConsumerNode[n] = e.liveConsumerNode[t], e.liveConsumerIndexOfThis[n] = e.liveConsumerIndexOfThis[t], e.liveConsumerNode.length--, e.liveConsumerIndexOfThis.length--, n < e.liveConsumerNode.length) { const r = e.liveConsumerIndexOfThis[n], i = e.liveConsumerNode[n]; oi(i), i.producerIndexOfThis[r] = n } } function Ao(e) { return e.consumerIsAlwaysLive || (e?.liveConsumerNode?.length ?? 0) > 0 } function oi(e) { e.producerNode ??= [], e.producerIndexOfThis ??= [], e.producerLastReadVersion ??= [] } let em = null; function rm(e) { const n = Ut(null); try { return e() } finally { Ut(n) } } const im = () => { }, mS = (() => ({ ...Gg, consumerIsAlwaysLive: !0, consumerAllowSignalWrites: !1, consumerMarkedDirty: e => { e.schedule(e.ref) }, hasRun: !1, cleanupFn: im }))(); class _S { constructor(n, t, r) { this.previousValue = n, this.currentValue = t, this.firstChange = r } isFirstChange() { return this.firstChange } } function kt() { return om } function om(e) { return e.type.prototype.ngOnChanges && (e.setInput = yS), vS } function vS() { const e = am(this), n = e?.current; if (n) { const t = e.previous; if (t === dn) e.previous = n; else for (let r in n) t[r] = n[r]; e.current = null, this.ngOnChanges(n) } } function yS(e, n, t, r) { const i = this.declaredInputs[t], o = am(e) || function bS(e, n) { return e[sm] = n }(e, { previous: dn, current: null }), s = o.current || (o.current = {}), a = o.previous, l = a[i]; s[i] = new _S(l && l.currentValue, n, a === dn), e[r] = n } kt.ngInherit = !0; const sm = "__ngSimpleChanges__"; function am(e) { return e[sm] || null } const pn = function (e, n, t) { }, lm = "svg"; function we(e) { for (; Array.isArray(e);)e = e[Ae]; return e } function Ta(e, n) { return we(n[e]) } function wt(e, n) { return we(n[e.index]) } function um(e, n) { return e.data[n] } function si(e, n) { return e[n] } function Rt(e, n) { const t = n[e]; return Ct(t) ? t : t[Ae] } function nr(e, n) { return null == n ? null : e[n] } function dm(e) { e[ri] = 0 } function SS(e) { 1024 & e[K] || (e[K] |= 1024, hm(e, 1)) } function fm(e) { 1024 & e[K] && (e[K] &= -1025, hm(e, -1)) } function hm(e, n) { let t = e[Te]; if (null === t) return; t[wo] += n; let r = t; for (t = t[Te]; null !== t && (1 === n && 1 === r[wo] || -1 === n && 0 === r[wo]);)t[wo] += n, r = t, t = t[Te] } const z = { lFrame: Em(null), bindingsEnabled: !0, skipHydrationRootTNode: null }; function mm() { return z.bindingsEnabled } function S() { return z.lFrame.lView } function oe() { return z.lFrame.tView } function V(e) { return z.lFrame.contextLView = e, e[Oe] } function B(e) { return z.lFrame.contextLView = null, e } function Je() { let e = _m(); for (; null !== e && 64 === e.type;)e = e.parent; return e } function _m() { return z.lFrame.currentTNode } function gn(e, n) { const t = z.lFrame; t.currentTNode = e, t.isParent = n } function ju() { return z.lFrame.isParent } function Vu() { z.lFrame.isParent = !1 } function ft() { const e = z.lFrame; let n = e.bindingRootIndex; return -1 === n && (n = e.bindingRootIndex = e.tView.bindingStartIndex), n } function Nn() { return z.lFrame.bindingIndex } function li() { return z.lFrame.bindingIndex++ } function On(e) { const n = z.lFrame, t = n.bindingIndex; return n.bindingIndex = n.bindingIndex + e, t } function jS(e, n) { const t = z.lFrame; t.bindingIndex = t.bindingRootIndex = e, Bu(n) } function Bu(e) { z.lFrame.currentDirectiveIndex = e } function Dm() { return z.lFrame.currentQueryIndex } function Hu(e) { z.lFrame.currentQueryIndex = e } function BS(e) { const n = e[N]; return 2 === n.type ? n.declTNode : 1 === n.type ? e[it] : null } function Cm(e, n, t) { if (t & J.SkipSelf) { let i = n, o = e; for (; !(i = i.parent, null !== i || t & J.Host || (i = BS(o), null === i || (o = o[ni], 10 & i.type)));); if (null === i) return !1; n = i, e = o } const r = z.lFrame = wm(); return r.currentTNode = n, r.lView = e, !0 } function $u(e) { const n = wm(), t = e[N]; z.lFrame = n, n.currentTNode = t.firstChild, n.lView = e, n.tView = t, n.contextLView = e, n.bindingIndex = t.bindingStartIndex, n.inI18n = !1 } function wm() { const e = z.lFrame, n = null === e ? null : e.child; return null === n ? Em(e) : n } function Em(e) { const n = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: e, child: null, inI18n: !1 }; return null !== e && (e.child = n), n } function Im() { const e = z.lFrame; return z.lFrame = e.parent, e.currentTNode = null, e.lView = null, e } const Sm = Im; function zu() { const e = Im(); e.isParent = !0, e.tView = null, e.selectedIndex = -1, e.contextLView = null, e.elementDepthCount = 0, e.currentDirectiveIndex = -1, e.currentNamespace = null, e.bindingRootIndex = -1, e.bindingIndex = -1, e.currentQueryIndex = 0 } function ht() { return z.lFrame.selectedIndex } function Ir(e) { z.lFrame.selectedIndex = e } function Me() { const e = z.lFrame; return um(e.tView, e.selectedIndex) } function Ee() { z.lFrame.currentNamespace = lm } function Le() { !function zS() { z.lFrame.currentNamespace = null }() } let xm = !0; function xa() { return xm } function rr(e) { xm = e } function Ma(e, n) { for (let t = n.directiveStart, r = n.directiveEnd; t < r; t++) { const o = e.data[t].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: l, ngAfterViewChecked: c, ngOnDestroy: u } = o; s && (e.contentHooks ??= []).push(-t, s), a && ((e.contentHooks ??= []).push(t, a), (e.contentCheckHooks ??= []).push(t, a)), l && (e.viewHooks ??= []).push(-t, l), c && ((e.viewHooks ??= []).push(t, c), (e.viewCheckHooks ??= []).push(t, c)), null != u && (e.destroyHooks ??= []).push(t, u) } } function Aa(e, n, t) { Mm(e, n, 3, t) } function ka(e, n, t, r) { (3 & e[K]) === t && Mm(e, n, t, r) } function Gu(e, n) { let t = e[K]; (3 & t) === n && (t &= 8191, t += 1, e[K] = t) } function Mm(e, n, t, r) { const o = r ?? -1, s = n.length - 1; let a = 0; for (let l = void 0 !== r ? 65535 & e[ri] : 0; l < s; l++)if ("number" == typeof n[l + 1]) { if (a = n[l], null != r && a >= r) break } else n[l] < 0 && (e[ri] += 65536), (a < o || -1 == o) && (qS(e, t, n, l), e[ri] = (4294901760 & e[ri]) + l + 2), l++ } function Am(e, n) { pn(4, e, n); const t = Ut(null); try { n.call(e) } finally { Ut(t), pn(5, e, n) } } function qS(e, n, t, r) { const i = t[r] < 0, o = t[r + 1], a = e[i ? -t[r] : t[r]]; i ? e[K] >> 13 < e[ri] >> 16 && (3 & e[K]) === n && (e[K] += 8192, Am(a, o)) : Am(a, o) } const ci = -1; class Ro { constructor(n, t, r) { this.factory = n, this.resolving = !1, this.canSeeViewProviders = t, this.injectImpl = r } } function Wu(e) { return e !== ci } function Po(e) { return 32767 & e } function No(e, n) { let t = function YS(e) { return e >> 16 }(e), r = n; for (; t > 0;)r = r[ni], t--; return r } let Zu = !0; function Ra(e) { const n = Zu; return Zu = e, n } const km = 255, Rm = 5; let QS = 0; const mn = {}; function Pa(e, n) { const t = Pm(e, n); if (-1 !== t) return t; const r = n[N]; r.firstCreatePass && (e.injectorIndex = n.length, Ku(r.data, e), Ku(n, null), Ku(r.blueprint, null)); const i = Na(e, n), o = e.injectorIndex; if (Wu(i)) { const s = Po(i), a = No(i, n), l = a[N].data; for (let c = 0; c < 8; c++)n[o + c] = a[s + c] | l[s + c] } return n[o + 8] = i, o } function Ku(e, n) { e.push(0, 0, 0, 0, 0, 0, 0, 0, n) } function Pm(e, n) { return -1 === e.injectorIndex || e.parent && e.parent.injectorIndex === e.injectorIndex || null === n[e.injectorIndex + 8] ? -1 : e.injectorIndex } function Na(e, n) { if (e.parent && -1 !== e.parent.injectorIndex) return e.parent.injectorIndex; let t = 0, r = null, i = n; for (; null !== i;) { if (r = Bm(i), null === r) return ci; if (t++, i = i[ni], -1 !== r.injectorIndex) return r.injectorIndex | t << 16 } return ci } function Yu(e, n, t) { !function XS(e, n, t) { let r; "string" == typeof t ? r = t.charCodeAt(0) || 0 : t.hasOwnProperty(Do) && (r = t[Do]), null == r && (r = t[Do] = QS++); const i = r & km; n.data[e + (i >> Rm)] |= 1 << i }(e, n, t) } function Nm(e, n, t) { if (t & J.Optional || void 0 !== e) return e; mu() } function Om(e, n, t, r) { if (t & J.Optional && void 0 === r && (r = null), !(t & (J.Self | J.Host))) { const i = e[Jn], o = yt(void 0); try { return i ? i.get(n, r, t & J.Optional) : wg(n, r, t & J.Optional) } finally { yt(o) } } return Nm(r, 0, t) } function Fm(e, n, t, r = J.Default, i) { if (null !== e) { if (2048 & n[K] && !(r & J.Self)) { const s = function iT(e, n, t, r, i) { let o = e, s = n; for (; null !== o && null !== s && 2048 & s[K] && !(512 & s[K]);) { const a = Lm(o, s, t, r | J.Self, mn); if (a !== mn) return a; let l = o.parent; if (!l) { const c = s[Ug]; if (c) { const u = c.get(t, mn, r); if (u !== mn) return u } l = Bm(s), s = s[ni] } o = l } return i }(e, n, t, r, mn); if (s !== mn) return s } const o = Lm(e, n, t, r, mn); if (o !== mn) return o } return Om(n, t, r, i) } function Lm(e, n, t, r, i) { const o = function tT(e) { if ("string" == typeof e) return e.charCodeAt(0) || 0; const n = e.hasOwnProperty(Do) ? e[Do] : void 0; return "number" == typeof n ? n >= 0 ? n & km : rT : n }(t); if ("function" == typeof o) { if (!Cm(n, e, r)) return r & J.Host ? Nm(i, 0, r) : Om(n, t, r, i); try { let s; if (s = o(r), null != s || r & J.Optional) return s; mu() } finally { Sm() } } else if ("number" == typeof o) { let s = null, a = Pm(e, n), l = ci, c = r & J.Host ? n[Fe][it] : null; for ((-1 === a || r & J.SkipSelf) && (l = -1 === a ? Na(e, n) : n[a + 8], l !== ci && Vm(r, !1) ? (s = n[N], a = Po(l), n = No(l, n)) : a = -1); -1 !== a;) { const u = n[N]; if (jm(o, a, u.data)) { const d = eT(a, n, t, s, r, c); if (d !== mn) return d } l = n[a + 8], l !== ci && Vm(r, n[N].data[a + 8] === c) && jm(o, a, n) ? (s = u, a = Po(l), n = No(l, n)) : a = -1 } } return i } function eT(e, n, t, r, i, o) { const s = n[N], a = s.data[e + 8], u = Oa(a, s, t, null == r ? wr(a) && Zu : r != s && 0 != (3 & a.type), i & J.Host && o === a); return null !== u ? Sr(n, s, u, a) : mn } function Oa(e, n, t, r, i) { const o = e.providerIndexes, s = n.data, a = 1048575 & o, l = e.directiveStart, u = o >> 20, p = i ? a + u : e.directiveEnd; for (let m = r ? a : a + u; m < p; m++) { const v = s[m]; if (m < l && t === v || m >= l && v.type === t) return m } if (i) { const m = s[l]; if (m && en(m) && m.type === t) return l } return null } function Sr(e, n, t, r) { let i = e[t]; const o = n.data; if (function WS(e) { return e instanceof Ro }(i)) { const s = i; s.resolving && function EI(e, n) { const t = n ? `. Dependency path: ${n.join(" > ")} > ${e}` : ""; throw new x(-200, `Circular dependency in DI detected for ${e}${t}`) }(function de(e) { return "function" == typeof e ? e.name || e.toString() : "object" == typeof e && null != e && "function" == typeof e.type ? e.type.name || e.type.toString() : q(e) }(o[t])); const a = Ra(s.canSeeViewProviders); s.resolving = !0; const c = s.injectImpl ? yt(s.injectImpl) : null; Cm(e, r, J.Default); try { i = e[t] = s.factory(void 0, o, e, r), n.firstCreatePass && t >= r.directiveStart && function GS(e, n, t) { const { ngOnChanges: r, ngOnInit: i, ngDoCheck: o } = n.type.prototype; if (r) { const s = om(n); (t.preOrderHooks ??= []).push(e, s), (t.preOrderCheckHooks ??= []).push(e, s) } i && (t.preOrderHooks ??= []).push(0 - e, i), o && ((t.preOrderHooks ??= []).push(e, o), (t.preOrderCheckHooks ??= []).push(e, o)) }(t, o[t], n) } finally { null !== c && yt(c), Ra(a), s.resolving = !1, Sm() } } return i } function jm(e, n, t) { return !!(t[n + (e >> Rm)] & 1 << e) } function Vm(e, n) { return !(e & J.Self || e & J.Host && n) } class pt { constructor(n, t) { this._tNode = n, this._lView = t } get(n, t, r) { return Fm(this._tNode, this._lView, n, ya(r), t) } } function rT() { return new pt(Je(), S()) } function et(e) { return kn(() => { const n = e.prototype.constructor, t = n[Rn] || Qu(n), r = Object.prototype; let i = Object.getPrototypeOf(e.prototype).constructor; for (; i && i !== r;) { const o = i[Rn] || Qu(i); if (o && o !== t) return o; i = Object.getPrototypeOf(i) } return o => new o }) } function Qu(e) { return pu(e) ? () => { const n = Qu(G(e)); return n && n() } : Er(e) } function Bm(e) { const n = e[N], t = n.type; return 2 === t ? n.declTNode : 1 === t ? e[it] : null } const di = "__parameters__"; function hi(e, n, t) { return kn(() => { const r = function Xu(e) { return function (...t) { if (e) { const r = e(...t); for (const i in r) this[i] = r[i] } } }(n); function i(...o) { if (this instanceof i) return r.apply(this, o), this; const s = new i(...o); return a.annotation = s, a; function a(l, c, u) { const d = l.hasOwnProperty(di) ? l[di] : Object.defineProperty(l, di, { value: [] })[di]; for (; d.length <= u;)d.push(null); return (d[u] = d[u] || []).push(s), l } } return t && (i.prototype = Object.create(t.prototype)), i.prototype.ngMetadataName = e, i.annotationCls = i, i }) } function gi(e, n) { e.forEach(t => Array.isArray(t) ? gi(t, n) : n(t)) } function Hm(e, n, t) { n >= e.length ? e.push(t) : e.splice(n, 0, t) } function La(e, n) { return n >= e.length - 1 ? e.pop() : e.splice(n, 1)[0] } function Pt(e, n, t) { let r = mi(e, n); return r >= 0 ? e[1 | r] = t : (r = ~r, function dT(e, n, t, r) { let i = e.length; if (i == n) e.push(t, r); else if (1 === i) e.push(r, e[0]), e[0] = t; else { for (i--, e.push(e[i - 1], e[i]); i > n;)e[i] = e[i - 2], i--; e[n] = t, e[n + 1] = r } }(e, r, n, t)), r } function Ju(e, n) { const t = mi(e, n); if (t >= 0) return e[1 | t] } function mi(e, n) { return function $m(e, n, t) { let r = 0, i = e.length >> t; for (; i !== r;) { const o = r + (i - r >> 1), s = e[o << t]; if (n === s) return o << t; s > n ? i = o : r = o + 1 } return ~(i << t) }(e, n, 1) } const Va = bo(hi("Optional"), 8), Ba = bo(hi("SkipSelf"), 4); function Ga(e) { return 128 == (128 & e.flags) } var ir = function (e) { return e[e.Important = 1] = "Important", e[e.DashCase = 2] = "DashCase", e }(ir || {}); const RT = /^>|^->|<!--|-->|--!>|<!-$/g, PT = /(<|>)/g, NT = "\u200b$1\u200b"; const id = new Map; let OT = 0; const sd = "__ngContext__"; function ot(e, n) { Ct(n) ? (e[sd] = n[So], function LT(e) { id.set(e[So], e) }(n)) : e[sd] = n } let ad; function ld(e, n) { return ad(e, n) } function Bo(e) { const n = e[Te]; return dt(n) ? n[Te] : n } function c_(e) { return d_(e[Eo]) } function u_(e) { return d_(e[Jt]) } function d_(e) { for (; null !== e && !dt(e);)e = e[Jt]; return e } function yi(e, n, t, r, i) { if (null != r) { let o, s = !1; dt(r) ? o = r : Ct(r) && (s = !0, r = r[Ae]); const a = we(r); 0 === e && null !== t ? null == i ? g_(n, t, a) : Tr(n, t, a, i || null, !0) : 1 === e && null !== t ? Tr(n, t, a, i || null, !0) : 2 === e ? function Xa(e, n, t) { const r = Ya(e, n); r && function nx(e, n, t, r) { e.removeChild(n, t, r) }(e, r, n, t) }(n, a, s) : 3 === e && n.destroyNode(a), null != o && function ox(e, n, t, r, i) { const o = t[hn]; o !== we(t) && yi(n, e, r, o, i); for (let a = Qe; a < t.length; a++) { const l = t[a]; Ho(l[N], l, e, n, r, o) } }(n, e, o, t, i) } } function cd(e, n) { return e.createComment(function t_(e) { return e.replace(RT, n => n.replace(PT, NT)) }(n)) } function Za(e, n, t) { return e.createElement(n, t) } function h_(e, n) { const t = e[ii], r = t.indexOf(n); fm(n), t.splice(r, 1) } function Ka(e, n) { if (e.length <= Qe) return; const t = Qe + n, r = e[t]; if (r) { const i = r[Io]; null !== i && i !== e && h_(i, r), n > 0 && (e[t - 1][Jt] = r[Jt]); const o = La(e, Qe + n); !function ZT(e, n) { Ho(e, n, n[W], 2, null, null), n[Ae] = null, n[it] = null }(r[N], r); const s = o[fn]; null !== s && s.detachView(o[N]), r[Te] = null, r[Jt] = null, r[K] &= -129 } return r } function ud(e, n) { if (!(256 & n[K])) { const t = n[W]; n[To] && Qg(n[To]), n[xo] && Qg(n[xo]), t.destroyNode && Ho(e, n, t, 3, null, null), function QT(e) { let n = e[Eo]; if (!n) return dd(e[N], e); for (; n;) { let t = null; if (Ct(n)) t = n[Eo]; else { const r = n[Qe]; r && (t = r) } if (!t) { for (; n && !n[Jt] && n !== e;)Ct(n) && dd(n[N], n), n = n[Te]; null === n && (n = e), Ct(n) && dd(n[N], n), t = n && n[Jt] } n = t } }(n) } } function dd(e, n) { if (!(256 & n[K])) { n[K] &= -129, n[K] |= 256, function tx(e, n) { let t; if (null != e && null != (t = e.destroyHooks)) for (let r = 0; r < t.length; r += 2) { const i = n[t[r]]; if (!(i instanceof Ro)) { const o = t[r + 1]; if (Array.isArray(o)) for (let s = 0; s < o.length; s += 2) { const a = i[o[s]], l = o[s + 1]; pn(4, a, l); try { l.call(a) } finally { pn(5, a, l) } } else { pn(4, i, o); try { o.call(i) } finally { pn(5, i, o) } } } } }(e, n), function ex(e, n) { const t = e.cleanup, r = n[ei]; if (null !== t) for (let o = 0; o < t.length - 1; o += 2)if ("string" == typeof t[o]) { const s = t[o + 3]; s >= 0 ? r[s]() : r[-s].unsubscribe(), o += 2 } else t[o].call(r[t[o + 1]]); null !== r && (n[ei] = null); const i = n[er]; if (null !== i) { n[er] = null; for (let o = 0; o < i.length; o++)(0, i[o])() } }(e, n), 1 === n[N].type && n[W].destroy(); const t = n[Io]; if (null !== t && dt(n[Te])) { t !== n[Te] && h_(t, n); const r = n[fn]; null !== r && r.detachView(e) } !function jT(e) { id.delete(e[So]) }(n) } } function fd(e, n, t) { return function p_(e, n, t) { let r = n; for (; null !== r && 40 & r.type;)r = (n = r).parent; if (null === r) return t[Ae]; { const { componentOffset: i } = r; if (i > -1) { const { encapsulation: o } = e.data[r.directiveStart + i]; if (o === Qt.None || o === Qt.Emulated) return null } return wt(r, t) } }(e, n.parent, t) } function Tr(e, n, t, r, i) { e.insertBefore(n, t, r, i) } function g_(e, n, t) { e.appendChild(n, t) } function m_(e, n, t, r, i) { null !== r ? Tr(e, n, t, r, i) : g_(e, n, t) } function Ya(e, n) { return e.parentNode(n) } let hd, _d, el, y_ = function v_(e, n, t) { return 40 & e.type ? wt(e, t) : null }; function Qa(e, n, t, r) { const i = fd(e, r, n), o = n[W], a = function __(e, n, t) { return y_(e, n, t) }(r.parent || n[it], r, n); if (null != i) if (Array.isArray(t)) for (let l = 0; l < t.length; l++)m_(o, i, t[l], a, !1); else m_(o, i, t, a, !1); void 0 !== hd && hd(o, r, n, t, i) } function Uo(e, n) { if (null !== n) { const t = n.type; if (3 & t) return wt(n, e); if (4 & t) return pd(-1, e[n.index]); if (8 & t) { const r = n.child; if (null !== r) return Uo(e, r); { const i = e[n.index]; return dt(i) ? pd(-1, i) : we(i) } } if (32 & t) return ld(n, e)() || we(e[n.index]); { const r = D_(e, n); return null !== r ? Array.isArray(r) ? r[0] : Uo(Bo(e[Fe]), r) : Uo(e, n.next) } } return null } function D_(e, n) { return null !== n ? e[Fe][it].projection[n.projection] : null } function pd(e, n) { const t = Qe + e + 1; if (t < n.length) { const r = n[t], i = r[N].firstChild; if (null !== i) return Uo(r, i) } return n[hn] } function gd(e, n, t, r, i, o, s) { for (; null != t;) { const a = r[t.index], l = t.type; if (s && 0 === n && (a && ot(we(a), r), t.flags |= 2), 32 != (32 & t.flags)) if (8 & l) gd(e, n, t.child, r, i, o, !1), yi(n, e, i, a, o); else if (32 & l) { const c = ld(t, r); let u; for (; u = c();)yi(n, e, i, u, o); yi(n, e, i, a, o) } else 16 & l ? w_(e, n, r, t, i, o) : yi(n, e, i, a, o); t = s ? t.projectionNext : t.next } } function Ho(e, n, t, r, i, o) { gd(t, r, e.firstChild, n, i, o, !1) } function w_(e, n, t, r, i, o) { const s = t[Fe], l = s[it].projection[r.projection]; if (Array.isArray(l)) for (let c = 0; c < l.length; c++)yi(n, e, i, l[c], o); else { let c = l; const u = s[Te]; Ga(r) && (c.flags |= 128), gd(e, n, c, u, i, o, !0) } } function E_(e, n, t) { "" === t ? e.removeAttribute(n, "class") : e.setAttribute(n, "class", t) } function I_(e, n, t) { const { mergedAttrs: r, classes: i, styles: o } = t; null !== r && Tu(e, n, r), null !== i && E_(e, n, i), null !== o && function ax(e, n, t) { e.setAttribute(n, "style", t) }(e, n, o) } function x_(e) { return function vd() { if (void 0 === el && (el = null, Ce.trustedTypes)) try { el = Ce.trustedTypes.createPolicy("angular#unsafe-bypass", { createHTML: e => e, createScript: e => e, createScriptURL: e => e }) } catch { } return el }()?.createScriptURL(e) || e } class M_ { constructor(n) { this.changingThisBreaksApplicationSecurity = n } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${yg})` } } function or(e) { return e instanceof M_ ? e.changingThisBreaksApplicationSecurity : e } function $o(e, n) { const t = function _x(e) { return e instanceof M_ && e.getTypeName() || null }(e); if (null != t && t !== n) { if ("ResourceURL" === t && "URL" === n) return !0; throw new Error(`Required a safe ${n}, got a ${t} (see ${yg})`) } return t === n } const Dx = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i; var Ci = function (e) { return e[e.NONE = 0] = "NONE", e[e.HTML = 1] = "HTML", e[e.STYLE = 2] = "STYLE", e[e.SCRIPT = 3] = "SCRIPT", e[e.URL = 4] = "URL", e[e.RESOURCE_URL = 5] = "RESOURCE_URL", e }(Ci || {}); function F_(e) { const n = Go(); return n ? n.sanitize(Ci.URL, e) || "" : $o(e, "URL") ? or(e) : function yd(e) { return (e = String(e)).match(Dx) ? e : "unsafe:" + e }(q(e)) } function L_(e) { const n = Go(); if (n) return x_(n.sanitize(Ci.RESOURCE_URL, e) || ""); if ($o(e, "ResourceURL")) return x_(or(e)); throw new x(904, !1) } function Go() { const e = S(); return e && e[ti].sanitizer } const qo = new A("ENVIRONMENT_INITIALIZER"), V_ = new A("INJECTOR", -1), B_ = new A("INJECTOR_DEF_TYPES"); class wd { get(n, t = yo) { if (t === yo) { const r = new Error(`NullInjectorError: No provider for ${$e(n)}!`); throw r.name = "NullInjectorError", r } return t } } function Nx(...e) { return { \u0275providers: U_(0, e), \u0275fromNgModule: !0 } } function U_(e, ...n) { const t = [], r = new Set; let i; const o = s => { t.push(s) }; return gi(n, s => { const a = s; nl(a, o, [], r) && (i ||= [], i.push(a)) }), void 0 !== i && H_(i, o), t } function H_(e, n) { for (let t = 0; t < e.length; t++) { const { ngModule: r, providers: i } = e[t]; Id(i, o => { n(o, r) }) } } function nl(e, n, t, r) { if (!(e = G(e))) return !1; let i = null, o = ma(e); const s = !o && ie(e); if (o || s) { if (s && !s.standalone) return !1; i = e } else { const l = e.ngModule; if (o = ma(l), !o) return !1; i = l } const a = r.has(i); if (s) { if (a) return !1; if (r.add(i), s.dependencies) { const l = "function" == typeof s.dependencies ? s.dependencies() : s.dependencies; for (const c of l) nl(c, n, t, r) } } else { if (!o) return !1; { if (null != o.imports && !a) { let c; r.add(i); try { gi(o.imports, u => { nl(u, n, t, r) && (c ||= [], c.push(u)) }) } finally { } void 0 !== c && H_(c, n) } if (!a) { const c = Er(i) || (() => new i); n({ provide: i, useFactory: c, deps: ae }, i), n({ provide: B_, useValue: i, multi: !0 }, i), n({ provide: qo, useValue: () => k(i), multi: !0 }, i) } const l = o.providers; if (null != l && !a) { const c = e; Id(l, u => { n(u, c) }) } } } return i !== e && void 0 !== e.providers } function Id(e, n) { for (let t of e) gu(t) && (t = t.\u0275providers), Array.isArray(t) ? Id(t, n) : n(t) } const Ox = he({ provide: String, useValue: he }); function Sd(e) { return null !== e && "object" == typeof e && Ox in e } function xr(e) { return "function" == typeof e } const Td = new A("Set Injector scope."), rl = {}, Lx = {}; let xd; function il() { return void 0 === xd && (xd = new wd), xd } class Nt { } class wi extends Nt { get destroyed() { return this._destroyed } constructor(n, t, r, i) { super(), this.parent = t, this.source = r, this.scopes = i, this.records = new Map, this._ngOnDestroyHooks = new Set, this._onDestroyHooks = [], this._destroyed = !1, Ad(n, s => this.processProvider(s)), this.records.set(V_, Ei(void 0, this)), i.has("environment") && this.records.set(Nt, Ei(void 0, this)); const o = this.records.get(Td); null != o && "string" == typeof o.value && this.scopes.add(o.value), this.injectorDefTypes = new Set(this.get(B_.multi, ae, J.Self)) } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { for (const t of this._ngOnDestroyHooks) t.ngOnDestroy(); const n = this._onDestroyHooks; this._onDestroyHooks = []; for (const t of n) t() } finally { this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear() } } onDestroy(n) { return this.assertNotDestroyed(), this._onDestroyHooks.push(n), () => this.removeOnDestroy(n) } runInContext(n) { this.assertNotDestroyed(); const t = Xn(this), r = yt(void 0); try { return n() } finally { Xn(t), yt(r) } } get(n, t = yo, r = J.Default) { if (this.assertNotDestroyed(), n.hasOwnProperty(xg)) return n[xg](this); r = ya(r); const o = Xn(this), s = yt(void 0); try { if (!(r & J.SkipSelf)) { let l = this.records.get(n); if (void 0 === l) { const c = function Hx(e) { return "function" == typeof e || "object" == typeof e && e instanceof A }(n) && ga(n); l = c && this.injectableDefInScope(c) ? Ei(Md(n), rl) : null, this.records.set(n, l) } if (null != l) return this.hydrate(n, l) } return (r & J.Self ? il() : this.parent).get(n, t = r & J.Optional && t === yo ? null : t) } catch (a) { if ("NullInjectorError" === a.name) { if ((a[va] = a[va] || []).unshift($e(n)), o) throw a; return function VI(e, n, t, r) { const i = e[va]; throw n[Ig] && i.unshift(n[Ig]), e.message = function BI(e, n, t, r = null) { e = e && "\n" === e.charAt(0) && "\u0275" == e.charAt(1) ? e.slice(2) : e; let i = $e(n); if (Array.isArray(n)) i = n.map($e).join(" -> "); else if ("object" == typeof n) { let o = []; for (let s in n) if (n.hasOwnProperty(s)) { let a = n[s]; o.push(s + ":" + ("string" == typeof a ? JSON.stringify(a) : $e(a))) } i = `{${o.join(", ")}}` } return `${t}${r ? "(" + r + ")" : ""}[${i}]: ${e.replace(NI, "\n  ")}` }("\n" + e.message, i, t, r), e.ngTokenPath = i, e[va] = null, e }(a, n, "R3InjectorError", this.source) } throw a } finally { yt(s), Xn(o) } } resolveInjectorInitializers() { const n = Xn(this), t = yt(void 0); try { const i = this.get(qo.multi, ae, J.Self); for (const o of i) o() } finally { Xn(n), yt(t) } } toString() { const n = [], t = this.records; for (const r of t.keys()) n.push($e(r)); return `R3Injector[${n.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new x(205, !1) } processProvider(n) { let t = xr(n = G(n)) ? n : G(n && n.provide); const r = function Vx(e) { return Sd(e) ? Ei(void 0, e.useValue) : Ei(G_(e), rl) }(n); if (xr(n) || !0 !== n.multi) this.records.get(t); else { let i = this.records.get(t); i || (i = Ei(void 0, rl, !0), i.factory = () => Eu(i.multi), this.records.set(t, i)), t = n, i.multi.push(n) } this.records.set(t, r) } hydrate(n, t) { return t.value === rl && (t.value = Lx, t.value = t.factory()), "object" == typeof t.value && t.value && function Ux(e) { return null !== e && "object" == typeof e && "function" == typeof e.ngOnDestroy }(t.value) && this._ngOnDestroyHooks.add(t.value), t.value } injectableDefInScope(n) { if (!n.providedIn) return !1; const t = G(n.providedIn); return "string" == typeof t ? "any" === t || this.scopes.has(t) : this.injectorDefTypes.has(t) } removeOnDestroy(n) { const t = this._onDestroyHooks.indexOf(n); -1 !== t && this._onDestroyHooks.splice(t, 1) } } function Md(e) { const n = ga(e), t = null !== n ? n.factory : Er(e); if (null !== t) return t; if (e instanceof A) throw new x(204, !1); if (e instanceof Function) return function jx(e) { const n = e.length; if (n > 0) throw function Lo(e, n) { const t = []; for (let r = 0; r < e; r++)t.push(n); return t }(n, "?"), new x(204, !1); const t = function AI(e) { return e && (e[_a] || e[Dg]) || null }(e); return null !== t ? () => t.factory(e) : () => new e }(e); throw new x(204, !1) } function G_(e, n, t) { let r; if (xr(e)) { const i = G(e); return Er(i) || Md(i) } if (Sd(e)) r = () => G(e.useValue); else if (function z_(e) { return !(!e || !e.useFactory) }(e)) r = () => e.useFactory(...Eu(e.deps || [])); else if (function $_(e) { return !(!e || !e.useExisting) }(e)) r = () => k(G(e.useExisting)); else { const i = G(e && (e.useClass || e.provide)); if (!function Bx(e) { return !!e.deps }(e)) return Er(i) || Md(i); r = () => new i(...Eu(e.deps)) } return r } function Ei(e, n, t = !1) { return { factory: e, value: n, multi: t ? [] : void 0 } } function Ad(e, n) { for (const t of e) Array.isArray(t) ? Ad(t, n) : t && gu(t) ? Ad(t.\u0275providers, n) : n(t) } const ol = new A("AppId", { providedIn: "root", factory: () => $x }), $x = "ng", q_ = new A("Platform Initializer"), sr = new A("Platform ID", { providedIn: "platform", factory: () => "unknown" }), W_ = new A("CSP nonce", { providedIn: "root", factory: () => function Di() { if (void 0 !== _d) return _d; if (typeof document < "u") return document; throw new x(210, !1) }().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce") || null }); let Z_ = (e, n, t) => null; function jd(e, n, t = !1) { return Z_(e, n, t) } class Jx { } class Q_ { } class tM { resolveComponentFactory(n) { throw function eM(e) { const n = Error(`No component factory found for ${$e(e)}.`); return n.ngComponent = e, n }(n) } } let dl = (() => { class e { static { this.NULL = new tM } } return e })(); function nM() { return Ti(Je(), S()) } function Ti(e, n) { return new tt(wt(e, n)) } let tt = (() => { class e { constructor(t) { this.nativeElement = t } static { this.__NG_ELEMENT_ID__ = nM } } return e })(); function rM(e) { return e instanceof tt ? e.nativeElement : e } class J_ { } let Ln = (() => { class e { constructor() { this.destroyNode = null } static { this.__NG_ELEMENT_ID__ = () => function iM() { const e = S(), t = Rt(Je().index, e); return (Ct(t) ? t : e)[W] }() } } return e })(), oM = (() => { class e { static { this.\u0275prov = F({ token: e, providedIn: "root", factory: () => null }) } } return e })(); class Ko { constructor(n) { this.full = n, this.major = n.split(".")[0], this.minor = n.split(".")[1], this.patch = n.split(".").slice(2).join(".") } } const sM = new Ko("16.2.12"), Ud = {}; function rv(e, n = null, t = null, r) { const i = iv(e, n, t, r); return i.resolveInjectorInitializers(), i } function iv(e, n = null, t = null, r, i = new Set) { const o = [t || ae, Nx(e)]; return r = r || ("object" == typeof e ? void 0 : $e(e)), new wi(o, n || il(), r || null, i) } let Ot = (() => { class e { static { this.THROW_IF_NOT_FOUND = yo } static { this.NULL = new wd } static create(t, r) { if (Array.isArray(t)) return rv({ name: "" }, r, t, ""); { const i = t.name ?? ""; return rv({ name: i }, t.parent, t.providers, i) } } static { this.\u0275prov = F({ token: e, providedIn: "any", factory: () => k(V_) }) } static { this.__NG_ELEMENT_ID__ = -1 } } return e })(); function $d(e) { return e.ngOriginalError } class jn { constructor() { this._console = console } handleError(n) { const t = this._findOriginalError(n); this._console.error("ERROR", n), t && this._console.error("ORIGINAL ERROR", t) } _findOriginalError(n) { let t = n && $d(n); for (; t && $d(t);)t = $d(t); return t || null } } function zd(e) { return n => { setTimeout(e, void 0, n) } } const se = class pM extends X { constructor(n = !1) { super(), this.__isAsync = n } emit(n) { super.next(n) } subscribe(n, t, r) { let i = n, o = t || (() => null), s = r; if (n && "object" == typeof n) { const l = n; i = l.next?.bind(l), o = l.error?.bind(l), s = l.complete?.bind(l) } this.__isAsync && (o = zd(o), i && (i = zd(i)), s && (s = zd(s))); const a = super.subscribe({ next: i, error: o, complete: s }); return n instanceof Pe && n.add(a), a } }; function sv(...e) { } class le { constructor({ enableLongStackTrace: n = !1, shouldCoalesceEventChangeDetection: t = !1, shouldCoalesceRunChangeDetection: r = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new se(!1), this.onMicrotaskEmpty = new se(!1), this.onStable = new se(!1), this.onError = new se(!1), typeof Zone > "u") throw new x(908, !1); Zone.assertZonePatched(); const i = this; i._nesting = 0, i._outer = i._inner = Zone.current, Zone.TaskTrackingZoneSpec && (i._inner = i._inner.fork(new Zone.TaskTrackingZoneSpec)), n && Zone.longStackTraceZoneSpec && (i._inner = i._inner.fork(Zone.longStackTraceZoneSpec)), i.shouldCoalesceEventChangeDetection = !r && t, i.shouldCoalesceRunChangeDetection = r, i.lastRequestAnimationFrameId = -1, i.nativeRequestAnimationFrame = function gM() { const e = "function" == typeof Ce.requestAnimationFrame; let n = Ce[e ? "requestAnimationFrame" : "setTimeout"], t = Ce[e ? "cancelAnimationFrame" : "clearTimeout"]; if (typeof Zone < "u" && n && t) { const r = n[Zone.__symbol__("OriginalDelegate")]; r && (n = r); const i = t[Zone.__symbol__("OriginalDelegate")]; i && (t = i) } return { nativeRequestAnimationFrame: n, nativeCancelAnimationFrame: t } }().nativeRequestAnimationFrame, function vM(e) { const n = () => { !function _M(e) { e.isCheckStableRunning || -1 !== e.lastRequestAnimationFrameId || (e.lastRequestAnimationFrameId = e.nativeRequestAnimationFrame.call(Ce, () => { e.fakeTopEventTask || (e.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { e.lastRequestAnimationFrameId = -1, qd(e), e.isCheckStableRunning = !0, Gd(e), e.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), e.fakeTopEventTask.invoke() }), qd(e)) }(e) }; e._inner = e._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (t, r, i, o, s, a) => { if (function bM(e) { return !(!Array.isArray(e) || 1 !== e.length) && !0 === e[0].data?.__ignore_ng_zone__ }(a)) return t.invokeTask(i, o, s, a); try { return av(e), t.invokeTask(i, o, s, a) } finally { (e.shouldCoalesceEventChangeDetection && "eventTask" === o.type || e.shouldCoalesceRunChangeDetection) && n(), lv(e) } }, onInvoke: (t, r, i, o, s, a, l) => { try { return av(e), t.invoke(i, o, s, a, l) } finally { e.shouldCoalesceRunChangeDetection && n(), lv(e) } }, onHasTask: (t, r, i, o) => { t.hasTask(i, o), r === i && ("microTask" == o.change ? (e._hasPendingMicrotasks = o.microTask, qd(e), Gd(e)) : "macroTask" == o.change && (e.hasPendingMacrotasks = o.macroTask)) }, onHandleError: (t, r, i, o) => (t.handleError(i, o), e.runOutsideAngular(() => e.onError.emit(o)), !1) }) }(i) } static isInAngularZone() { return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!le.isInAngularZone()) throw new x(909, !1) } static assertNotInAngularZone() { if (le.isInAngularZone()) throw new x(909, !1) } run(n, t, r) { return this._inner.run(n, t, r) } runTask(n, t, r, i) { const o = this._inner, s = o.scheduleEventTask("NgZoneEvent: " + i, n, mM, sv, sv); try { return o.runTask(s, t, r) } finally { o.cancelTask(s) } } runGuarded(n, t, r) { return this._inner.runGuarded(n, t, r) } runOutsideAngular(n) { return this._outer.run(n) } } const mM = {}; function Gd(e) { if (0 == e._nesting && !e.hasPendingMicrotasks && !e.isStable) try { e._nesting++, e.onMicrotaskEmpty.emit(null) } finally { if (e._nesting--, !e.hasPendingMicrotasks) try { e.runOutsideAngular(() => e.onStable.emit(null)) } finally { e.isStable = !0 } } } function qd(e) { e.hasPendingMicrotasks = !!(e._hasPendingMicrotasks || (e.shouldCoalesceEventChangeDetection || e.shouldCoalesceRunChangeDetection) && -1 !== e.lastRequestAnimationFrameId) } function av(e) { e._nesting++, e.isStable && (e.isStable = !1, e.onUnstable.emit(null)) } function lv(e) { e._nesting--, Gd(e) } class yM { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new se, this.onMicrotaskEmpty = new se, this.onStable = new se, this.onError = new se } run(n, t, r) { return n.apply(t, r) } runGuarded(n, t, r) { return n.apply(t, r) } runOutsideAngular(n) { return n() } runTask(n, t, r, i) { return n.apply(t, r) } } const cv = new A("", { providedIn: "root", factory: uv }); function uv() { const e = O(le); let n = !0; return fa(new be(i => { n = e.isStable && !e.hasPendingMacrotasks && !e.hasPendingMicrotasks, e.runOutsideAngular(() => { i.next(n), i.complete() }) }), new be(i => { let o; e.runOutsideAngular(() => { o = e.onStable.subscribe(() => { le.assertNotInAngularZone(), queueMicrotask(() => { !n && !e.hasPendingMacrotasks && !e.hasPendingMicrotasks && (n = !0, i.next(!0)) }) }) }); const s = e.onUnstable.subscribe(() => { le.assertInAngularZone(), n && (n = !1, e.runOutsideAngular(() => { i.next(!1) })) }); return () => { o.unsubscribe(), s.unsubscribe() } }).pipe(vg())) } function hl(e) { return e.ownerDocument } function Vn(e) { return e instanceof Function ? e() : e } let Wd = (() => { class e { constructor() { this.renderDepth = 0, this.handler = null } begin() { this.handler?.validateBegin(), this.renderDepth++ } end() { this.renderDepth--, 0 === this.renderDepth && this.handler?.execute() } ngOnDestroy() { this.handler?.destroy(), this.handler = null } static { this.\u0275prov = F({ token: e, providedIn: "root", factory: () => new e }) } } return e })(); function Yo(e) { for (; e;) { e[K] |= 64; const n = Bo(e); if (Au(e) && !n) return e; e = n } return null } const gv = new A("", { providedIn: "root", factory: () => !1 }); let gl = null; function yv(e, n) { return e[n] ?? Cv() } function bv(e, n) { const t = Cv(); t.producerNode?.length && (e[n] = gl, t.lView = e, gl = Dv()) } const MM = { ...Gg, consumerIsAlwaysLive: !0, consumerMarkedDirty: e => { Yo(e.lView) }, lView: null }; function Dv() { return Object.create(MM) } function Cv() { return gl ??= Dv(), gl } const Z = {}; function _(e) { wv(oe(), S(), ht() + e, !1) } function wv(e, n, t, r) { if (!r) if (3 == (3 & n[K])) { const o = e.preOrderCheckHooks; null !== o && Aa(n, o, t) } else { const o = e.preOrderHooks; null !== o && ka(n, o, 0, t) } Ir(t) } function D(e, n = J.Default) { const t = S(); return null === t ? k(e, n) : Fm(Je(), t, G(e), n) } function ml(e, n, t, r, i, o, s, a, l, c, u) { const d = n.blueprint.slice(); return d[Ae] = i, d[K] = 140 | r, (null !== c || e && 2048 & e[K]) && (d[K] |= 2048), dm(d), d[Te] = d[ni] = e, d[Oe] = t, d[ti] = s || e && e[ti], d[W] = a || e && e[W], d[Jn] = l || e && e[Jn] || null, d[it] = o, d[So] = function FT() { return OT++ }(), d[Pn] = u, d[Ug] = c, d[Fe] = 2 == n.type ? e[Fe] : d, d } function Ai(e, n, t, r, i) { let o = e.data[n]; if (null === o) o = function Zd(e, n, t, r, i) { const o = _m(), s = ju(), l = e.data[n] = function LM(e, n, t, r, i, o) { let s = n ? n.injectorIndex : -1, a = 0; return function ai() { return null !== z.skipHydrationRootTNode }() && (a |= 128), { type: t, index: r, insertBeforeIndex: null, injectorIndex: s, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, componentOffset: -1, propertyBindings: null, flags: a, providerIndexes: 0, value: i, attrs: o, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tView: null, next: null, prev: null, projectionNext: null, child: null, parent: n, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, s ? o : o && o.parent, t, n, r, i); return null === e.firstChild && (e.firstChild = l), null !== o && (s ? null == o.child && null !== l.parent && (o.child = l) : null === o.next && (o.next = l, l.prev = o)), l }(e, n, t, r, i), function LS() { return z.lFrame.inI18n }() && (o.flags |= 32); else if (64 & o.type) { o.type = t, o.value = r, o.attrs = i; const s = function ko() { const e = z.lFrame, n = e.currentTNode; return e.isParent ? n : n.parent }(); o.injectorIndex = null === s ? -1 : s.injectorIndex } return gn(o, !0), o } function Qo(e, n, t, r) { if (0 === t) return -1; const i = n.length; for (let o = 0; o < t; o++)n.push(r), e.blueprint.push(r), e.data.push(null); return i } function Iv(e, n, t, r, i) { const o = yv(n, To), s = ht(), a = 2 & r; try { Ir(-1), a && n.length > ee && wv(e, n, ee, !1), pn(a ? 2 : 0, i); const c = a ? o : null, u = Ru(c); try { null !== c && (c.dirty = !1), t(r, i) } finally { Pu(c, u) } } finally { a && null === n[To] && bv(n, To), Ir(s), pn(a ? 3 : 1, i) } } function Kd(e, n, t) { if (Mu(n)) { const r = Ut(null); try { const o = n.directiveEnd; for (let s = n.directiveStart; s < o; s++) { const a = e.data[s]; a.contentQueries && a.contentQueries(1, t[s], s) } } finally { Ut(r) } } } function Yd(e, n, t) { mm() && (function zM(e, n, t, r) { const i = t.directiveStart, o = t.directiveEnd; wr(t) && function QM(e, n, t) { const r = wt(n, e), i = Sv(t); let s = 16; t.signals ? s = 4096 : t.onPush && (s = 64); const a = _l(e, ml(e, i, null, s, r, n, null, e[ti].rendererFactory.createRenderer(r, t), null, null, null)); e[n.index] = a }(n, t, e.data[i + t.componentOffset]), e.firstCreatePass || Pa(t, n), ot(r, n); const s = t.initialInputs; for (let a = i; a < o; a++) { const l = e.data[a], c = Sr(n, e, a, t); ot(c, n), null !== s && XM(0, a - i, c, l, 0, s), en(l) && (Rt(t.index, n)[Oe] = Sr(n, e, a, t)) } }(e, n, t, wt(t, n)), 64 == (64 & t.flags) && kv(e, n, t)) } function Qd(e, n, t = wt) { const r = n.localNames; if (null !== r) { let i = n.index + 1; for (let o = 0; o < r.length; o += 2) { const s = r[o + 1], a = -1 === s ? t(n, e) : e[s]; e[i++] = a } } } function Sv(e) { const n = e.tView; return null === n || n.incompleteFirstPass ? e.tView = Xd(1, null, e.template, e.decls, e.vars, e.directiveDefs, e.pipeDefs, e.viewQuery, e.schemas, e.consts, e.id) : n } function Xd(e, n, t, r, i, o, s, a, l, c, u) { const d = ee + r, p = d + i, m = function kM(e, n) { const t = []; for (let r = 0; r < n; r++)t.push(r < e ? null : Z); return t }(d, p), v = "function" == typeof c ? c() : c; return m[N] = { type: e, blueprint: m, template: t, queries: null, viewQuery: a, declTNode: n, data: m.slice().fill(null, d), bindingStartIndex: d, expandoStartIndex: p, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof o ? o() : o, pipeRegistry: "function" == typeof s ? s() : s, firstChild: null, schemas: l, consts: v, incompleteFirstPass: !1, ssrId: u } } let Tv = e => null; function xv(e, n, t, r) { for (let i in e) if (e.hasOwnProperty(i)) { t = null === t ? {} : t; const o = e[i]; null === r ? Mv(t, n, i, o) : r.hasOwnProperty(i) && Mv(t, n, r[i], o) } return t } function Mv(e, n, t, r) { e.hasOwnProperty(t) ? e[t].push(n, r) : e[t] = [n, r] } function Ft(e, n, t, r, i, o, s, a) { const l = wt(n, t); let u, c = n.inputs; !a && null != c && (u = c[r]) ? (rf(e, t, u, r, i), wr(n) && function BM(e, n) { const t = Rt(n, e); 16 & t[K] || (t[K] |= 64) }(t, n.index)) : 3 & n.type && (r = function VM(e) { return "class" === e ? "className" : "for" === e ? "htmlFor" : "formaction" === e ? "formAction" : "innerHtml" === e ? "innerHTML" : "readonly" === e ? "readOnly" : "tabindex" === e ? "tabIndex" : e }(r), i = null != s ? s(i, n.value || "", r) : i, o.setProperty(l, r, i)) } function Jd(e, n, t, r) { if (mm()) { const i = null === r ? null : { "": -1 }, o = function qM(e, n) { const t = e.directiveRegistry; let r = null, i = null; if (t) for (let o = 0; o < t.length; o++) { const s = t[o]; if (Og(n, s.selectors, !1)) if (r || (r = []), en(s)) if (null !== s.findHostDirectiveDefs) { const a = []; i = i || new Map, s.findHostDirectiveDefs(s, a, i), r.unshift(...a, s), ef(e, n, a.length) } else r.unshift(s), ef(e, n, 0); else i = i || new Map, s.findHostDirectiveDefs?.(s, r, i), r.push(s) } return null === r ? null : [r, i] }(e, t); let s, a; null === o ? s = a = null : [s, a] = o, null !== s && Av(e, n, t, s, i, a), i && function WM(e, n, t) { if (n) { const r = e.localNames = []; for (let i = 0; i < n.length; i += 2) { const o = t[n[i + 1]]; if (null == o) throw new x(-301, !1); r.push(n[i], o) } } }(t, r, i) } t.mergedAttrs = Co(t.mergedAttrs, t.attrs) } function Av(e, n, t, r, i, o) { for (let c = 0; c < r.length; c++)Yu(Pa(t, n), e, r[c].type); !function KM(e, n, t) { e.flags |= 1, e.directiveStart = n, e.directiveEnd = n + t, e.providerIndexes = n }(t, e.data.length, r.length); for (let c = 0; c < r.length; c++) { const u = r[c]; u.providersResolver && u.providersResolver(u) } let s = !1, a = !1, l = Qo(e, n, r.length, null); for (let c = 0; c < r.length; c++) { const u = r[c]; t.mergedAttrs = Co(t.mergedAttrs, u.hostAttrs), YM(e, t, n, l, u), ZM(l, u, i), null !== u.contentQueries && (t.flags |= 4), (null !== u.hostBindings || null !== u.hostAttrs || 0 !== u.hostVars) && (t.flags |= 64); const d = u.type.prototype; !s && (d.ngOnChanges || d.ngOnInit || d.ngDoCheck) && ((e.preOrderHooks ??= []).push(t.index), s = !0), !a && (d.ngOnChanges || d.ngDoCheck) && ((e.preOrderCheckHooks ??= []).push(t.index), a = !0), l++ } !function jM(e, n, t) { const i = n.directiveEnd, o = e.data, s = n.attrs, a = []; let l = null, c = null; for (let u = n.directiveStart; u < i; u++) { const d = o[u], p = t ? t.get(d) : null, v = p ? p.outputs : null; l = xv(d.inputs, u, l, p ? p.inputs : null), c = xv(d.outputs, u, c, v); const y = null === l || null === s || Ng(n) ? null : JM(l, u, s); a.push(y) } null !== l && (l.hasOwnProperty("class") && (n.flags |= 8), l.hasOwnProperty("style") && (n.flags |= 16)), n.initialInputs = a, n.inputs = l, n.outputs = c }(e, t, o) } function kv(e, n, t) { const r = t.directiveStart, i = t.directiveEnd, o = t.index, s = function VS() { return z.lFrame.currentDirectiveIndex }(); try { Ir(o); for (let a = r; a < i; a++) { const l = e.data[a], c = n[a]; Bu(a), (null !== l.hostBindings || 0 !== l.hostVars || null !== l.hostAttrs) && GM(l, c) } } finally { Ir(-1), Bu(s) } } function GM(e, n) { null !== e.hostBindings && e.hostBindings(1, n) } function ef(e, n, t) { n.componentOffset = t, (e.components ??= []).push(n.index) } function ZM(e, n, t) { if (t) { if (n.exportAs) for (let r = 0; r < n.exportAs.length; r++)t[n.exportAs[r]] = e; en(n) && (t[""] = e) } } function YM(e, n, t, r, i) { e.data[r] = i; const o = i.factory || (i.factory = Er(i.type)), s = new Ro(o, en(i), D); e.blueprint[r] = s, t[r] = s, function HM(e, n, t, r, i) { const o = i.hostBindings; if (o) { let s = e.hostBindingOpCodes; null === s && (s = e.hostBindingOpCodes = []); const a = ~n.index; (function $M(e) { let n = e.length; for (; n > 0;) { const t = e[--n]; if ("number" == typeof t && t < 0) return t } return 0 })(s) != a && s.push(a), s.push(t, r, o) } }(e, n, r, Qo(e, t, i.hostVars, Z), i) } function _n(e, n, t, r, i, o) { const s = wt(e, n); !function tf(e, n, t, r, i, o, s) { if (null == o) e.removeAttribute(n, i, t); else { const a = null == s ? q(o) : s(o, r || "", i); e.setAttribute(n, i, a, t) } }(n[W], s, o, e.value, t, r, i) } function XM(e, n, t, r, i, o) { const s = o[n]; if (null !== s) for (let a = 0; a < s.length;)Rv(r, t, s[a++], s[a++], s[a++]) } function Rv(e, n, t, r, i) { const o = Ut(null); try { const s = e.inputTransforms; null !== s && s.hasOwnProperty(r) && (i = s[r].call(n, i)), null !== e.setInput ? e.setInput(n, i, t, r) : n[r] = i } finally { Ut(o) } } function JM(e, n, t) { let r = null, i = 0; for (; i < t.length;) { const o = t[i]; if (0 !== o) if (5 !== o) { if ("number" == typeof o) break; if (e.hasOwnProperty(o)) { null === r && (r = []); const s = e[o]; for (let a = 0; a < s.length; a += 2)if (s[a] === n) { r.push(o, s[a + 1], t[i + 1]); break } } i += 2 } else i += 2; else i += 4 } return r } function Pv(e, n, t, r) { return [e, !0, !1, n, null, 0, r, t, null, null, null] } function Nv(e, n) { const t = e.contentQueries; if (null !== t) for (let r = 0; r < t.length; r += 2) { const o = t[r + 1]; if (-1 !== o) { const s = e.data[o]; Hu(t[r]), s.contentQueries(2, n[o], o) } } } function _l(e, n) { return e[Eo] ? e[Bg][Jt] = n : e[Eo] = n, e[Bg] = n, n } function nf(e, n, t) { Hu(0); const r = Ut(null); try { n(e, t) } finally { Ut(r) } } function Ov(e) { return e[ei] || (e[ei] = []) } function Fv(e) { return e.cleanup || (e.cleanup = []) } function jv(e, n) { const t = e[Jn], r = t ? t.get(jn, null) : null; r && r.handleError(n) } function rf(e, n, t, r, i) { for (let o = 0; o < t.length;) { const s = t[o++], a = t[o++]; Rv(e.data[s], n[s], r, a, i) } } function Bn(e, n, t) { const r = Ta(n, e); !function f_(e, n, t) { e.setValue(n, t) }(e[W], r, t) } function eA(e, n) { const t = Rt(n, e), r = t[N]; !function tA(e, n) { for (let t = n.length; t < e.blueprint.length; t++)n.push(e.blueprint[t]) }(r, t); const i = t[Ae]; null !== i && null === t[Pn] && (t[Pn] = jd(i, t[Jn])), sf(r, t, t[Oe]) } function sf(e, n, t) { $u(n); try { const r = e.viewQuery; null !== r && nf(1, r, t); const i = e.template; null !== i && Iv(e, n, i, 1, t), e.firstCreatePass && (e.firstCreatePass = !1), e.staticContentQueries && Nv(e, n), e.staticViewQueries && nf(2, e.viewQuery, t); const o = e.components; null !== o && function nA(e, n) { for (let t = 0; t < n.length; t++)eA(e, n[t]) }(n, o) } catch (r) { throw e.firstCreatePass && (e.incompleteFirstPass = !0, e.firstCreatePass = !1), r } finally { n[K] &= -5, zu() } } let Vv = (() => { class e { constructor() { this.all = new Set, this.queue = new Map } create(t, r, i) { const o = typeof Zone > "u" ? null : Zone.current, s = function gS(e, n, t) { const r = Object.create(mS); t && (r.consumerAllowSignalWrites = !0), r.fn = e, r.schedule = n; const i = s => { r.cleanupFn = s }; return r.ref = { notify: () => Kg(r), run: () => { if (r.dirty = !1, r.hasRun && !Yg(r)) return; r.hasRun = !0; const s = Ru(r); try { r.cleanupFn(), r.cleanupFn = im, r.fn(i) } finally { Pu(r, s) } }, cleanup: () => r.cleanupFn() }, r.ref }(t, c => { this.all.has(c) && this.queue.set(c, o) }, i); let a; this.all.add(s), s.notify(); const l = () => { s.cleanup(), a?.(), this.all.delete(s), this.queue.delete(s) }; return a = r?.onDestroy(l), { destroy: l } } flush() { if (0 !== this.queue.size) for (const [t, r] of this.queue) this.queue.delete(t), r ? r.run(() => t.run()) : t.run() } get isQueueEmpty() { return 0 === this.queue.size } static { this.\u0275prov = F({ token: e, providedIn: "root", factory: () => new e }) } } return e })(); function vl(e, n, t) { let r = t ? e.styles : null, i = t ? e.classes : null, o = 0; if (null !== n) for (let s = 0; s < n.length; s++) { const a = n[s]; "number" == typeof a ? o = a : 1 == o ? i = hu(i, a) : 2 == o && (r = hu(r, a + ": " + n[++s] + ";")) } t ? e.styles = r : e.stylesWithoutHost = r, t ? e.classes = i : e.classesWithoutHost = i } function Xo(e, n, t, r, i = !1) { for (; null !== t;) { const o = n[t.index]; null !== o && r.push(we(o)), dt(o) && Bv(o, r); const s = t.type; if (8 & s) Xo(e, n, t.child, r); else if (32 & s) { const a = ld(t, n); let l; for (; l = a();)r.push(l) } else if (16 & s) { const a = D_(n, t); if (Array.isArray(a)) r.push(...a); else { const l = Bo(n[Fe]); Xo(l[N], l, a, r, !0) } } t = i ? t.projectionNext : t.next } return r } function Bv(e, n) { for (let t = Qe; t < e.length; t++) { const r = e[t], i = r[N].firstChild; null !== i && Xo(r[N], r, i, n) } e[hn] !== e[Ae] && n.push(e[hn]) } function yl(e, n, t, r = !0) { const i = n[ti], o = i.rendererFactory, s = i.afterRenderEventManager; o.begin?.(), s?.begin(); try { Uv(e, n, e.template, t) } catch (l) { throw r && jv(n, l), l } finally { o.end?.(), i.effectManager?.flush(), s?.end() } } function Uv(e, n, t, r) { const i = n[K]; if (256 != (256 & i)) { n[ti].effectManager?.flush(), $u(n); try { dm(n), function ym(e) { return z.lFrame.bindingIndex = e }(e.bindingStartIndex), null !== t && Iv(e, n, t, 2, r); const s = 3 == (3 & i); if (s) { const c = e.preOrderCheckHooks; null !== c && Aa(n, c, null) } else { const c = e.preOrderHooks; null !== c && ka(n, c, 0, null), Gu(n, 0) } if (function oA(e) { for (let n = c_(e); null !== n; n = u_(n)) { if (!n[Hg]) continue; const t = n[ii]; for (let r = 0; r < t.length; r++) { SS(t[r]) } } }(n), Hv(n, 2), null !== e.contentQueries && Nv(e, n), s) { const c = e.contentCheckHooks; null !== c && Aa(n, c) } else { const c = e.contentHooks; null !== c && ka(n, c, 1), Gu(n, 1) } !function AM(e, n) { const t = e.hostBindingOpCodes; if (null === t) return; const r = yv(n, xo); try { for (let i = 0; i < t.length; i++) { const o = t[i]; if (o < 0) Ir(~o); else { const s = o, a = t[++i], l = t[++i]; jS(a, s), r.dirty = !1; const c = Ru(r); try { l(2, n[s]) } finally { Pu(r, c) } } } } finally { null === n[xo] && bv(n, xo), Ir(-1) } }(e, n); const a = e.components; null !== a && zv(n, a, 0); const l = e.viewQuery; if (null !== l && nf(2, l, r), s) { const c = e.viewCheckHooks; null !== c && Aa(n, c) } else { const c = e.viewHooks; null !== c && ka(n, c, 2), Gu(n, 2) } !0 === e.firstUpdatePass && (e.firstUpdatePass = !1), n[K] &= -73, fm(n) } finally { zu() } } } function Hv(e, n) { for (let t = c_(e); null !== t; t = u_(t))for (let r = Qe; r < t.length; r++)$v(t[r], n) } function sA(e, n, t) { $v(Rt(n, e), t) } function $v(e, n) { if (!function ES(e) { return 128 == (128 & e[K]) }(e)) return; const t = e[N], r = e[K]; if (80 & r && 0 === n || 1024 & r || 2 === n) Uv(t, e, t.template, e[Oe]); else if (e[wo] > 0) { Hv(e, 1); const i = t.components; null !== i && zv(e, i, 1) } } function zv(e, n, t) { for (let r = 0; r < n.length; r++)sA(e, n[r], t) } class Jo { get rootNodes() { const n = this._lView, t = n[N]; return Xo(t, n, t.firstChild, []) } constructor(n, t) { this._lView = n, this._cdRefInjectingView = t, this._appRef = null, this._attachedToViewContainer = !1 } get context() { return this._lView[Oe] } set context(n) { this._lView[Oe] = n } get destroyed() { return 256 == (256 & this._lView[K]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const n = this._lView[Te]; if (dt(n)) { const t = n[8], r = t ? t.indexOf(this) : -1; r > -1 && (Ka(n, r), La(t, r)) } this._attachedToViewContainer = !1 } ud(this._lView[N], this._lView) } onDestroy(n) { !function pm(e, n) { if (256 == (256 & e[K])) throw new x(911, !1); null === e[er] && (e[er] = []), e[er].push(n) }(this._lView, n) } markForCheck() { Yo(this._cdRefInjectingView || this._lView) } detach() { this._lView[K] &= -129 } reattach() { this._lView[K] |= 128 } detectChanges() { yl(this._lView[N], this._lView, this.context) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new x(902, !1); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null, function YT(e, n) { Ho(e, n, n[W], 2, null, null) }(this._lView[N], this._lView) } attachToAppRef(n) { if (this._attachedToViewContainer) throw new x(902, !1); this._appRef = n } } class aA extends Jo { constructor(n) { super(n), this._view = n } detectChanges() { const n = this._view; yl(n[N], n, n[Oe], !1) } checkNoChanges() { } get context() { return null } } class Gv extends dl { constructor(n) { super(), this.ngModule = n } resolveComponentFactory(n) { const t = ie(n); return new es(t, this.ngModule) } } function qv(e) { const n = []; for (let t in e) e.hasOwnProperty(t) && n.push({ propName: e[t], templateName: t }); return n } class cA { constructor(n, t) { this.injector = n, this.parentInjector = t } get(n, t, r) { r = ya(r); const i = this.injector.get(n, Ud, r); return i !== Ud || t === Ud ? i : this.parentInjector.get(n, t, r) } } class es extends Q_ { get inputs() { const n = this.componentDef, t = n.inputTransforms, r = qv(n.inputs); if (null !== t) for (const i of r) t.hasOwnProperty(i.propName) && (i.transform = t[i.propName]); return r } get outputs() { return qv(this.componentDef.outputs) } constructor(n, t) { super(), this.componentDef = n, this.ngModule = t, this.componentType = n.type, this.selector = function YI(e) { return e.map(KI).join(",") }(n.selectors), this.ngContentSelectors = n.ngContentSelectors ? n.ngContentSelectors : [], this.isBoundToModule = !!t } create(n, t, r, i) { let o = (i = i || this.ngModule) instanceof Nt ? i : i?.injector; o && null !== this.componentDef.getStandaloneInjector && (o = this.componentDef.getStandaloneInjector(o) || o); const s = o ? new cA(n, o) : n, a = s.get(J_, null); if (null === a) throw new x(407, !1); const d = { rendererFactory: a, sanitizer: s.get(oM, null), effectManager: s.get(Vv, null), afterRenderEventManager: s.get(Wd, null) }, p = a.createRenderer(null, this.componentDef), m = this.componentDef.selectors[0][0] || "div", v = r ? function RM(e, n, t, r) { const o = r.get(gv, !1) || t === Qt.ShadowDom, s = e.selectRootElement(n, o); return function PM(e) { Tv(e) }(s), s }(p, r, this.componentDef.encapsulation, s) : Za(p, m, function lA(e) { const n = e.toLowerCase(); return "svg" === n ? lm : "math" === n ? "math" : null }(m)), T = this.componentDef.signals ? 4608 : this.componentDef.onPush ? 576 : 528; let w = null; null !== v && (w = jd(v, s, !0)); const P = Xd(0, null, null, 1, 0, null, null, null, null, null, null), L = ml(null, P, null, T, null, null, d, p, s, null, w); let Q, Ke; $u(L); try { const Mn = this.componentDef; let Kr, Gp = null; Mn.findHostDirectiveDefs ? (Kr = [], Gp = new Map, Mn.findHostDirectiveDefs(Mn, Kr, Gp), Kr.push(Mn)) : Kr = [Mn]; const jU = function dA(e, n) { const t = e[N], r = ee; return e[r] = n, Ai(t, r, 2, "#host", null) }(L, v), VU = function fA(e, n, t, r, i, o, s) { const a = i[N]; !function hA(e, n, t, r) { for (const i of e) n.mergedAttrs = Co(n.mergedAttrs, i.hostAttrs); null !== n.mergedAttrs && (vl(n, n.mergedAttrs, !0), null !== t && I_(r, t, n)) }(r, e, n, s); let l = null; null !== n && (l = jd(n, i[Jn])); const c = o.rendererFactory.createRenderer(n, t); let u = 16; t.signals ? u = 4096 : t.onPush && (u = 64); const d = ml(i, Sv(t), null, u, i[e.index], e, o, c, null, null, l); return a.firstCreatePass && ef(a, e, r.length - 1), _l(i, d), i[e.index] = d }(jU, v, Mn, Kr, L, d, p); Ke = um(P, ee), v && function gA(e, n, t, r) { if (r) Tu(e, t, ["ng-version", sM.full]); else { const { attrs: i, classes: o } = function QI(e) { const n = [], t = []; let r = 1, i = 2; for (; r < e.length;) { let o = e[r]; if ("string" == typeof o) 2 === i ? "" !== o && n.push(o, e[++r]) : 8 === i && t.push(o); else { if (!Xt(i)) break; i = o } r++ } return { attrs: n, classes: t } }(n.selectors[0]); i && Tu(e, t, i), o && o.length > 0 && E_(e, t, o.join(" ")) } }(p, Mn, v, r), void 0 !== t && function mA(e, n, t) { const r = e.projection = []; for (let i = 0; i < n.length; i++) { const o = t[i]; r.push(null != o ? Array.from(o) : null) } }(Ke, this.ngContentSelectors, t), Q = function pA(e, n, t, r, i, o) { const s = Je(), a = i[N], l = wt(s, i); Av(a, i, s, t, null, r); for (let u = 0; u < t.length; u++)ot(Sr(i, a, s.directiveStart + u, s), i); kv(a, i, s), l && ot(l, i); const c = Sr(i, a, s.directiveStart + s.componentOffset, s); if (e[Oe] = i[Oe] = c, null !== o) for (const u of o) u(c, n); return Kd(a, s, e), c }(VU, Mn, Kr, Gp, L, [_A]), sf(P, L, null) } finally { zu() } return new uA(this.componentType, Q, Ti(Ke, L), L, Ke) } } class uA extends Jx { constructor(n, t, r, i, o) { super(), this.location = r, this._rootLView = i, this._tNode = o, this.previousInputValues = null, this.instance = t, this.hostView = this.changeDetectorRef = new aA(i), this.componentType = n } setInput(n, t) { const r = this._tNode.inputs; let i; if (null !== r && (i = r[n])) { if (this.previousInputValues ??= new Map, this.previousInputValues.has(n) && Object.is(this.previousInputValues.get(n), t)) return; const o = this._rootLView; rf(o[N], o, i, n, t), this.previousInputValues.set(n, t), Yo(Rt(this._tNode.index, o)) } } get injector() { return new pt(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(n) { this.hostView.onDestroy(n) } } function _A() { const e = Je(); Ma(S()[N], e) } function pe(e) { let n = function Wv(e) { return Object.getPrototypeOf(e.prototype).constructor }(e.type), t = !0; const r = [e]; for (; n;) { let i; if (en(e)) i = n.\u0275cmp || n.\u0275dir; else { if (n.\u0275cmp) throw new x(903, !1); i = n.\u0275dir } if (i) { if (t) { r.push(i); const s = e; s.inputs = bl(e.inputs), s.inputTransforms = bl(e.inputTransforms), s.declaredInputs = bl(e.declaredInputs), s.outputs = bl(e.outputs); const a = i.hostBindings; a && DA(e, a); const l = i.viewQuery, c = i.contentQueries; if (l && yA(e, l), c && bA(e, c), ha(e.inputs, i.inputs), ha(e.declaredInputs, i.declaredInputs), ha(e.outputs, i.outputs), null !== i.inputTransforms && (null === s.inputTransforms && (s.inputTransforms = {}), ha(s.inputTransforms, i.inputTransforms)), en(i) && i.data.animation) { const u = e.data; u.animation = (u.animation || []).concat(i.data.animation) } } const o = i.features; if (o) for (let s = 0; s < o.length; s++) { const a = o[s]; a && a.ngInherit && a(e), a === pe && (t = !1) } } n = Object.getPrototypeOf(n) } !function vA(e) { let n = 0, t = null; for (let r = e.length - 1; r >= 0; r--) { const i = e[r]; i.hostVars = n += i.hostVars, i.hostAttrs = Co(i.hostAttrs, t = Co(t, i.hostAttrs)) } }(r) } function bl(e) { return e === dn ? {} : e === ae ? [] : e } function yA(e, n) { const t = e.viewQuery; e.viewQuery = t ? (r, i) => { n(r, i), t(r, i) } : n } function bA(e, n) { const t = e.contentQueries; e.contentQueries = t ? (r, i, o) => { n(r, i, o), t(r, i, o) } : n } function DA(e, n) { const t = e.hostBindings; e.hostBindings = t ? (r, i) => { n(r, i), t(r, i) } : n } function Qv(e) { const n = e.inputConfig, t = {}; for (const r in n) if (n.hasOwnProperty(r)) { const i = n[r]; Array.isArray(i) && i[2] && (t[r] = i[2]) } e.inputTransforms = t } function Dl(e) { return !!af(e) && (Array.isArray(e) || !(e instanceof Map) && Symbol.iterator in e) } function af(e) { return null !== e && ("function" == typeof e || "object" == typeof e) } function vn(e, n, t) { return e[n] = t } function st(e, n, t) { return !Object.is(e[n], t) && (e[n] = t, !0) } function Mr(e, n, t, r) { const i = st(e, n, t); return st(e, n + 1, r) || i } function Cl(e, n, t, r, i) { const o = Mr(e, n, t, r); return st(e, n + 2, i) || o } function nt(e, n, t, r) { const i = S(); return st(i, li(), n) && (oe(), _n(Me(), i, e, n, t, r)), nt } function Ri(e, n, t, r) { return st(e, li(), t) ? n + q(t) + r : Z } function I(e, n, t, r, i, o, s, a) { const l = S(), c = oe(), u = e + ee, d = c.firstCreatePass ? function qA(e, n, t, r, i, o, s, a, l) { const c = n.consts, u = Ai(n, e, 4, s || null, nr(c, a)); Jd(n, t, u, nr(c, l)), Ma(n, u); const d = u.tView = Xd(2, u, r, i, o, n.directiveRegistry, n.pipeRegistry, null, n.schemas, c, null); return null !== n.queries && (n.queries.template(n, u), d.queries = n.queries.embeddedTView(u)), u }(u, c, l, n, t, r, i, o, s) : c.data[u]; gn(d, !1); const p = uy(c, l, d, e); xa() && Qa(c, l, p, d), ot(p, l), _l(l, l[u] = Pv(p, l, p, d)), Ea(d) && Yd(c, l, d), null != s && Qd(l, d, a) } let uy = function dy(e, n, t, r) { return rr(!0), n[W].createComment("") }; function Ve(e) { return si(function FS() { return z.lFrame.contextLView }(), ee + e) } function b(e, n, t) { const r = S(); return st(r, li(), n) && Ft(oe(), Me(), r, e, n, r[W], t, !1), b } function hf(e, n, t, r, i) { const s = i ? "class" : "style"; rf(e, t, n.inputs[s], s, r) } function f(e, n, t, r) { const i = S(), o = oe(), s = ee + e, a = i[W], l = o.firstCreatePass ? function YA(e, n, t, r, i, o) { const s = n.consts, l = Ai(n, e, 2, r, nr(s, i)); return Jd(n, t, l, nr(s, o)), null !== l.attrs && vl(l, l.attrs, !1), null !== l.mergedAttrs && vl(l, l.mergedAttrs, !0), null !== n.queries && n.queries.elementStart(n, l), l }(s, o, i, n, t, r) : o.data[s], c = fy(o, i, l, a, n, e); i[s] = c; const u = Ea(l); return gn(l, !0), I_(a, c, l), 32 != (32 & l.flags) && xa() && Qa(o, i, c, l), 0 === function xS() { return z.lFrame.elementDepthCount }() && ot(c, i), function MS() { z.lFrame.elementDepthCount++ }(), u && (Yd(o, i, l), Kd(o, l, i)), null !== r && Qd(i, l), f } function h() { let e = Je(); ju() ? Vu() : (e = e.parent, gn(e, !1)); const n = e; (function kS(e) { return z.skipHydrationRootTNode === e })(n) && function OS() { z.skipHydrationRootTNode = null }(), function AS() { z.lFrame.elementDepthCount-- }(); const t = oe(); return t.firstCreatePass && (Ma(t, e), Mu(e) && t.queries.elementEnd(e)), null != n.classesWithoutHost && function ZS(e) { return 0 != (8 & e.flags) }(n) && hf(t, n, S(), n.classesWithoutHost, !0), null != n.stylesWithoutHost && function KS(e) { return 0 != (16 & e.flags) }(n) && hf(t, n, S(), n.stylesWithoutHost, !1), h } function M(e, n, t, r) { return f(e, n, t, r), h(), M } let fy = (e, n, t, r, i, o) => (rr(!0), Za(r, i, function Tm() { return z.lFrame.currentNamespace }())); function ge(e, n, t) { const r = S(), i = oe(), o = e + ee, s = i.firstCreatePass ? function JA(e, n, t, r, i) { const o = n.consts, s = nr(o, r), a = Ai(n, e, 8, "ng-container", s); return null !== s && vl(a, s, !0), Jd(n, t, a, nr(o, i)), null !== n.queries && n.queries.elementStart(n, a), a }(o, i, r, n, t) : i.data[o]; gn(s, !0); const a = py(i, r, s, e); return r[o] = a, xa() && Qa(i, r, a, s), ot(a, r), Ea(s) && (Yd(i, r, s), Kd(i, s, r)), null != t && Qd(r, s), ge } function me() { let e = Je(); const n = oe(); return ju() ? Vu() : (e = e.parent, gn(e, !1)), n.firstCreatePass && (Ma(n, e), Mu(e) && n.queries.elementEnd(e)), me } let py = (e, n, t, r) => (rr(!0), cd(n[W], "")); function ve() { return S() } function os(e) { return !!e && "function" == typeof e.then } function gy(e) { return !!e && "function" == typeof e.subscribe } function R(e, n, t, r) { const i = S(), o = oe(), s = Je(); return function _y(e, n, t, r, i, o, s) { const a = Ea(r), c = e.firstCreatePass && Fv(e), u = n[Oe], d = Ov(n); let p = !0; if (3 & r.type || s) { const y = wt(r, n), C = s ? s(y) : y, T = d.length, w = s ? L => s(we(L[r.index])) : r.index; let P = null; if (!s && a && (P = function nk(e, n, t, r) { const i = e.cleanup; if (null != i) for (let o = 0; o < i.length - 1; o += 2) { const s = i[o]; if (s === t && i[o + 1] === r) { const a = n[ei], l = i[o + 2]; return a.length > l ? a[l] : null } "string" == typeof s && (o += 2) } return null }(e, n, i, r.index)), null !== P) (P.__ngLastListenerFn__ || P).__ngNextListenerFn__ = o, P.__ngLastListenerFn__ = o, p = !1; else { o = yy(r, n, u, o, !1); const L = t.listen(C, i, o); d.push(o, L), c && c.push(i, w, T, T + 1) } } else o = yy(r, n, u, o, !1); const m = r.outputs; let v; if (p && null !== m && (v = m[i])) { const y = v.length; if (y) for (let C = 0; C < y; C += 2) { const Q = n[v[C]][v[C + 1]].subscribe(o), Ke = d.length; d.push(o, Q), c && c.push(i, r.index, Ke, -(Ke + 1)) } } }(o, i, i[W], s, e, n, r), R } function vy(e, n, t, r) { try { return pn(6, n, t), !1 !== t(r) } catch (i) { return jv(e, i), !1 } finally { pn(7, n, t) } } function yy(e, n, t, r, i) { return function o(s) { if (s === Function) return r; Yo(e.componentOffset > -1 ? Rt(e.index, n) : n); let l = vy(n, t, r, s), c = o.__ngNextListenerFn__; for (; c;)l = vy(n, t, c, s) && l, c = c.__ngNextListenerFn__; return i && !1 === l && s.preventDefault(), l } } function E(e = 1) { return function US(e) { return (z.lFrame.contextLView = function HS(e, n) { for (; e > 0;)n = n[ni], e--; return n }(e, z.lFrame.contextLView))[Oe] }(e) } function ss(e, n, t, r, i) { const o = S(), s = Ri(o, n, t, r); return s !== Z && Ft(oe(), Me(), o, e, s, o[W], i, !1), ss } function Sl(e, n) { return e << 17 | n << 2 } function ar(e) { return e >> 17 & 32767 } function pf(e) { return 2 | e } function Ar(e) { return (131068 & e) >> 2 } function gf(e, n) { return -131069 & e | n << 2 } function mf(e) { return 1 | e } function My(e, n, t, r, i) { const o = e[t + 1], s = null === n; let a = r ? ar(o) : Ar(o), l = !1; for (; 0 !== a && (!1 === l || s);) { const u = e[a + 1]; dk(e[a], n) && (l = !0, e[a + 1] = r ? mf(u) : pf(u)), a = r ? ar(u) : Ar(u) } l && (e[t + 1] = r ? pf(o) : mf(o)) } function dk(e, n) { return null === e || null == n || (Array.isArray(e) ? e[1] : e) === n || !(!Array.isArray(e) || "string" != typeof n) && mi(e, n) >= 0 } function Un(e, n, t) { return tn(e, n, t, !1), Un } function zt(e, n) { return tn(e, n, null, !0), zt } function tn(e, n, t, r) { const i = S(), o = oe(), s = On(2); o.firstUpdatePass && function Ly(e, n, t, r) { const i = e.data; if (null === i[t + 1]) { const o = i[ht()], s = function Fy(e, n) { return n >= e.expandoStartIndex }(e, t); (function Uy(e, n) { return 0 != (e.flags & (n ? 8 : 16)) })(o, r) && null === n && !s && (n = !1), n = function bk(e, n, t, r) { const i = function Uu(e) { const n = z.lFrame.currentDirectiveIndex; return -1 === n ? null : e[n] }(e); let o = r ? n.residualClasses : n.residualStyles; if (null === i) 0 === (r ? n.classBindings : n.styleBindings) && (t = as(t = _f(null, e, n, t, r), n.attrs, r), o = null); else { const s = n.directiveStylingLast; if (-1 === s || e[s] !== i) if (t = _f(i, e, n, t, r), null === o) { let l = function Dk(e, n, t) { const r = t ? n.classBindings : n.styleBindings; if (0 !== Ar(r)) return e[ar(r)] }(e, n, r); void 0 !== l && Array.isArray(l) && (l = _f(null, e, n, l[1], r), l = as(l, n.attrs, r), function Ck(e, n, t, r) { e[ar(t ? n.classBindings : n.styleBindings)] = r }(e, n, r, l)) } else o = function wk(e, n, t) { let r; const i = n.directiveEnd; for (let o = 1 + n.directiveStylingLast; o < i; o++)r = as(r, e[o].hostAttrs, t); return as(r, n.attrs, t) }(e, n, r) } return void 0 !== o && (r ? n.residualClasses = o : n.residualStyles = o), t }(i, o, n, r), function ck(e, n, t, r, i, o) { let s = o ? n.classBindings : n.styleBindings, a = ar(s), l = Ar(s); e[r] = t; let u, c = !1; if (Array.isArray(t) ? (u = t[1], (null === u || mi(t, u) > 0) && (c = !0)) : u = t, i) if (0 !== l) { const p = ar(e[a + 1]); e[r + 1] = Sl(p, a), 0 !== p && (e[p + 1] = gf(e[p + 1], r)), e[a + 1] = function ak(e, n) { return 131071 & e | n << 17 }(e[a + 1], r) } else e[r + 1] = Sl(a, 0), 0 !== a && (e[a + 1] = gf(e[a + 1], r)), a = r; else e[r + 1] = Sl(l, 0), 0 === a ? a = r : e[l + 1] = gf(e[l + 1], r), l = r; c && (e[r + 1] = pf(e[r + 1])), My(e, u, r, !0), My(e, u, r, !1), function uk(e, n, t, r, i) { const o = i ? e.residualClasses : e.residualStyles; null != o && "string" == typeof n && mi(o, n) >= 0 && (t[r + 1] = mf(t[r + 1])) }(n, u, e, r, o), s = Sl(a, l), o ? n.classBindings = s : n.styleBindings = s }(i, o, n, t, s, r) } }(o, e, s, r), n !== Z && st(i, s, n) && function Vy(e, n, t, r, i, o, s, a) { if (!(3 & n.type)) return; const l = e.data, c = l[a + 1], u = function lk(e) { return 1 == (1 & e) }(c) ? By(l, n, t, i, Ar(c), s) : void 0; Tl(u) || (Tl(o) || function sk(e) { return 2 == (2 & e) }(c) && (o = By(l, null, t, i, a, s)), function sx(e, n, t, r, i) { if (n) i ? e.addClass(t, r) : e.removeClass(t, r); else { let o = -1 === r.indexOf("-") ? void 0 : ir.DashCase; null == i ? e.removeStyle(t, r, o) : ("string" == typeof i && i.endsWith("!important") && (i = i.slice(0, -10), o |= ir.Important), e.setStyle(t, r, i, o)) } }(r, s, Ta(ht(), t), i, o)) }(o, o.data[ht()], i, i[W], e, i[s + 1] = function Tk(e, n) { return null == e || "" === e || ("string" == typeof n ? e += n : "object" == typeof e && (e = $e(or(e)))), e }(n, t), r, s) } function _f(e, n, t, r, i) { let o = null; const s = t.directiveEnd; let a = t.directiveStylingLast; for (-1 === a ? a = t.directiveStart : a++; a < s && (o = n[a], r = as(r, o.hostAttrs, i), o !== e);)a++; return null !== e && (t.directiveStylingLast = a), r } function as(e, n, t) { const r = t ? 1 : 2; let i = -1; if (null !== n) for (let o = 0; o < n.length; o++) { const s = n[o]; "number" == typeof s ? i = s : i === r && (Array.isArray(e) || (e = void 0 === e ? [] : ["", e]), Pt(e, s, !!t || n[++o])) } return void 0 === e ? null : e } function By(e, n, t, r, i, o) { const s = null === n; let a; for (; i > 0;) { const l = e[i], c = Array.isArray(l), u = c ? l[1] : l, d = null === u; let p = t[i + 1]; p === Z && (p = d ? ae : void 0); let m = d ? Ju(p, r) : u === r ? p : void 0; if (c && !Tl(m) && (m = Ju(l, r)), Tl(m) && (a = m, s)) return a; const v = e[i + 1]; i = s ? ar(v) : Ar(v) } if (null !== n) { let l = o ? n.residualClasses : n.residualStyles; null != l && (a = Ju(l, r)) } return a } function Tl(e) { return void 0 !== e } function g(e, n = "") { const t = S(), r = oe(), i = e + ee, o = r.firstCreatePass ? Ai(r, i, 1, n, null) : r.data[i], s = Hy(r, t, o, n, e); t[i] = s, xa() && Qa(r, t, s, o), gn(o, !1) } let Hy = (e, n, t, r, i) => (rr(!0), function Wa(e, n) { return e.createText(n) }(n[W], r)); function te(e) { return U("", e, ""), te } function U(e, n, t) { const r = S(), i = Ri(r, e, n, t); return i !== Z && Bn(r, ht(), i), U } function vf(e, n, t, r, i) { const o = S(), s = function Pi(e, n, t, r, i, o) { const a = Mr(e, Nn(), t, i); return On(2), a ? n + q(t) + r + q(i) + o : Z }(o, e, n, t, r, i); return s !== Z && Bn(o, ht(), s), vf } function Ui(e, n, t, r, i, o, s) { const a = S(), l = function Ni(e, n, t, r, i, o, s, a) { const c = Cl(e, Nn(), t, i, s); return On(3), c ? n + q(t) + r + q(i) + o + q(s) + a : Z }(a, e, n, t, r, i, o, s); return l !== Z && Bn(a, ht(), l), Ui } const kr = void 0; var Kk = ["en", [["a", "p"], ["AM", "PM"], kr], [["AM", "PM"], kr, kr], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], kr, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], kr, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", kr, "{1} 'at' {0}", kr], [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"], ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", function Zk(e) { const t = Math.floor(Math.abs(e)), r = e.toString().replace(/^[^.]*\.?/, "").length; return 1 === t && 0 === r ? 1 : 5 }]; let Hi = {}; function gt(e) { const n = function Yk(e) { return e.toLowerCase().replace(/_/g, "-") }(e); let t = ab(n); if (t) return t; const r = n.split("-")[0]; if (t = ab(r), t) return t; if ("en" === r) return Kk; throw new x(701, !1) } function ab(e) { return e in Hi || (Hi[e] = Ce.ng && Ce.ng.common && Ce.ng.common.locales && Ce.ng.common.locales[e]), Hi[e] } var Ie = function (e) { return e[e.LocaleId = 0] = "LocaleId", e[e.DayPeriodsFormat = 1] = "DayPeriodsFormat", e[e.DayPeriodsStandalone = 2] = "DayPeriodsStandalone", e[e.DaysFormat = 3] = "DaysFormat", e[e.DaysStandalone = 4] = "DaysStandalone", e[e.MonthsFormat = 5] = "MonthsFormat", e[e.MonthsStandalone = 6] = "MonthsStandalone", e[e.Eras = 7] = "Eras", e[e.FirstDayOfWeek = 8] = "FirstDayOfWeek", e[e.WeekendRange = 9] = "WeekendRange", e[e.DateFormat = 10] = "DateFormat", e[e.TimeFormat = 11] = "TimeFormat", e[e.DateTimeFormat = 12] = "DateTimeFormat", e[e.NumberSymbols = 13] = "NumberSymbols", e[e.NumberFormats = 14] = "NumberFormats", e[e.CurrencyCode = 15] = "CurrencyCode", e[e.CurrencySymbol = 16] = "CurrencySymbol", e[e.CurrencyName = 17] = "CurrencyName", e[e.Currencies = 18] = "Currencies", e[e.Directionality = 19] = "Directionality", e[e.PluralCase = 20] = "PluralCase", e[e.ExtraData = 21] = "ExtraData", e }(Ie || {}); const $i = "en-US"; let lb = $i; function Df(e, n, t, r, i) { if (e = G(e), Array.isArray(e)) for (let o = 0; o < e.length; o++)Df(e[o], n, t, r, i); else { const o = oe(), s = S(), a = Je(); let l = xr(e) ? e : G(e.provide); const c = G_(e), u = 1048575 & a.providerIndexes, d = a.directiveStart, p = a.providerIndexes >> 20; if (xr(e) || !e.multi) { const m = new Ro(c, i, D), v = wf(l, n, i ? u : u + p, d); -1 === v ? (Yu(Pa(a, s), o, l), Cf(o, e, n.length), n.push(l), a.directiveStart++, a.directiveEnd++, i && (a.providerIndexes += 1048576), t.push(m), s.push(m)) : (t[v] = m, s[v] = m) } else { const m = wf(l, n, u + p, d), v = wf(l, n, u, u + p), C = v >= 0 && t[v]; if (i && !C || !i && !(m >= 0 && t[m])) { Yu(Pa(a, s), o, l); const T = function ZR(e, n, t, r, i) { const o = new Ro(e, t, D); return o.multi = [], o.index = n, o.componentProviders = 0, Pb(o, i, r && !t), o }(i ? WR : qR, t.length, i, r, c); !i && C && (t[v].providerFactory = T), Cf(o, e, n.length, 0), n.push(l), a.directiveStart++, a.directiveEnd++, i && (a.providerIndexes += 1048576), t.push(T), s.push(T) } else Cf(o, e, m > -1 ? m : v, Pb(t[i ? v : m], c, !i && r)); !i && r && C && t[v].componentProviders++ } } } function Cf(e, n, t, r) { const i = xr(n), o = function Fx(e) { return !!e.useClass }(n); if (i || o) { const l = (o ? G(n.useClass) : n).prototype.ngOnDestroy; if (l) { const c = e.destroyHooks || (e.destroyHooks = []); if (!i && n.multi) { const u = c.indexOf(t); -1 === u ? c.push(t, [r, l]) : c[u + 1].push(r, l) } else c.push(t, l) } } } function Pb(e, n, t) { return t && e.componentProviders++, e.multi.push(n) - 1 } function wf(e, n, t, r) { for (let i = t; i < r; i++)if (n[i] === e) return i; return -1 } function qR(e, n, t, r) { return Ef(this.multi, []) } function WR(e, n, t, r) { const i = this.multi; let o; if (this.providerFactory) { const s = this.providerFactory.componentProviders, a = Sr(t, t[N], this.providerFactory.index, r); o = a.slice(0, s), Ef(i, o); for (let l = s; l < a.length; l++)o.push(a[l]) } else o = [], Ef(i, o); return o } function Ef(e, n) { for (let t = 0; t < e.length; t++)n.push((0, e[t])()); return n } function fe(e, n = []) { return t => { t.providersResolver = (r, i) => function GR(e, n, t) { const r = oe(); if (r.firstCreatePass) { const i = en(e); Df(t, r.data, r.blueprint, i, !0), Df(n, r.data, r.blueprint, i, !1) } }(r, i ? i(e) : e, n) } } class Rr { } class Nb { } class If extends Rr { constructor(n, t, r) { super(), this._parent = t, this._bootstrapComponents = [], this.destroyCbs = [], this.componentFactoryResolver = new Gv(this); const i = At(n); this._bootstrapComponents = Vn(i.bootstrap), this._r3Injector = iv(n, t, [{ provide: Rr, useValue: this }, { provide: dl, useValue: this.componentFactoryResolver }, ...r], $e(n), new Set(["environment"])), this._r3Injector.resolveInjectorInitializers(), this.instance = this._r3Injector.get(n) } get injector() { return this._r3Injector } destroy() { const n = this._r3Injector; !n.destroyed && n.destroy(), this.destroyCbs.forEach(t => t()), this.destroyCbs = null } onDestroy(n) { this.destroyCbs.push(n) } } class Sf extends Nb { constructor(n) { super(), this.moduleType = n } create(n) { return new If(this.moduleType, n, []) } } class Ob extends Rr { constructor(n) { super(), this.componentFactoryResolver = new Gv(this), this.instance = null; const t = new wi([...n.providers, { provide: Rr, useValue: this }, { provide: dl, useValue: this.componentFactoryResolver }], n.parent || il(), n.debugName, new Set(["environment"])); this.injector = t, n.runEnvironmentInitializers && t.resolveInjectorInitializers() } destroy() { this.injector.destroy() } onDestroy(n) { this.injector.onDestroy(n) } } function Tf(e, n, t = null) { return new Ob({ providers: e, parent: n, debugName: t, runEnvironmentInitializers: !0 }).injector } let QR = (() => { class e { constructor(t) { this._injector = t, this.cachedInjectors = new Map } getOrCreateStandaloneInjector(t) { if (!t.standalone) return null; if (!this.cachedInjectors.has(t)) { const r = U_(0, t.type), i = r.length > 0 ? Tf([r], this._injector, `Standalone[${t.type.name}]`) : null; this.cachedInjectors.set(t, i) } return this.cachedInjectors.get(t) } ngOnDestroy() { try { for (const t of this.cachedInjectors.values()) null !== t && t.destroy() } finally { this.cachedInjectors.clear() } } static { this.\u0275prov = F({ token: e, providedIn: "environment", factory: () => new e(k(Nt)) }) } } return e })(); function Fb(e) { e.getStandaloneInjector = n => n.get(QR).getOrCreateStandaloneInjector(e) } function Gt(e, n, t) { const r = ft() + e, i = S(); return i[r] === Z ? vn(i, r, t ? n.call(t) : n()) : function ts(e, n) { return e[n] }(i, r) } function Mf(e, n, t, r) { return $b(S(), ft(), e, n, t, r) } function hs(e, n, t, r, i, o) { return Gb(S(), ft(), e, n, t, r, i, o) } function Rl(e, n, t, r, i, o, s) { return function qb(e, n, t, r, i, o, s, a, l) { const c = n + t; return function $t(e, n, t, r, i, o) { const s = Mr(e, n, t, r); return Mr(e, n + 2, i, o) || s }(e, c, i, o, s, a) ? vn(e, c + 4, l ? r.call(l, i, o, s, a) : r(i, o, s, a)) : ps(e, c + 4) }(S(), ft(), e, n, t, r, i, o, s) } function ps(e, n) { const t = e[n]; return t === Z ? void 0 : t } function $b(e, n, t, r, i, o) { const s = n + t; return st(e, s, i) ? vn(e, s + 1, o ? r.call(o, i) : r(i)) : ps(e, s + 1) } function Gb(e, n, t, r, i, o, s, a) { const l = n + t; return Cl(e, l, i, o, s) ? vn(e, l + 3, a ? r.call(a, i, o, s) : r(i, o, s)) : ps(e, l + 3) } function qt(e, n) { const t = oe(); let r; const i = e + ee; t.firstCreatePass ? (r = function fP(e, n) { if (n) for (let t = n.length - 1; t >= 0; t--) { const r = n[t]; if (e === r.name) return r } }(n, t.pipeRegistry), t.data[i] = r, r.onDestroy && (t.destroyHooks ??= []).push(i, r.onDestroy)) : r = t.data[i]; const o = r.factory || (r.factory = Er(r.type)), a = yt(D); try { const l = Ra(!1), c = o(); return Ra(l), function KA(e, n, t, r) { t >= e.data.length && (e.data[t] = null, e.blueprint[t] = null), n[t] = r }(t, S(), i, c), c } finally { yt(a) } } function gs(e, n, t) { const r = e + ee, i = S(), o = si(i, r); return ms(i, r) ? $b(i, ft(), n, o.transform, t, o) : o.transform(t) } function Af(e, n, t, r) { const i = e + ee, o = S(), s = si(o, i); return ms(o, i) ? function zb(e, n, t, r, i, o, s) { const a = n + t; return Mr(e, a, i, o) ? vn(e, a + 2, s ? r.call(s, i, o) : r(i, o)) : ps(e, a + 2) }(o, ft(), n, s.transform, t, r, s) : s.transform(t, r) } function zi(e, n, t, r, i) { const o = e + ee, s = S(), a = si(s, o); return ms(s, o) ? Gb(s, ft(), n, a.transform, t, r, i, a) : a.transform(t, r, i) } function ms(e, n) { return e[N].data[n].pure } function gP() { return this._results[Symbol.iterator]() } class _s { get changes() { return this._changes || (this._changes = new se) } constructor(n = !1) { this._emitDistinctChangesOnly = n, this.dirty = !0, this._results = [], this._changesDetected = !1, this._changes = null, this.length = 0, this.first = void 0, this.last = void 0; const t = _s.prototype; t[Symbol.iterator] || (t[Symbol.iterator] = gP) } get(n) { return this._results[n] } map(n) { return this._results.map(n) } filter(n) { return this._results.filter(n) } find(n) { return this._results.find(n) } reduce(n, t) { return this._results.reduce(n, t) } forEach(n) { this._results.forEach(n) } some(n) { return this._results.some(n) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(n, t) { const r = this; r.dirty = !1; const i = function Ht(e) { return e.flat(Number.POSITIVE_INFINITY) }(n); (this._changesDetected = !function cT(e, n, t) { if (e.length !== n.length) return !1; for (let r = 0; r < e.length; r++) { let i = e[r], o = n[r]; if (t && (i = t(i), o = t(o)), o !== i) return !1 } return !0 }(r._results, i, t)) && (r._results = i, r.length = i.length, r.last = i[this.length - 1], r.first = i[0]) } notifyOnChanges() { this._changes && (this._changesDetected || !this._emitDistinctChangesOnly) && this._changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } function _P(e, n, t, r = !0) { const i = n[N]; if (function XT(e, n, t, r) { const i = Qe + r, o = t.length; r > 0 && (t[i - 1][Jt] = n), r < o - Qe ? (n[Jt] = t[i], Hm(t, Qe + r, n)) : (t.push(n), n[Jt] = null), n[Te] = t; const s = n[Io]; null !== s && t !== s && function JT(e, n) { const t = e[ii]; n[Fe] !== n[Te][Te][Fe] && (e[Hg] = !0), null === t ? e[ii] = [n] : t.push(n) }(s, n); const a = n[fn]; null !== a && a.insertView(e), n[K] |= 128 }(i, n, e, t), r) { const o = pd(t, e), s = n[W], a = Ya(s, e[hn]); null !== a && function KT(e, n, t, r, i, o) { r[Ae] = i, r[it] = n, Ho(e, r, t, 1, i, o) }(i, e[it], s, n, a, o) } } let rn = (() => { class e { static { this.__NG_ELEMENT_ID__ = bP } } return e })(); const vP = rn, yP = class extends vP { constructor(n, t, r) { super(), this._declarationLView = n, this._declarationTContainer = t, this.elementRef = r } get ssrId() { return this._declarationTContainer.tView?.ssrId || null } createEmbeddedView(n, t) { return this.createEmbeddedViewImpl(n, t) } createEmbeddedViewImpl(n, t, r) { const i = function mP(e, n, t, r) { const i = n.tView, a = ml(e, i, t, 4096 & e[K] ? 4096 : 16, null, n, null, null, null, r?.injector ?? null, r?.hydrationInfo ?? null); a[Io] = e[n.index]; const c = e[fn]; return null !== c && (a[fn] = c.createEmbeddedView(i)), sf(i, a, t), a }(this._declarationLView, this._declarationTContainer, n, { injector: t, hydrationInfo: r }); return new Jo(i) } }; function bP() { return Pl(Je(), S()) } function Pl(e, n) { return 4 & e.type ? new yP(n, e, Ti(e, n)) : null } let Wt = (() => { class e { static { this.__NG_ELEMENT_ID__ = SP } } return e })(); function SP() { return e0(Je(), S()) } const TP = Wt, Xb = class extends TP { constructor(n, t, r) { super(), this._lContainer = n, this._hostTNode = t, this._hostLView = r } get element() { return Ti(this._hostTNode, this._hostLView) } get injector() { return new pt(this._hostTNode, this._hostLView) } get parentInjector() { const n = Na(this._hostTNode, this._hostLView); if (Wu(n)) { const t = No(n, this._hostLView), r = Po(n); return new pt(t[N].data[r + 8], t) } return new pt(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(n) { const t = Jb(this._lContainer); return null !== t && t[n] || null } get length() { return this._lContainer.length - Qe } createEmbeddedView(n, t, r) { let i, o; "number" == typeof r ? i = r : null != r && (i = r.index, o = r.injector); const a = n.createEmbeddedViewImpl(t || {}, o, null); return this.insertImpl(a, i, false), a } createComponent(n, t, r, i, o) { const s = n && !function Fo(e) { return "function" == typeof e }(n); let a; if (s) a = t; else { const y = t || {}; a = y.index, r = y.injector, i = y.projectableNodes, o = y.environmentInjector || y.ngModuleRef } const l = s ? n : new es(ie(n)), c = r || this.parentInjector; if (!o && null == l.ngModule) { const C = (s ? c : this.parentInjector).get(Nt, null); C && (o = C) } ie(l.componentType ?? {}); const m = l.create(c, i, null, o); return this.insertImpl(m.hostView, a, false), m } insert(n, t) { return this.insertImpl(n, t, !1) } insertImpl(n, t, r) { const i = n._lView; if (function IS(e) { return dt(e[Te]) }(i)) { const l = this.indexOf(n); if (-1 !== l) this.detach(l); else { const c = i[Te], u = new Xb(c, c[it], c[Te]); u.detach(u.indexOf(n)) } } const s = this._adjustIndex(t), a = this._lContainer; return _P(a, i, s, !r), n.attachToViewContainerRef(), Hm(kf(a), s, n), n } move(n, t) { return this.insert(n, t) } indexOf(n) { const t = Jb(this._lContainer); return null !== t ? t.indexOf(n) : -1 } remove(n) { const t = this._adjustIndex(n, -1), r = Ka(this._lContainer, t); r && (La(kf(this._lContainer), t), ud(r[N], r)) } detach(n) { const t = this._adjustIndex(n, -1), r = Ka(this._lContainer, t); return r && null != La(kf(this._lContainer), t) ? new Jo(r) : null } _adjustIndex(n, t = 0) { return n ?? this.length + t } }; function Jb(e) { return e[8] } function kf(e) { return e[8] || (e[8] = []) } function e0(e, n) { let t; const r = n[e.index]; return dt(r) ? t = r : (t = Pv(r, n, null, e), n[e.index] = t, _l(n, t)), t0(t, n, e, r), new Xb(t, e, n) } let t0 = function n0(e, n, t, r) { if (e[hn]) return; let i; i = 8 & t.type ? we(r) : function xP(e, n) { const t = e[W], r = t.createComment(""), i = wt(n, e); return Tr(t, Ya(t, i), r, function rx(e, n) { return e.nextSibling(n) }(t, i), !1), r }(n, t), e[hn] = i }; class Rf { constructor(n) { this.queryList = n, this.matches = null } clone() { return new Rf(this.queryList) } setDirty() { this.queryList.setDirty() } } class Pf { constructor(n = []) { this.queries = n } createEmbeddedView(n) { const t = n.queries; if (null !== t) { const r = null !== n.contentQueries ? n.contentQueries[0] : t.length, i = []; for (let o = 0; o < r; o++) { const s = t.getByIndex(o); i.push(this.queries[s.indexInDeclarationView].clone()) } return new Pf(i) } return null } insertView(n) { this.dirtyQueriesWithMatches(n) } detachView(n) { this.dirtyQueriesWithMatches(n) } dirtyQueriesWithMatches(n) { for (let t = 0; t < this.queries.length; t++)null !== c0(n, t).matches && this.queries[t].setDirty() } } class r0 { constructor(n, t, r = null) { this.predicate = n, this.flags = t, this.read = r } } class Nf { constructor(n = []) { this.queries = n } elementStart(n, t) { for (let r = 0; r < this.queries.length; r++)this.queries[r].elementStart(n, t) } elementEnd(n) { for (let t = 0; t < this.queries.length; t++)this.queries[t].elementEnd(n) } embeddedTView(n) { let t = null; for (let r = 0; r < this.length; r++) { const i = null !== t ? t.length : 0, o = this.getByIndex(r).embeddedTView(n, i); o && (o.indexInDeclarationView = r, null !== t ? t.push(o) : t = [o]) } return null !== t ? new Nf(t) : null } template(n, t) { for (let r = 0; r < this.queries.length; r++)this.queries[r].template(n, t) } getByIndex(n) { return this.queries[n] } get length() { return this.queries.length } track(n) { this.queries.push(n) } } class Of { constructor(n, t = -1) { this.metadata = n, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = t } elementStart(n, t) { this.isApplyingToNode(t) && this.matchTNode(n, t) } elementEnd(n) { this._declarationNodeIndex === n.index && (this._appliesToNextNode = !1) } template(n, t) { this.elementStart(n, t) } embeddedTView(n, t) { return this.isApplyingToNode(n) ? (this.crossesNgTemplate = !0, this.addMatch(-n.index, t), new Of(this.metadata)) : null } isApplyingToNode(n) { if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) { const t = this._declarationNodeIndex; let r = n.parent; for (; null !== r && 8 & r.type && r.index !== t;)r = r.parent; return t === (null !== r ? r.index : -1) } return this._appliesToNextNode } matchTNode(n, t) { const r = this.metadata.predicate; if (Array.isArray(r)) for (let i = 0; i < r.length; i++) { const o = r[i]; this.matchTNodeWithReadOption(n, t, kP(t, o)), this.matchTNodeWithReadOption(n, t, Oa(t, n, o, !1, !1)) } else r === rn ? 4 & t.type && this.matchTNodeWithReadOption(n, t, -1) : this.matchTNodeWithReadOption(n, t, Oa(t, n, r, !1, !1)) } matchTNodeWithReadOption(n, t, r) { if (null !== r) { const i = this.metadata.read; if (null !== i) if (i === tt || i === Wt || i === rn && 4 & t.type) this.addMatch(t.index, -2); else { const o = Oa(t, n, i, !1, !1); null !== o && this.addMatch(t.index, o) } else this.addMatch(t.index, r) } } addMatch(n, t) { null === this.matches ? this.matches = [n, t] : this.matches.push(n, t) } } function kP(e, n) { const t = e.localNames; if (null !== t) for (let r = 0; r < t.length; r += 2)if (t[r] === n) return t[r + 1]; return null } function PP(e, n, t, r) { return -1 === t ? function RP(e, n) { return 11 & e.type ? Ti(e, n) : 4 & e.type ? Pl(e, n) : null }(n, e) : -2 === t ? function NP(e, n, t) { return t === tt ? Ti(n, e) : t === rn ? Pl(n, e) : t === Wt ? e0(n, e) : void 0 }(e, n, r) : Sr(e, e[N], t, n) } function o0(e, n, t, r) { const i = n[fn].queries[r]; if (null === i.matches) { const o = e.data, s = t.matches, a = []; for (let l = 0; l < s.length; l += 2) { const c = s[l]; a.push(c < 0 ? null : PP(n, o[c], s[l + 1], t.metadata.read)) } i.matches = a } return i.matches } function Ff(e, n, t, r) { const i = e.queries.getByIndex(t), o = i.matches; if (null !== o) { const s = o0(e, n, i, t); for (let a = 0; a < o.length; a += 2) { const l = o[a]; if (l > 0) r.push(s[a / 2]); else { const c = o[a + 1], u = n[-l]; for (let d = Qe; d < u.length; d++) { const p = u[d]; p[Io] === p[Te] && Ff(p[N], p, c, r) } if (null !== u[ii]) { const d = u[ii]; for (let p = 0; p < d.length; p++) { const m = d[p]; Ff(m[N], m, c, r) } } } } } return r } function Gi(e) { const n = S(), t = oe(), r = Dm(); Hu(r + 1); const i = c0(t, r); if (e.dirty && function wS(e) { return 4 == (4 & e[K]) }(n) === (2 == (2 & i.metadata.flags))) { if (null === i.matches) e.reset([]); else { const o = i.crossesNgTemplate ? Ff(t, n, r, []) : o0(t, n, i, r); e.reset(o, rM), e.notifyOnChanges() } return !0 } return !1 } function vs(e, n, t, r) { const i = oe(); if (i.firstCreatePass) { const o = Je(); l0(i, new r0(n, t, r), o.index), function FP(e, n) { const t = e.contentQueries || (e.contentQueries = []); n !== (t.length ? t[t.length - 1] : -1) && t.push(e.queries.length - 1, n) }(i, e), 2 == (2 & t) && (i.staticContentQueries = !0) } a0(i, S(), t) } function qi() { return function OP(e, n) { return e[fn].queries[n].queryList }(S(), Dm()) } function a0(e, n, t) { const r = new _s(4 == (4 & t)); (function FM(e, n, t, r) { const i = Ov(n); i.push(t), e.firstCreatePass && Fv(e).push(r, i.length - 1) })(e, n, r, r.destroy), null === n[fn] && (n[fn] = new Pf), n[fn].queries.push(new Rf(r)) } function l0(e, n, t) { null === e.queries && (e.queries = new Nf), e.queries.track(new Of(n, t)) } function c0(e, n) { return e.queries.getByIndex(n) } function qe(e, n) { return Pl(e, n) } const Hf = new A("Application Initializer"); let $f = (() => { class e { constructor() { this.initialized = !1, this.done = !1, this.donePromise = new Promise((t, r) => { this.resolve = t, this.reject = r }), this.appInits = O(Hf, { optional: !0 }) ?? [] } runInitializers() { if (this.initialized) return; const t = []; for (const i of this.appInits) { const o = i(); if (os(o)) t.push(o); else if (gy(o)) { const s = new Promise((a, l) => { o.subscribe({ complete: a, error: l }) }); t.push(s) } } const r = () => { this.done = !0, this.resolve() }; Promise.all(t).then(() => { r() }).catch(i => { this.reject(i) }), 0 === t.length && r(), this.initialized = !0 } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(), S0 = (() => { class e { log(t) { console.log(t) } warn(t) { console.warn(t) } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "platform" }) } } return e })(); const Hn = new A("LocaleId", { providedIn: "root", factory: () => O(Hn, J.Optional | J.SkipSelf) || function rN() { return typeof $localize < "u" && $localize.locale || $i }() }); let Fl = (() => { class e { constructor() { this.taskId = 0, this.pendingTasks = new Set, this.hasPendingTasks = new xt(!1) } add() { this.hasPendingTasks.next(!0); const t = this.taskId++; return this.pendingTasks.add(t), t } remove(t) { this.pendingTasks.delete(t), 0 === this.pendingTasks.size && this.hasPendingTasks.next(!1) } ngOnDestroy() { this.pendingTasks.clear(), this.hasPendingTasks.next(!1) } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); class sN { constructor(n, t) { this.ngModuleFactory = n, this.componentFactories = t } } let T0 = (() => { class e { compileModuleSync(t) { return new Sf(t) } compileModuleAsync(t) { return Promise.resolve(this.compileModuleSync(t)) } compileModuleAndAllComponentsSync(t) { const r = this.compileModuleSync(t), o = Vn(At(t).declarations).reduce((s, a) => { const l = ie(a); return l && s.push(new es(l)), s }, []); return new sN(r, o) } compileModuleAndAllComponentsAsync(t) { return Promise.resolve(this.compileModuleAndAllComponentsSync(t)) } clearCache() { } clearCacheFor(t) { } getModuleId(t) { } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); const k0 = new A(""), jl = new A(""); let Zf, qf = (() => { class e { constructor(t, r, i) { this._ngZone = t, this.registry = r, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, Zf || (function xN(e) { Zf = e }(i), i.addToWindow(r)), this._watchAngularEvents(), t.run(() => { this.taskTrackingZone = typeof Zone > "u" ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { le.assertNotInAngularZone(), queueMicrotask(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) queueMicrotask(() => { for (; 0 !== this._callbacks.length;) { let t = this._callbacks.pop(); clearTimeout(t.timeoutId), t.doneCb(this._didWork) } this._didWork = !1 }); else { let t = this.getPendingTasks(); this._callbacks = this._callbacks.filter(r => !r.updateCb || !r.updateCb(t) || (clearTimeout(r.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(t => ({ source: t.source, creationLocation: t.creationLocation, data: t.data })) : [] } addCallback(t, r, i) { let o = -1; r && r > 0 && (o = setTimeout(() => { this._callbacks = this._callbacks.filter(s => s.timeoutId !== o), t(this._didWork, this.getPendingTasks()) }, r)), this._callbacks.push({ doneCb: t, timeoutId: o, updateCb: i }) } whenStable(t, r, i) { if (i && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(t, r, i), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } registerApplication(t) { this.registry.registerApplication(t, this) } unregisterApplication(t) { this.registry.unregisterApplication(t) } findProviders(t, r, i) { return [] } static { this.\u0275fac = function (r) { return new (r || e)(k(le), k(Wf), k(jl)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac }) } } return e })(), Wf = (() => { class e { constructor() { this._applications = new Map } registerApplication(t, r) { this._applications.set(t, r) } unregisterApplication(t) { this._applications.delete(t) } unregisterAllApplications() { this._applications.clear() } getTestability(t) { return this._applications.get(t) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(t, r = !0) { return Zf?.findTestabilityInTree(this, t, r) ?? null } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "platform" }) } } return e })(), lr = null; const R0 = new A("AllowMultipleToken"), Kf = new A("PlatformDestroyListeners"), Yf = new A("appBootstrapListener"); class N0 { constructor(n, t) { this.name = n, this.token = t } } function F0(e, n, t = []) { const r = `Platform: ${n}`, i = new A(r); return (o = []) => { let s = Qf(); if (!s || s.injector.get(R0, !1)) { const a = [...t, ...o, { provide: i, useValue: !0 }]; e ? e(a) : function kN(e) { if (lr && !lr.get(R0, !1)) throw new x(400, !1); (function P0() { !function uS(e) { em = e }(() => { throw new x(600, !1) }) })(), lr = e; const n = e.get(j0); (function O0(e) { e.get(q_, null)?.forEach(t => t()) })(e) }(function L0(e = [], n) { return Ot.create({ name: n, providers: [{ provide: Td, useValue: "platform" }, { provide: Kf, useValue: new Set([() => lr = null]) }, ...e] }) }(a, r)) } return function PN(e) { const n = Qf(); if (!n) throw new x(401, !1); return n }() } } function Qf() { return lr?.get(j0) ?? null } let j0 = (() => { class e { constructor(t) { this._injector = t, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(t, r) { const i = function NN(e = "zone.js", n) { return "noop" === e ? new yM : "zone.js" === e ? new le(n) : e }(r?.ngZone, function V0(e) { return { enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: e?.eventCoalescing ?? !1, shouldCoalesceRunChangeDetection: e?.runCoalescing ?? !1 } }({ eventCoalescing: r?.ngZoneEventCoalescing, runCoalescing: r?.ngZoneRunCoalescing })); return i.run(() => { const o = function YR(e, n, t) { return new If(e, n, t) }(t.moduleType, this.injector, function z0(e) { return [{ provide: le, useFactory: e }, { provide: qo, multi: !0, useFactory: () => { const n = O(FN, { optional: !0 }); return () => n.initialize() } }, { provide: $0, useFactory: ON }, { provide: cv, useFactory: uv }] }(() => i)), s = o.injector.get(jn, null); return i.runOutsideAngular(() => { const a = i.onError.subscribe({ next: l => { s.handleError(l) } }); o.onDestroy(() => { Vl(this._modules, o), a.unsubscribe() }) }), function B0(e, n, t) { try { const r = t(); return os(r) ? r.catch(i => { throw n.runOutsideAngular(() => e.handleError(i)), i }) : r } catch (r) { throw n.runOutsideAngular(() => e.handleError(r)), r } }(s, i, () => { const a = o.injector.get($f); return a.runInitializers(), a.donePromise.then(() => (function cb(e) { Bt(e, "Expected localeId to be defined"), "string" == typeof e && (lb = e.toLowerCase().replace(/_/g, "-")) }(o.injector.get(Hn, $i) || $i), this._moduleDoBootstrap(o), o)) }) }) } bootstrapModule(t, r = []) { const i = U0({}, r); return function MN(e, n, t) { const r = new Sf(t); return Promise.resolve(r) }(0, 0, t).then(o => this.bootstrapModuleFactory(o, i)) } _moduleDoBootstrap(t) { const r = t.injector.get(Ki); if (t._bootstrapComponents.length > 0) t._bootstrapComponents.forEach(i => r.bootstrap(i)); else { if (!t.instance.ngDoBootstrap) throw new x(-403, !1); t.instance.ngDoBootstrap(r) } this._modules.push(t) } onDestroy(t) { this._destroyListeners.push(t) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new x(404, !1); this._modules.slice().forEach(r => r.destroy()), this._destroyListeners.forEach(r => r()); const t = this._injector.get(Kf, null); t && (t.forEach(r => r()), t.clear()), this._destroyed = !0 } get destroyed() { return this._destroyed } static { this.\u0275fac = function (r) { return new (r || e)(k(Ot)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "platform" }) } } return e })(); function U0(e, n) { return Array.isArray(n) ? n.reduce(U0, e) : { ...e, ...n } } let Ki = (() => { class e { constructor() { this._bootstrapListeners = [], this._runningTick = !1, this._destroyed = !1, this._destroyListeners = [], this._views = [], this.internalErrorHandler = O($0), this.zoneIsStable = O(cv), this.componentTypes = [], this.components = [], this.isStable = O(Fl).hasPendingTasks.pipe(Vt(t => t ? H(!1) : this.zoneIsStable), function DI(e, n = Yn) { return e = e ?? CI, Ne((t, r) => { let i, o = !0; t.subscribe(xe(r, s => { const a = n(s); (o || !e(i, a)) && (o = !1, i = a, r.next(s)) })) }) }(), vg()), this._injector = O(Nt) } get destroyed() { return this._destroyed } get injector() { return this._injector } bootstrap(t, r) { const i = t instanceof Q_; if (!this._injector.get($f).done) throw !i && function Jr(e) { const n = ie(e) || Ye(e) || ut(e); return null !== n && n.standalone }(t), new x(405, !1); let s; s = i ? t : this._injector.get(dl).resolveComponentFactory(t), this.componentTypes.push(s.componentType); const a = function AN(e) { return e.isBoundToModule }(s) ? void 0 : this._injector.get(Rr), c = s.create(Ot.NULL, [], r || s.selector, a), u = c.location.nativeElement, d = c.injector.get(k0, null); return d?.registerApplication(u), c.onDestroy(() => { this.detachView(c.hostView), Vl(this.components, c), d?.unregisterApplication(u) }), this._loadComponent(c), c } tick() { if (this._runningTick) throw new x(101, !1); try { this._runningTick = !0; for (let t of this._views) t.detectChanges() } catch (t) { this.internalErrorHandler(t) } finally { this._runningTick = !1 } } attachView(t) { const r = t; this._views.push(r), r.attachToAppRef(this) } detachView(t) { const r = t; Vl(this._views, r), r.detachFromAppRef() } _loadComponent(t) { this.attachView(t.hostView), this.tick(), this.components.push(t); const r = this._injector.get(Yf, []); r.push(...this._bootstrapListeners), r.forEach(i => i(t)) } ngOnDestroy() { if (!this._destroyed) try { this._destroyListeners.forEach(t => t()), this._views.slice().forEach(t => t.destroy()) } finally { this._destroyed = !0, this._views = [], this._bootstrapListeners = [], this._destroyListeners = [] } } onDestroy(t) { return this._destroyListeners.push(t), () => Vl(this._destroyListeners, t) } destroy() { if (this._destroyed) throw new x(406, !1); const t = this._injector; t.destroy && !t.destroyed && t.destroy() } get viewCount() { return this._views.length } warnIfDestroyed() { } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); function Vl(e, n) { const t = e.indexOf(n); t > -1 && e.splice(t, 1) } const $0 = new A("", { providedIn: "root", factory: () => O(jn).handleError.bind(void 0) }); function ON() { const e = O(le), n = O(jn); return t => e.runOutsideAngular(() => n.handleError(t)) } let FN = (() => { class e { constructor() { this.zone = O(le), this.applicationRef = O(Ki) } initialize() { this._onMicrotaskEmptySubscription || (this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({ next: () => { this.zone.run(() => { this.applicationRef.tick() }) } })) } ngOnDestroy() { this._onMicrotaskEmptySubscription?.unsubscribe() } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); let Pr = (() => { class e { static { this.__NG_ELEMENT_ID__ = jN } } return e })(); function jN(e) { return function VN(e, n, t) { if (wr(e) && !t) { const r = Rt(e.index, n); return new Jo(r, r) } return 47 & e.type ? new Jo(n[Fe], n) : null }(Je(), S(), 16 == (16 & e)) } class K0 { constructor() { } supports(n) { return Dl(n) } create(n) { return new zN(n) } } const $N = (e, n) => n; class zN { constructor(n) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = n || $N } forEachItem(n) { let t; for (t = this._itHead; null !== t; t = t._next)n(t) } forEachOperation(n) { let t = this._itHead, r = this._removalsHead, i = 0, o = null; for (; t || r;) { const s = !r || t && t.currentIndex < Q0(r, i, o) ? t : r, a = Q0(s, i, o), l = s.currentIndex; if (s === r) i--, r = r._nextRemoved; else if (t = t._next, null == s.previousIndex) i++; else { o || (o = []); const c = a - i, u = l - i; if (c != u) { for (let p = 0; p < c; p++) { const m = p < o.length ? o[p] : o[p] = 0, v = m + p; u <= v && v < c && (o[p] = m + 1) } o[s.previousIndex] = u - c } } a !== l && n(s, a, l) } } forEachPreviousItem(n) { let t; for (t = this._previousItHead; null !== t; t = t._nextPrevious)n(t) } forEachAddedItem(n) { let t; for (t = this._additionsHead; null !== t; t = t._nextAdded)n(t) } forEachMovedItem(n) { let t; for (t = this._movesHead; null !== t; t = t._nextMoved)n(t) } forEachRemovedItem(n) { let t; for (t = this._removalsHead; null !== t; t = t._nextRemoved)n(t) } forEachIdentityChange(n) { let t; for (t = this._identityChangesHead; null !== t; t = t._nextIdentityChange)n(t) } diff(n) { if (null == n && (n = []), !Dl(n)) throw new x(900, !1); return this.check(n) ? this : null } onDestroy() { } check(n) { this._reset(); let i, o, s, t = this._itHead, r = !1; if (Array.isArray(n)) { this.length = n.length; for (let a = 0; a < this.length; a++)o = n[a], s = this._trackByFn(a, o), null !== t && Object.is(t.trackById, s) ? (r && (t = this._verifyReinsertion(t, o, s, a)), Object.is(t.item, o) || this._addIdentityChange(t, o)) : (t = this._mismatch(t, o, s, a), r = !0), t = t._next } else i = 0, function xA(e, n) { if (Array.isArray(e)) for (let t = 0; t < e.length; t++)n(e[t]); else { const t = e[Symbol.iterator](); let r; for (; !(r = t.next()).done;)n(r.value) } }(n, a => { s = this._trackByFn(i, a), null !== t && Object.is(t.trackById, s) ? (r && (t = this._verifyReinsertion(t, a, s, i)), Object.is(t.item, a) || this._addIdentityChange(t, a)) : (t = this._mismatch(t, a, s, i), r = !0), t = t._next, i++ }), this.length = i; return this._truncate(t), this.collection = n, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let n; for (n = this._previousItHead = this._itHead; null !== n; n = n._next)n._nextPrevious = n._next; for (n = this._additionsHead; null !== n; n = n._nextAdded)n.previousIndex = n.currentIndex; for (this._additionsHead = this._additionsTail = null, n = this._movesHead; null !== n; n = n._nextMoved)n.previousIndex = n.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(n, t, r, i) { let o; return null === n ? o = this._itTail : (o = n._prev, this._remove(n)), null !== (n = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null)) ? (Object.is(n.item, t) || this._addIdentityChange(n, t), this._reinsertAfter(n, o, i)) : null !== (n = null === this._linkedRecords ? null : this._linkedRecords.get(r, i)) ? (Object.is(n.item, t) || this._addIdentityChange(n, t), this._moveAfter(n, o, i)) : n = this._addAfter(new GN(t, r), o, i), n } _verifyReinsertion(n, t, r, i) { let o = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null); return null !== o ? n = this._reinsertAfter(o, n._prev, i) : n.currentIndex != i && (n.currentIndex = i, this._addToMoves(n, i)), n } _truncate(n) { for (; null !== n;) { const t = n._next; this._addToRemovals(this._unlink(n)), n = t } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(n, t, r) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(n); const i = n._prevRemoved, o = n._nextRemoved; return null === i ? this._removalsHead = o : i._nextRemoved = o, null === o ? this._removalsTail = i : o._prevRemoved = i, this._insertAfter(n, t, r), this._addToMoves(n, r), n } _moveAfter(n, t, r) { return this._unlink(n), this._insertAfter(n, t, r), this._addToMoves(n, r), n } _addAfter(n, t, r) { return this._insertAfter(n, t, r), this._additionsTail = null === this._additionsTail ? this._additionsHead = n : this._additionsTail._nextAdded = n, n } _insertAfter(n, t, r) { const i = null === t ? this._itHead : t._next; return n._next = i, n._prev = t, null === i ? this._itTail = n : i._prev = n, null === t ? this._itHead = n : t._next = n, null === this._linkedRecords && (this._linkedRecords = new Y0), this._linkedRecords.put(n), n.currentIndex = r, n } _remove(n) { return this._addToRemovals(this._unlink(n)) } _unlink(n) { null !== this._linkedRecords && this._linkedRecords.remove(n); const t = n._prev, r = n._next; return null === t ? this._itHead = r : t._next = r, null === r ? this._itTail = t : r._prev = t, n } _addToMoves(n, t) { return n.previousIndex === t || (this._movesTail = null === this._movesTail ? this._movesHead = n : this._movesTail._nextMoved = n), n } _addToRemovals(n) { return null === this._unlinkedRecords && (this._unlinkedRecords = new Y0), this._unlinkedRecords.put(n), n.currentIndex = null, n._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = n, n._prevRemoved = null) : (n._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = n), n } _addIdentityChange(n, t) { return n.item = t, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = n : this._identityChangesTail._nextIdentityChange = n, n } } class GN { constructor(n, t) { this.item = n, this.trackById = t, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class qN { constructor() { this._head = null, this._tail = null } add(n) { null === this._head ? (this._head = this._tail = n, n._nextDup = null, n._prevDup = null) : (this._tail._nextDup = n, n._prevDup = this._tail, n._nextDup = null, this._tail = n) } get(n, t) { let r; for (r = this._head; null !== r; r = r._nextDup)if ((null === t || t <= r.currentIndex) && Object.is(r.trackById, n)) return r; return null } remove(n) { const t = n._prevDup, r = n._nextDup; return null === t ? this._head = r : t._nextDup = r, null === r ? this._tail = t : r._prevDup = t, null === this._head } } class Y0 { constructor() { this.map = new Map } put(n) { const t = n.trackById; let r = this.map.get(t); r || (r = new qN, this.map.set(t, r)), r.add(n) } get(n, t) { const i = this.map.get(n); return i ? i.get(n, t) : null } remove(n) { const t = n.trackById; return this.map.get(t).remove(n) && this.map.delete(t), n } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function Q0(e, n, t) { const r = e.previousIndex; if (null === r) return r; let i = 0; return t && r < t.length && (i = t[r]), r + n + i } class X0 { constructor() { } supports(n) { return n instanceof Map || af(n) } create() { return new WN } } class WN { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(n) { let t; for (t = this._mapHead; null !== t; t = t._next)n(t) } forEachPreviousItem(n) { let t; for (t = this._previousMapHead; null !== t; t = t._nextPrevious)n(t) } forEachChangedItem(n) { let t; for (t = this._changesHead; null !== t; t = t._nextChanged)n(t) } forEachAddedItem(n) { let t; for (t = this._additionsHead; null !== t; t = t._nextAdded)n(t) } forEachRemovedItem(n) { let t; for (t = this._removalsHead; null !== t; t = t._nextRemoved)n(t) } diff(n) { if (n) { if (!(n instanceof Map || af(n))) throw new x(900, !1) } else n = new Map; return this.check(n) ? this : null } onDestroy() { } check(n) { this._reset(); let t = this._mapHead; if (this._appendAfter = null, this._forEach(n, (r, i) => { if (t && t.key === i) this._maybeAddToChanges(t, r), this._appendAfter = t, t = t._next; else { const o = this._getOrCreateRecordForKey(i, r); t = this._insertBeforeOrAppend(t, o) } }), t) { t._prev && (t._prev._next = null), this._removalsHead = t; for (let r = t; null !== r; r = r._nextRemoved)r === this._mapHead && (this._mapHead = null), this._records.delete(r.key), r._nextRemoved = r._next, r.previousValue = r.currentValue, r.currentValue = null, r._prev = null, r._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(n, t) { if (n) { const r = n._prev; return t._next = n, t._prev = r, n._prev = t, r && (r._next = t), n === this._mapHead && (this._mapHead = t), this._appendAfter = n, n } return this._appendAfter ? (this._appendAfter._next = t, t._prev = this._appendAfter) : this._mapHead = t, this._appendAfter = t, null } _getOrCreateRecordForKey(n, t) { if (this._records.has(n)) { const i = this._records.get(n); this._maybeAddToChanges(i, t); const o = i._prev, s = i._next; return o && (o._next = s), s && (s._prev = o), i._next = null, i._prev = null, i } const r = new ZN(n); return this._records.set(n, r), r.currentValue = t, this._addToAdditions(r), r } _reset() { if (this.isDirty) { let n; for (this._previousMapHead = this._mapHead, n = this._previousMapHead; null !== n; n = n._next)n._nextPrevious = n._next; for (n = this._changesHead; null !== n; n = n._nextChanged)n.previousValue = n.currentValue; for (n = this._additionsHead; null != n; n = n._nextAdded)n.previousValue = n.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(n, t) { Object.is(t, n.currentValue) || (n.previousValue = n.currentValue, n.currentValue = t, this._addToChanges(n)) } _addToAdditions(n) { null === this._additionsHead ? this._additionsHead = this._additionsTail = n : (this._additionsTail._nextAdded = n, this._additionsTail = n) } _addToChanges(n) { null === this._changesHead ? this._changesHead = this._changesTail = n : (this._changesTail._nextChanged = n, this._changesTail = n) } _forEach(n, t) { n instanceof Map ? n.forEach(t) : Object.keys(n).forEach(r => t(n[r], r)) } } class ZN { constructor(n) { this.key = n, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } function J0() { return new Hl([new K0]) } let Hl = (() => { class e { static { this.\u0275prov = F({ token: e, providedIn: "root", factory: J0 }) } constructor(t) { this.factories = t } static create(t, r) { if (null != r) { const i = r.factories.slice(); t = t.concat(i) } return new e(t) } static extend(t) { return { provide: e, useFactory: r => e.create(t, r || J0()), deps: [[e, new Ba, new Va]] } } find(t) { const r = this.factories.find(i => i.supports(t)); if (null != r) return r; throw new x(901, !1) } } return e })(); function eD() { return new Ds([new X0]) } let Ds = (() => { class e { static { this.\u0275prov = F({ token: e, providedIn: "root", factory: eD }) } constructor(t) { this.factories = t } static create(t, r) { if (r) { const i = r.factories.slice(); t = t.concat(i) } return new e(t) } static extend(t) { return { provide: e, useFactory: r => e.create(t, r || eD()), deps: [[e, new Ba, new Va]] } } find(t) { const r = this.factories.find(i => i.supports(t)); if (r) return r; throw new x(901, !1) } } return e })(); const QN = F0(null, "core", []); let XN = (() => { class e { constructor(t) { } static { this.\u0275fac = function (r) { return new (r || e)(k(Ki)) } } static { this.\u0275mod = bt({ type: e }) } static { this.\u0275inj = ct({}) } } return e })(); function Yi(e) { return "boolean" == typeof e ? e : null != e && "false" !== e } let rh = null; function cr() { return rh } class fO { } const We = new A("DocumentToken"); let ih = (() => { class e { historyGo(t) { throw new Error("Not implemented") } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = F({ token: e, factory: function () { return O(pO) }, providedIn: "platform" }) } } return e })(); const hO = new A("Location Initialized"); let pO = (() => { class e extends ih { constructor() { super(), this._doc = O(We), this._location = window.location, this._history = window.history } getBaseHrefFromDOM() { return cr().getBaseHref(this._doc) } onPopState(t) { const r = cr().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("popstate", t, !1), () => r.removeEventListener("popstate", t) } onHashChange(t) { const r = cr().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("hashchange", t, !1), () => r.removeEventListener("hashchange", t) } get href() { return this._location.href } get protocol() { return this._location.protocol } get hostname() { return this._location.hostname } get port() { return this._location.port } get pathname() { return this._location.pathname } get search() { return this._location.search } get hash() { return this._location.hash } set pathname(t) { this._location.pathname = t } pushState(t, r, i) { this._history.pushState(t, r, i) } replaceState(t, r, i) { this._history.replaceState(t, r, i) } forward() { this._history.forward() } back() { this._history.back() } historyGo(t = 0) { this._history.go(t) } getState() { return this._history.state } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = F({ token: e, factory: function () { return new e }, providedIn: "platform" }) } } return e })(); function oh(e, n) { if (0 == e.length) return n; if (0 == n.length) return e; let t = 0; return e.endsWith("/") && t++, n.startsWith("/") && t++, 2 == t ? e + n.substring(1) : 1 == t ? e + n : e + "/" + n } function cD(e) { const n = e.match(/#|\?|$/), t = n && n.index || e.length; return e.slice(0, t - ("/" === e[t - 1] ? 1 : 0)) + e.slice(t) } function $n(e) { return e && "?" !== e[0] ? "?" + e : e } let Or = (() => { class e { historyGo(t) { throw new Error("Not implemented") } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = F({ token: e, factory: function () { return O(dD) }, providedIn: "root" }) } } return e })(); const uD = new A("appBaseHref"); let dD = (() => { class e extends Or { constructor(t, r) { super(), this._platformLocation = t, this._removeListenerFns = [], this._baseHref = r ?? this._platformLocation.getBaseHrefFromDOM() ?? O(We).location?.origin ?? "" } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(t) { this._removeListenerFns.push(this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t)) } getBaseHref() { return this._baseHref } prepareExternalUrl(t) { return oh(this._baseHref, t) } path(t = !1) { const r = this._platformLocation.pathname + $n(this._platformLocation.search), i = this._platformLocation.hash; return i && t ? `${r}${i}` : r } pushState(t, r, i, o) { const s = this.prepareExternalUrl(i + $n(o)); this._platformLocation.pushState(t, r, s) } replaceState(t, r, i, o) { const s = this.prepareExternalUrl(i + $n(o)); this._platformLocation.replaceState(t, r, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(t = 0) { this._platformLocation.historyGo?.(t) } static { this.\u0275fac = function (r) { return new (r || e)(k(ih), k(uD, 8)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(), gO = (() => { class e extends Or { constructor(t, r) { super(), this._platformLocation = t, this._baseHref = "", this._removeListenerFns = [], null != r && (this._baseHref = r) } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(t) { this._removeListenerFns.push(this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t)) } getBaseHref() { return this._baseHref } path(t = !1) { let r = this._platformLocation.hash; return null == r && (r = "#"), r.length > 0 ? r.substring(1) : r } prepareExternalUrl(t) { const r = oh(this._baseHref, t); return r.length > 0 ? "#" + r : r } pushState(t, r, i, o) { let s = this.prepareExternalUrl(i + $n(o)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.pushState(t, r, s) } replaceState(t, r, i, o) { let s = this.prepareExternalUrl(i + $n(o)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.replaceState(t, r, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(t = 0) { this._platformLocation.historyGo?.(t) } static { this.\u0275fac = function (r) { return new (r || e)(k(ih), k(uD, 8)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac }) } } return e })(), zl = (() => { class e { constructor(t) { this._subject = new se, this._urlChangeListeners = [], this._urlChangeSubscription = null, this._locationStrategy = t; const r = this._locationStrategy.getBaseHref(); this._basePath = function vO(e) { if (new RegExp("^(https?:)?//").test(e)) { const [, t] = e.split(/\/\/[^\/]+/); return t } return e }(cD(fD(r))), this._locationStrategy.onPopState(i => { this._subject.emit({ url: this.path(!0), pop: !0, state: i.state, type: i.type }) }) } ngOnDestroy() { this._urlChangeSubscription?.unsubscribe(), this._urlChangeListeners = [] } path(t = !1) { return this.normalize(this._locationStrategy.path(t)) } getState() { return this._locationStrategy.getState() } isCurrentPathEqualTo(t, r = "") { return this.path() == this.normalize(t + $n(r)) } normalize(t) { return e.stripTrailingSlash(function _O(e, n) { if (!e || !n.startsWith(e)) return n; const t = n.substring(e.length); return "" === t || ["/", ";", "?", "#"].includes(t[0]) ? t : n }(this._basePath, fD(t))) } prepareExternalUrl(t) { return t && "/" !== t[0] && (t = "/" + t), this._locationStrategy.prepareExternalUrl(t) } go(t, r = "", i = null) { this._locationStrategy.pushState(i, "", t, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + $n(r)), i) } replaceState(t, r = "", i = null) { this._locationStrategy.replaceState(i, "", t, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + $n(r)), i) } forward() { this._locationStrategy.forward() } back() { this._locationStrategy.back() } historyGo(t = 0) { this._locationStrategy.historyGo?.(t) } onUrlChange(t) { return this._urlChangeListeners.push(t), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(r => { this._notifyUrlChangeListeners(r.url, r.state) })), () => { const r = this._urlChangeListeners.indexOf(t); this._urlChangeListeners.splice(r, 1), 0 === this._urlChangeListeners.length && (this._urlChangeSubscription?.unsubscribe(), this._urlChangeSubscription = null) } } _notifyUrlChangeListeners(t = "", r) { this._urlChangeListeners.forEach(i => i(t, r)) } subscribe(t, r, i) { return this._subject.subscribe({ next: t, error: r, complete: i }) } static { this.normalizeQueryParams = $n } static { this.joinWithSlash = oh } static { this.stripTrailingSlash = cD } static { this.\u0275fac = function (r) { return new (r || e)(k(Or)) } } static { this.\u0275prov = F({ token: e, factory: function () { return function mO() { return new zl(k(Or)) }() }, providedIn: "root" }) } } return e })(); function fD(e) { return e.replace(/\/index.html$/, "") } var _t = function (e) { return e[e.Format = 0] = "Format", e[e.Standalone = 1] = "Standalone", e }(_t || {}), ye = function (e) { return e[e.Narrow = 0] = "Narrow", e[e.Abbreviated = 1] = "Abbreviated", e[e.Wide = 2] = "Wide", e[e.Short = 3] = "Short", e }(ye || {}), Lt = function (e) { return e[e.Short = 0] = "Short", e[e.Medium = 1] = "Medium", e[e.Long = 2] = "Long", e[e.Full = 3] = "Full", e }(Lt || {}), je = function (e) { return e[e.Decimal = 0] = "Decimal", e[e.Group = 1] = "Group", e[e.List = 2] = "List", e[e.PercentSign = 3] = "PercentSign", e[e.PlusSign = 4] = "PlusSign", e[e.MinusSign = 5] = "MinusSign", e[e.Exponential = 6] = "Exponential", e[e.SuperscriptingExponent = 7] = "SuperscriptingExponent", e[e.PerMille = 8] = "PerMille", e[e.Infinity = 9] = "Infinity", e[e.NaN = 10] = "NaN", e[e.TimeSeparator = 11] = "TimeSeparator", e[e.CurrencyDecimal = 12] = "CurrencyDecimal", e[e.CurrencyGroup = 13] = "CurrencyGroup", e }(je || {}); function ql(e, n) { return Kt(gt(e)[Ie.DateFormat], n) } function Wl(e, n) { return Kt(gt(e)[Ie.TimeFormat], n) } function Zl(e, n) { return Kt(gt(e)[Ie.DateTimeFormat], n) } function Zt(e, n) { const t = gt(e), r = t[Ie.NumberSymbols][n]; if (typeof r > "u") { if (n === je.CurrencyDecimal) return t[Ie.NumberSymbols][je.Decimal]; if (n === je.CurrencyGroup) return t[Ie.NumberSymbols][je.Group] } return r } function pD(e) { if (!e[Ie.ExtraData]) throw new Error(`Missing extra locale data for the locale "${e[Ie.LocaleId]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`) } function Kt(e, n) { for (let t = n; t > -1; t--)if (typeof e[t] < "u") return e[t]; throw new Error("Locale data API: locale data undefined") } function ah(e) { const [n, t] = e.split(":"); return { hours: +n, minutes: +t } } const RO = /^(\d{4,})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/, Cs = {}, PO = /((?:[^BEGHLMOSWYZabcdhmswyz']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|Y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|c{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/; var zn = function (e) { return e[e.Short = 0] = "Short", e[e.ShortGMT = 1] = "ShortGMT", e[e.Long = 2] = "Long", e[e.Extended = 3] = "Extended", e }(zn || {}), ce = function (e) { return e[e.FullYear = 0] = "FullYear", e[e.Month = 1] = "Month", e[e.Date = 2] = "Date", e[e.Hours = 3] = "Hours", e[e.Minutes = 4] = "Minutes", e[e.Seconds = 5] = "Seconds", e[e.FractionalSeconds = 6] = "FractionalSeconds", e[e.Day = 7] = "Day", e }(ce || {}), ue = function (e) { return e[e.DayPeriods = 0] = "DayPeriods", e[e.Days = 1] = "Days", e[e.Months = 2] = "Months", e[e.Eras = 3] = "Eras", e }(ue || {}); function NO(e, n, t, r) { let i = function $O(e) { if (_D(e)) return e; if ("number" == typeof e && !isNaN(e)) return new Date(e); if ("string" == typeof e) { if (e = e.trim(), /^(\d{4}(-\d{1,2}(-\d{1,2})?)?)$/.test(e)) { const [i, o = 1, s = 1] = e.split("-").map(a => +a); return Kl(i, o - 1, s) } const t = parseFloat(e); if (!isNaN(e - t)) return new Date(t); let r; if (r = e.match(RO)) return function zO(e) { const n = new Date(0); let t = 0, r = 0; const i = e[8] ? n.setUTCFullYear : n.setFullYear, o = e[8] ? n.setUTCHours : n.setHours; e[9] && (t = Number(e[9] + e[10]), r = Number(e[9] + e[11])), i.call(n, Number(e[1]), Number(e[2]) - 1, Number(e[3])); const s = Number(e[4] || 0) - t, a = Number(e[5] || 0) - r, l = Number(e[6] || 0), c = Math.floor(1e3 * parseFloat("0." + (e[7] || 0))); return o.call(n, s, a, l, c), n }(r) } const n = new Date(e); if (!_D(n)) throw new Error(`Unable to convert "${e}" into a date`); return n }(e); n = Gn(t, n) || n; let a, s = []; for (; n;) { if (a = PO.exec(n), !a) { s.push(n); break } { s = s.concat(a.slice(1)); const u = s.pop(); if (!u) break; n = u } } let l = i.getTimezoneOffset(); r && (l = mD(r, l), i = function HO(e, n, t) { const r = t ? -1 : 1, i = e.getTimezoneOffset(); return function UO(e, n) { return (e = new Date(e.getTime())).setMinutes(e.getMinutes() + n), e }(e, r * (mD(n, i) - i)) }(i, r, !0)); let c = ""; return s.forEach(u => { const d = function BO(e) { if (ch[e]) return ch[e]; let n; switch (e) { case "G": case "GG": case "GGG": n = Se(ue.Eras, ye.Abbreviated); break; case "GGGG": n = Se(ue.Eras, ye.Wide); break; case "GGGGG": n = Se(ue.Eras, ye.Narrow); break; case "y": n = Be(ce.FullYear, 1, 0, !1, !0); break; case "yy": n = Be(ce.FullYear, 2, 0, !0, !0); break; case "yyy": n = Be(ce.FullYear, 3, 0, !1, !0); break; case "yyyy": n = Be(ce.FullYear, 4, 0, !1, !0); break; case "Y": n = Jl(1); break; case "YY": n = Jl(2, !0); break; case "YYY": n = Jl(3); break; case "YYYY": n = Jl(4); break; case "M": case "L": n = Be(ce.Month, 1, 1); break; case "MM": case "LL": n = Be(ce.Month, 2, 1); break; case "MMM": n = Se(ue.Months, ye.Abbreviated); break; case "MMMM": n = Se(ue.Months, ye.Wide); break; case "MMMMM": n = Se(ue.Months, ye.Narrow); break; case "LLL": n = Se(ue.Months, ye.Abbreviated, _t.Standalone); break; case "LLLL": n = Se(ue.Months, ye.Wide, _t.Standalone); break; case "LLLLL": n = Se(ue.Months, ye.Narrow, _t.Standalone); break; case "w": n = lh(1); break; case "ww": n = lh(2); break; case "W": n = lh(1, !0); break; case "d": n = Be(ce.Date, 1); break; case "dd": n = Be(ce.Date, 2); break; case "c": case "cc": n = Be(ce.Day, 1); break; case "ccc": n = Se(ue.Days, ye.Abbreviated, _t.Standalone); break; case "cccc": n = Se(ue.Days, ye.Wide, _t.Standalone); break; case "ccccc": n = Se(ue.Days, ye.Narrow, _t.Standalone); break; case "cccccc": n = Se(ue.Days, ye.Short, _t.Standalone); break; case "E": case "EE": case "EEE": n = Se(ue.Days, ye.Abbreviated); break; case "EEEE": n = Se(ue.Days, ye.Wide); break; case "EEEEE": n = Se(ue.Days, ye.Narrow); break; case "EEEEEE": n = Se(ue.Days, ye.Short); break; case "a": case "aa": case "aaa": n = Se(ue.DayPeriods, ye.Abbreviated); break; case "aaaa": n = Se(ue.DayPeriods, ye.Wide); break; case "aaaaa": n = Se(ue.DayPeriods, ye.Narrow); break; case "b": case "bb": case "bbb": n = Se(ue.DayPeriods, ye.Abbreviated, _t.Standalone, !0); break; case "bbbb": n = Se(ue.DayPeriods, ye.Wide, _t.Standalone, !0); break; case "bbbbb": n = Se(ue.DayPeriods, ye.Narrow, _t.Standalone, !0); break; case "B": case "BB": case "BBB": n = Se(ue.DayPeriods, ye.Abbreviated, _t.Format, !0); break; case "BBBB": n = Se(ue.DayPeriods, ye.Wide, _t.Format, !0); break; case "BBBBB": n = Se(ue.DayPeriods, ye.Narrow, _t.Format, !0); break; case "h": n = Be(ce.Hours, 1, -12); break; case "hh": n = Be(ce.Hours, 2, -12); break; case "H": n = Be(ce.Hours, 1); break; case "HH": n = Be(ce.Hours, 2); break; case "m": n = Be(ce.Minutes, 1); break; case "mm": n = Be(ce.Minutes, 2); break; case "s": n = Be(ce.Seconds, 1); break; case "ss": n = Be(ce.Seconds, 2); break; case "S": n = Be(ce.FractionalSeconds, 1); break; case "SS": n = Be(ce.FractionalSeconds, 2); break; case "SSS": n = Be(ce.FractionalSeconds, 3); break; case "Z": case "ZZ": case "ZZZ": n = Ql(zn.Short); break; case "ZZZZZ": n = Ql(zn.Extended); break; case "O": case "OO": case "OOO": case "z": case "zz": case "zzz": n = Ql(zn.ShortGMT); break; case "OOOO": case "ZZZZ": case "zzzz": n = Ql(zn.Long); break; default: return null }return ch[e] = n, n }(u); c += d ? d(i, t, l) : "''" === u ? "'" : u.replace(/(^'|'$)/g, "").replace(/''/g, "'") }), c } function Kl(e, n, t) { const r = new Date(0); return r.setFullYear(e, n, t), r.setHours(0, 0, 0), r } function Gn(e, n) { const t = function bO(e) { return gt(e)[Ie.LocaleId] }(e); if (Cs[t] = Cs[t] || {}, Cs[t][n]) return Cs[t][n]; let r = ""; switch (n) { case "shortDate": r = ql(e, Lt.Short); break; case "mediumDate": r = ql(e, Lt.Medium); break; case "longDate": r = ql(e, Lt.Long); break; case "fullDate": r = ql(e, Lt.Full); break; case "shortTime": r = Wl(e, Lt.Short); break; case "mediumTime": r = Wl(e, Lt.Medium); break; case "longTime": r = Wl(e, Lt.Long); break; case "fullTime": r = Wl(e, Lt.Full); break; case "short": const i = Gn(e, "shortTime"), o = Gn(e, "shortDate"); r = Yl(Zl(e, Lt.Short), [i, o]); break; case "medium": const s = Gn(e, "mediumTime"), a = Gn(e, "mediumDate"); r = Yl(Zl(e, Lt.Medium), [s, a]); break; case "long": const l = Gn(e, "longTime"), c = Gn(e, "longDate"); r = Yl(Zl(e, Lt.Long), [l, c]); break; case "full": const u = Gn(e, "fullTime"), d = Gn(e, "fullDate"); r = Yl(Zl(e, Lt.Full), [u, d]) }return r && (Cs[t][n] = r), r } function Yl(e, n) { return n && (e = e.replace(/\{([^}]+)}/g, function (t, r) { return null != n && r in n ? n[r] : t })), e } function on(e, n, t = "-", r, i) { let o = ""; (e < 0 || i && e <= 0) && (i ? e = 1 - e : (e = -e, o = t)); let s = String(e); for (; s.length < n;)s = "0" + s; return r && (s = s.slice(s.length - n)), o + s } function Be(e, n, t = 0, r = !1, i = !1) { return function (o, s) { let a = function FO(e, n) { switch (e) { case ce.FullYear: return n.getFullYear(); case ce.Month: return n.getMonth(); case ce.Date: return n.getDate(); case ce.Hours: return n.getHours(); case ce.Minutes: return n.getMinutes(); case ce.Seconds: return n.getSeconds(); case ce.FractionalSeconds: return n.getMilliseconds(); case ce.Day: return n.getDay(); default: throw new Error(`Unknown DateType value "${e}".`) } }(e, o); if ((t > 0 || a > -t) && (a += t), e === ce.Hours) 0 === a && -12 === t && (a = 12); else if (e === ce.FractionalSeconds) return function OO(e, n) { return on(e, 3).substring(0, n) }(a, n); const l = Zt(s, je.MinusSign); return on(a, n, l, r, i) } } function Se(e, n, t = _t.Format, r = !1) { return function (i, o) { return function LO(e, n, t, r, i, o) { switch (t) { case ue.Months: return function wO(e, n, t) { const r = gt(e), o = Kt([r[Ie.MonthsFormat], r[Ie.MonthsStandalone]], n); return Kt(o, t) }(n, i, r)[e.getMonth()]; case ue.Days: return function CO(e, n, t) { const r = gt(e), o = Kt([r[Ie.DaysFormat], r[Ie.DaysStandalone]], n); return Kt(o, t) }(n, i, r)[e.getDay()]; case ue.DayPeriods: const s = e.getHours(), a = e.getMinutes(); if (o) { const c = function TO(e) { const n = gt(e); return pD(n), (n[Ie.ExtraData][2] || []).map(r => "string" == typeof r ? ah(r) : [ah(r[0]), ah(r[1])]) }(n), u = function xO(e, n, t) { const r = gt(e); pD(r); const o = Kt([r[Ie.ExtraData][0], r[Ie.ExtraData][1]], n) || []; return Kt(o, t) || [] }(n, i, r), d = c.findIndex(p => { if (Array.isArray(p)) { const [m, v] = p, y = s >= m.hours && a >= m.minutes, C = s < v.hours || s === v.hours && a < v.minutes; if (m.hours < v.hours) { if (y && C) return !0 } else if (y || C) return !0 } else if (p.hours === s && p.minutes === a) return !0; return !1 }); if (-1 !== d) return u[d] } return function DO(e, n, t) { const r = gt(e), o = Kt([r[Ie.DayPeriodsFormat], r[Ie.DayPeriodsStandalone]], n); return Kt(o, t) }(n, i, r)[s < 12 ? 0 : 1]; case ue.Eras: return function EO(e, n) { return Kt(gt(e)[Ie.Eras], n) }(n, r)[e.getFullYear() <= 0 ? 0 : 1]; default: throw new Error(`unexpected translation type ${t}`) } }(i, o, e, n, t, r) } } function Ql(e) { return function (n, t, r) { const i = -1 * r, o = Zt(t, je.MinusSign), s = i > 0 ? Math.floor(i / 60) : Math.ceil(i / 60); switch (e) { case zn.Short: return (i >= 0 ? "+" : "") + on(s, 2, o) + on(Math.abs(i % 60), 2, o); case zn.ShortGMT: return "GMT" + (i >= 0 ? "+" : "") + on(s, 1, o); case zn.Long: return "GMT" + (i >= 0 ? "+" : "") + on(s, 2, o) + ":" + on(Math.abs(i % 60), 2, o); case zn.Extended: return 0 === r ? "Z" : (i >= 0 ? "+" : "") + on(s, 2, o) + ":" + on(Math.abs(i % 60), 2, o); default: throw new Error(`Unknown zone width "${e}"`) } } } const jO = 0, Xl = 4; function gD(e) { return Kl(e.getFullYear(), e.getMonth(), e.getDate() + (Xl - e.getDay())) } function lh(e, n = !1) { return function (t, r) { let i; if (n) { const o = new Date(t.getFullYear(), t.getMonth(), 1).getDay() - 1, s = t.getDate(); i = 1 + Math.floor((s + o) / 7) } else { const o = gD(t), s = function VO(e) { const n = Kl(e, jO, 1).getDay(); return Kl(e, 0, 1 + (n <= Xl ? Xl : Xl + 7) - n) }(o.getFullYear()), a = o.getTime() - s.getTime(); i = 1 + Math.round(a / 6048e5) } return on(i, e, Zt(r, je.MinusSign)) } } function Jl(e, n = !1) { return function (t, r) { return on(gD(t).getFullYear(), e, Zt(r, je.MinusSign), n) } } const ch = {}; function mD(e, n) { e = e.replace(/:/g, ""); const t = Date.parse("Jan 01, 1970 00:00:00 " + e) / 6e4; return isNaN(t) ? n : t } function _D(e) { return e instanceof Date && !isNaN(e.valueOf()) } function DD(e, n) { n = encodeURIComponent(n); for (const t of e.split(";")) { const r = t.indexOf("="), [i, o] = -1 == r ? [t, ""] : [t.slice(0, r), t.slice(r + 1)]; if (i.trim() === n) return decodeURIComponent(o) } return null } const gh = /\s+/, CD = []; let Xi = (() => { class e { constructor(t, r, i, o) { this._iterableDiffers = t, this._keyValueDiffers = r, this._ngEl = i, this._renderer = o, this.initialClasses = CD, this.stateMap = new Map } set klass(t) { this.initialClasses = null != t ? t.trim().split(gh) : CD } set ngClass(t) { this.rawClass = "string" == typeof t ? t.trim().split(gh) : t } ngDoCheck() { for (const r of this.initialClasses) this._updateState(r, !0); const t = this.rawClass; if (Array.isArray(t) || t instanceof Set) for (const r of t) this._updateState(r, !0); else if (null != t) for (const r of Object.keys(t)) this._updateState(r, !!t[r]); this._applyStateDiff() } _updateState(t, r) { const i = this.stateMap.get(t); void 0 !== i ? (i.enabled !== r && (i.changed = !0, i.enabled = r), i.touched = !0) : this.stateMap.set(t, { enabled: r, changed: !0, touched: !0 }) } _applyStateDiff() { for (const t of this.stateMap) { const r = t[0], i = t[1]; i.changed ? (this._toggleClass(r, i.enabled), i.changed = !1) : i.touched || (i.enabled && this._toggleClass(r, !1), this.stateMap.delete(r)), i.touched = !1 } } _toggleClass(t, r) { (t = t.trim()).length > 0 && t.split(gh).forEach(i => { r ? this._renderer.addClass(this._ngEl.nativeElement, i) : this._renderer.removeClass(this._ngEl.nativeElement, i) }) } static { this.\u0275fac = function (r) { return new (r || e)(D(Hl), D(Ds), D(tt), D(Ln)) } } static { this.\u0275dir = j({ type: e, selectors: [["", "ngClass", ""]], inputs: { klass: ["class", "klass"], ngClass: "ngClass" }, standalone: !0 }) } } return e })(); class r2 { constructor(n, t, r, i) { this.$implicit = n, this.ngForOf = t, this.index = r, this.count = i } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let Fr = (() => { class e { set ngForOf(t) { this._ngForOf = t, this._ngForOfDirty = !0 } set ngForTrackBy(t) { this._trackByFn = t } get ngForTrackBy() { return this._trackByFn } constructor(t, r, i) { this._viewContainer = t, this._template = r, this._differs = i, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForTemplate(t) { t && (this._template = t) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const t = this._ngForOf; !this._differ && t && (this._differ = this._differs.find(t).create(this.ngForTrackBy)) } if (this._differ) { const t = this._differ.diff(this._ngForOf); t && this._applyChanges(t) } } _applyChanges(t) { const r = this._viewContainer; t.forEachOperation((i, o, s) => { if (null == i.previousIndex) r.createEmbeddedView(this._template, new r2(i.item, this._ngForOf, -1, -1), null === s ? void 0 : s); else if (null == s) r.remove(null === o ? void 0 : o); else if (null !== o) { const a = r.get(o); r.move(a, s), ED(a, i) } }); for (let i = 0, o = r.length; i < o; i++) { const a = r.get(i).context; a.index = i, a.count = o, a.ngForOf = this._ngForOf } t.forEachIdentityChange(i => { ED(r.get(i.currentIndex), i) }) } static ngTemplateContextGuard(t, r) { return !0 } static { this.\u0275fac = function (r) { return new (r || e)(D(Wt), D(rn), D(Hl)) } } static { this.\u0275dir = j({ type: e, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" }, standalone: !0 }) } } return e })(); function ED(e, n) { e.context.$implicit = n.item } let Dn = (() => { class e { constructor(t, r) { this._viewContainer = t, this._context = new o2, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = r } set ngIf(t) { this._context.$implicit = this._context.ngIf = t, this._updateView() } set ngIfThen(t) { ID("ngIfThen", t), this._thenTemplateRef = t, this._thenViewRef = null, this._updateView() } set ngIfElse(t) { ID("ngIfElse", t), this._elseTemplateRef = t, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(t, r) { return !0 } static { this.\u0275fac = function (r) { return new (r || e)(D(Wt), D(rn)) } } static { this.\u0275dir = j({ type: e, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" }, standalone: !0 }) } } return e })(); class o2 { constructor() { this.$implicit = null, this.ngIf = null } } function ID(e, n) { if (n && !n.createEmbeddedView) throw new Error(`${e} must be a TemplateRef, but received '${$e(n)}'.`) } function sn(e, n) { return new x(2100, !1) } class l2 { createSubscription(n, t) { return rm(() => n.subscribe({ next: t, error: r => { throw r } })) } dispose(n) { rm(() => n.unsubscribe()) } } class c2 { createSubscription(n, t) { return n.then(t, r => { throw r }) } dispose(n) { } } const u2 = new c2, d2 = new l2; let vh = (() => { class e { constructor(t) { this._latestValue = null, this._subscription = null, this._obj = null, this._strategy = null, this._ref = t } ngOnDestroy() { this._subscription && this._dispose(), this._ref = null } transform(t) { return this._obj ? t !== this._obj ? (this._dispose(), this.transform(t)) : this._latestValue : (t && this._subscribe(t), this._latestValue) } _subscribe(t) { this._obj = t, this._strategy = this._selectStrategy(t), this._subscription = this._strategy.createSubscription(t, r => this._updateLatestValue(t, r)) } _selectStrategy(t) { if (os(t)) return u2; if (gy(t)) return d2; throw sn() } _dispose() { this._strategy.dispose(this._subscription), this._latestValue = null, this._subscription = null, this._obj = null } _updateLatestValue(t, r) { t === this._obj && (this._latestValue = r, this._ref.markForCheck()) } static { this.\u0275fac = function (r) { return new (r || e)(D(Pr, 16)) } } static { this.\u0275pipe = Dt({ name: "async", type: e, pure: !1, standalone: !0 }) } } return e })(); const _2 = new A("DATE_PIPE_DEFAULT_TIMEZONE"), v2 = new A("DATE_PIPE_DEFAULT_OPTIONS"); let yh = (() => { class e { constructor(t, r, i) { this.locale = t, this.defaultTimezone = r, this.defaultOptions = i } transform(t, r, i, o) { if (null == t || "" === t || t != t) return null; try { return NO(t, r ?? this.defaultOptions?.dateFormat ?? "mediumDate", o || this.locale, i ?? this.defaultOptions?.timezone ?? this.defaultTimezone ?? void 0) } catch (s) { throw sn() } } static { this.\u0275fac = function (r) { return new (r || e)(D(Hn, 16), D(_2, 24), D(v2, 24)) } } static { this.\u0275pipe = Dt({ name: "date", type: e, pure: !0, standalone: !0 }) } } return e })(), tc = (() => { class e { transform(t, r, i) { if (null == t) return null; if (!this.supports(t)) throw sn(); return t.slice(r, i) } supports(t) { return "string" == typeof t || Array.isArray(t) } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275pipe = Dt({ name: "slice", type: e, pure: !1, standalone: !0 }) } } return e })(), x2 = (() => { class e { static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275mod = bt({ type: e }) } static { this.\u0275inj = ct({}) } } return e })(); const xD = "browser"; function MD(e) { return "server" === e } let P2 = (() => { class e { static { this.\u0275prov = F({ token: e, providedIn: "root", factory: () => new N2(k(We), window) }) } } return e })(); class N2 { constructor(n, t) { this.document = n, this.window = t, this.offset = () => [0, 0] } setOffset(n) { this.offset = Array.isArray(n) ? () => n : n } getScrollPosition() { return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0] } scrollToPosition(n) { this.supportsScrolling() && this.window.scrollTo(n[0], n[1]) } scrollToAnchor(n) { if (!this.supportsScrolling()) return; const t = function O2(e, n) { const t = e.getElementById(n) || e.getElementsByName(n)[0]; if (t) return t; if ("function" == typeof e.createTreeWalker && e.body && "function" == typeof e.body.attachShadow) { const r = e.createTreeWalker(e.body, NodeFilter.SHOW_ELEMENT); let i = r.currentNode; for (; i;) { const o = i.shadowRoot; if (o) { const s = o.getElementById(n) || o.querySelector(`[name="${n}"]`); if (s) return s } i = r.nextNode() } } return null }(this.document, n); t && (this.scrollToElement(t), t.focus()) } setHistoryScrollRestoration(n) { this.supportsScrolling() && (this.window.history.scrollRestoration = n) } scrollToElement(n) { const t = n.getBoundingClientRect(), r = t.left + this.window.pageXOffset, i = t.top + this.window.pageYOffset, o = this.offset(); this.window.scrollTo(r - o[0], i - o[1]) } supportsScrolling() { try { return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window } catch { return !1 } } } class AD { } class iF extends fO { constructor() { super(...arguments), this.supportsDOMEvents = !0 } } class Eh extends iF { static makeCurrent() { !function dO(e) { rh || (rh = e) }(new Eh) } onAndCancel(n, t, r) { return n.addEventListener(t, r), () => { n.removeEventListener(t, r) } } dispatchEvent(n, t) { n.dispatchEvent(t) } remove(n) { n.parentNode && n.parentNode.removeChild(n) } createElement(n, t) { return (t = t || this.getDefaultDocument()).createElement(n) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(n) { return n.nodeType === Node.ELEMENT_NODE } isShadowRoot(n) { return n instanceof DocumentFragment } getGlobalEventTarget(n, t) { return "window" === t ? window : "document" === t ? n : "body" === t ? n.body : null } getBaseHref(n) { const t = function oF() { return Is = Is || document.querySelector("base"), Is ? Is.getAttribute("href") : null }(); return null == t ? null : function sF(e) { ic = ic || document.createElement("a"), ic.setAttribute("href", e); const n = ic.pathname; return "/" === n.charAt(0) ? n : `/${n}` }(t) } resetBaseElement() { Is = null } getUserAgent() { return window.navigator.userAgent } getCookie(n) { return DD(document.cookie, n) } } let ic, Is = null, lF = (() => { class e { build() { return new XMLHttpRequest } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac }) } } return e })(); const Ih = new A("EventManagerPlugins"); let OD = (() => { class e { constructor(t, r) { this._zone = r, this._eventNameToPlugin = new Map, t.forEach(i => { i.manager = this }), this._plugins = t.slice().reverse() } addEventListener(t, r, i) { return this._findPluginFor(r).addEventListener(t, r, i) } getZone() { return this._zone } _findPluginFor(t) { let r = this._eventNameToPlugin.get(t); if (r) return r; if (r = this._plugins.find(o => o.supports(t)), !r) throw new x(5101, !1); return this._eventNameToPlugin.set(t, r), r } static { this.\u0275fac = function (r) { return new (r || e)(k(Ih), k(le)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac }) } } return e })(); class FD { constructor(n) { this._doc = n } } const Sh = "ng-app-id"; let LD = (() => { class e { constructor(t, r, i, o = {}) { this.doc = t, this.appId = r, this.nonce = i, this.platformId = o, this.styleRef = new Map, this.hostNodes = new Set, this.styleNodesInDOM = this.collectServerRenderedStyles(), this.platformIsServer = MD(o), this.resetHostNodes() } addStyles(t) { for (const r of t) 1 === this.changeUsageCount(r, 1) && this.onStyleAdded(r) } removeStyles(t) { for (const r of t) this.changeUsageCount(r, -1) <= 0 && this.onStyleRemoved(r) } ngOnDestroy() { const t = this.styleNodesInDOM; t && (t.forEach(r => r.remove()), t.clear()); for (const r of this.getAllStyles()) this.onStyleRemoved(r); this.resetHostNodes() } addHost(t) { this.hostNodes.add(t); for (const r of this.getAllStyles()) this.addStyleToHost(t, r) } removeHost(t) { this.hostNodes.delete(t) } getAllStyles() { return this.styleRef.keys() } onStyleAdded(t) { for (const r of this.hostNodes) this.addStyleToHost(r, t) } onStyleRemoved(t) { const r = this.styleRef; r.get(t)?.elements?.forEach(i => i.remove()), r.delete(t) } collectServerRenderedStyles() { const t = this.doc.head?.querySelectorAll(`style[${Sh}="${this.appId}"]`); if (t?.length) { const r = new Map; return t.forEach(i => { null != i.textContent && r.set(i.textContent, i) }), r } return null } changeUsageCount(t, r) { const i = this.styleRef; if (i.has(t)) { const o = i.get(t); return o.usage += r, o.usage } return i.set(t, { usage: r, elements: [] }), r } getStyleElement(t, r) { const i = this.styleNodesInDOM, o = i?.get(r); if (o?.parentNode === t) return i.delete(r), o.removeAttribute(Sh), o; { const s = this.doc.createElement("style"); return this.nonce && s.setAttribute("nonce", this.nonce), s.textContent = r, this.platformIsServer && s.setAttribute(Sh, this.appId), s } } addStyleToHost(t, r) { const i = this.getStyleElement(t, r); t.appendChild(i); const o = this.styleRef, s = o.get(r)?.elements; s ? s.push(i) : o.set(r, { elements: [i], usage: 1 }) } resetHostNodes() { const t = this.hostNodes; t.clear(), t.add(this.doc.head) } static { this.\u0275fac = function (r) { return new (r || e)(k(We), k(ol), k(W_, 8), k(sr)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac }) } } return e })(); const Th = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/MathML/" }, xh = /%COMP%/g, fF = new A("RemoveStylesOnCompDestroy", { providedIn: "root", factory: () => !1 }); function VD(e, n) { return n.map(t => t.replace(xh, e)) } let BD = (() => { class e { constructor(t, r, i, o, s, a, l, c = null) { this.eventManager = t, this.sharedStylesHost = r, this.appId = i, this.removeStylesOnCompDestroy = o, this.doc = s, this.platformId = a, this.ngZone = l, this.nonce = c, this.rendererByCompId = new Map, this.platformIsServer = MD(a), this.defaultRenderer = new Mh(t, s, l, this.platformIsServer) } createRenderer(t, r) { if (!t || !r) return this.defaultRenderer; this.platformIsServer && r.encapsulation === Qt.ShadowDom && (r = { ...r, encapsulation: Qt.Emulated }); const i = this.getOrCreateRenderer(t, r); return i instanceof HD ? i.applyToHost(t) : i instanceof Ah && i.applyStyles(), i } getOrCreateRenderer(t, r) { const i = this.rendererByCompId; let o = i.get(r.id); if (!o) { const s = this.doc, a = this.ngZone, l = this.eventManager, c = this.sharedStylesHost, u = this.removeStylesOnCompDestroy, d = this.platformIsServer; switch (r.encapsulation) { case Qt.Emulated: o = new HD(l, c, r, this.appId, u, s, a, d); break; case Qt.ShadowDom: return new mF(l, c, t, r, s, a, this.nonce, d); default: o = new Ah(l, c, r, u, s, a, d) }i.set(r.id, o) } return o } ngOnDestroy() { this.rendererByCompId.clear() } static { this.\u0275fac = function (r) { return new (r || e)(k(OD), k(LD), k(ol), k(fF), k(We), k(sr), k(le), k(W_)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac }) } } return e })(); class Mh { constructor(n, t, r, i) { this.eventManager = n, this.doc = t, this.ngZone = r, this.platformIsServer = i, this.data = Object.create(null), this.destroyNode = null } destroy() { } createElement(n, t) { return t ? this.doc.createElementNS(Th[t] || t, n) : this.doc.createElement(n) } createComment(n) { return this.doc.createComment(n) } createText(n) { return this.doc.createTextNode(n) } appendChild(n, t) { (UD(n) ? n.content : n).appendChild(t) } insertBefore(n, t, r) { n && (UD(n) ? n.content : n).insertBefore(t, r) } removeChild(n, t) { n && n.removeChild(t) } selectRootElement(n, t) { let r = "string" == typeof n ? this.doc.querySelector(n) : n; if (!r) throw new x(-5104, !1); return t || (r.textContent = ""), r } parentNode(n) { return n.parentNode } nextSibling(n) { return n.nextSibling } setAttribute(n, t, r, i) { if (i) { t = i + ":" + t; const o = Th[i]; o ? n.setAttributeNS(o, t, r) : n.setAttribute(t, r) } else n.setAttribute(t, r) } removeAttribute(n, t, r) { if (r) { const i = Th[r]; i ? n.removeAttributeNS(i, t) : n.removeAttribute(`${r}:${t}`) } else n.removeAttribute(t) } addClass(n, t) { n.classList.add(t) } removeClass(n, t) { n.classList.remove(t) } setStyle(n, t, r, i) { i & (ir.DashCase | ir.Important) ? n.style.setProperty(t, r, i & ir.Important ? "important" : "") : n.style[t] = r } removeStyle(n, t, r) { r & ir.DashCase ? n.style.removeProperty(t) : n.style[t] = "" } setProperty(n, t, r) { n[t] = r } setValue(n, t) { n.nodeValue = t } listen(n, t, r) { if ("string" == typeof n && !(n = cr().getGlobalEventTarget(this.doc, n))) throw new Error(`Unsupported event target ${n} for event ${t}`); return this.eventManager.addEventListener(n, t, this.decoratePreventDefault(r)) } decoratePreventDefault(n) { return t => { if ("__ngUnwrap__" === t) return n; !1 === (this.platformIsServer ? this.ngZone.runGuarded(() => n(t)) : n(t)) && t.preventDefault() } } } function UD(e) { return "TEMPLATE" === e.tagName && void 0 !== e.content } class mF extends Mh { constructor(n, t, r, i, o, s, a, l) { super(n, o, s, l), this.sharedStylesHost = t, this.hostEl = r, this.shadowRoot = r.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const c = VD(i.id, i.styles); for (const u of c) { const d = document.createElement("style"); a && d.setAttribute("nonce", a), d.textContent = u, this.shadowRoot.appendChild(d) } } nodeOrShadowRoot(n) { return n === this.hostEl ? this.shadowRoot : n } appendChild(n, t) { return super.appendChild(this.nodeOrShadowRoot(n), t) } insertBefore(n, t, r) { return super.insertBefore(this.nodeOrShadowRoot(n), t, r) } removeChild(n, t) { return super.removeChild(this.nodeOrShadowRoot(n), t) } parentNode(n) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(n))) } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } } class Ah extends Mh { constructor(n, t, r, i, o, s, a, l) { super(n, o, s, a), this.sharedStylesHost = t, this.removeStylesOnCompDestroy = i, this.styles = l ? VD(l, r.styles) : r.styles } applyStyles() { this.sharedStylesHost.addStyles(this.styles) } destroy() { this.removeStylesOnCompDestroy && this.sharedStylesHost.removeStyles(this.styles) } } class HD extends Ah { constructor(n, t, r, i, o, s, a, l) { const c = i + "-" + r.id; super(n, t, r, o, s, a, l, c), this.contentAttr = function hF(e) { return "_ngcontent-%COMP%".replace(xh, e) }(c), this.hostAttr = function pF(e) { return "_nghost-%COMP%".replace(xh, e) }(c) } applyToHost(n) { this.applyStyles(), this.setAttribute(n, this.hostAttr, "") } createElement(n, t) { const r = super.createElement(n, t); return super.setAttribute(r, this.contentAttr, ""), r } } let _F = (() => { class e extends FD { constructor(t) { super(t) } supports(t) { return !0 } addEventListener(t, r, i) { return t.addEventListener(r, i, !1), () => this.removeEventListener(t, r, i) } removeEventListener(t, r, i) { return t.removeEventListener(r, i) } static { this.\u0275fac = function (r) { return new (r || e)(k(We)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac }) } } return e })(); const $D = ["alt", "control", "meta", "shift"], vF = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, yF = { alt: e => e.altKey, control: e => e.ctrlKey, meta: e => e.metaKey, shift: e => e.shiftKey }; let bF = (() => { class e extends FD { constructor(t) { super(t) } supports(t) { return null != e.parseEventName(t) } addEventListener(t, r, i) { const o = e.parseEventName(r), s = e.eventCallback(o.fullKey, i, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => cr().onAndCancel(t, o.domEventName, s)) } static parseEventName(t) { const r = t.toLowerCase().split("."), i = r.shift(); if (0 === r.length || "keydown" !== i && "keyup" !== i) return null; const o = e._normalizeKey(r.pop()); let s = "", a = r.indexOf("code"); if (a > -1 && (r.splice(a, 1), s = "code."), $D.forEach(c => { const u = r.indexOf(c); u > -1 && (r.splice(u, 1), s += c + ".") }), s += o, 0 != r.length || 0 === o.length) return null; const l = {}; return l.domEventName = i, l.fullKey = s, l } static matchEventFullKeyCode(t, r) { let i = vF[t.key] || t.key, o = ""; return r.indexOf("code.") > -1 && (i = t.code, o = "code."), !(null == i || !i) && (i = i.toLowerCase(), " " === i ? i = "space" : "." === i && (i = "dot"), $D.forEach(s => { s !== i && (0, yF[s])(t) && (o += s + ".") }), o += i, o === r) } static eventCallback(t, r, i) { return o => { e.matchEventFullKeyCode(o, t) && i.runGuarded(() => r(o)) } } static _normalizeKey(t) { return "esc" === t ? "escape" : t } static { this.\u0275fac = function (r) { return new (r || e)(k(We)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac }) } } return e })(); const EF = F0(QN, "browser", [{ provide: sr, useValue: xD }, { provide: q_, useValue: function DF() { Eh.makeCurrent() }, multi: !0 }, { provide: We, useFactory: function wF() { return function dx(e) { _d = e }(document), document }, deps: [] }]), IF = new A(""), qD = [{ provide: jl, useClass: class aF { addToWindow(n) { Ce.getAngularTestability = (r, i = !0) => { const o = n.findTestabilityInTree(r, i); if (null == o) throw new x(5103, !1); return o }, Ce.getAllAngularTestabilities = () => n.getAllTestabilities(), Ce.getAllAngularRootElements = () => n.getAllRootElements(), Ce.frameworkStabilizers || (Ce.frameworkStabilizers = []), Ce.frameworkStabilizers.push(r => { const i = Ce.getAllAngularTestabilities(); let o = i.length, s = !1; const a = function (l) { s = s || l, o--, 0 == o && r(s) }; i.forEach(l => { l.whenStable(a) }) }) } findTestabilityInTree(n, t, r) { return null == t ? null : n.getTestability(t) ?? (r ? cr().isShadowRoot(t) ? this.findTestabilityInTree(n, t.host, !0) : this.findTestabilityInTree(n, t.parentElement, !0) : null) } }, deps: [] }, { provide: k0, useClass: qf, deps: [le, Wf, jl] }, { provide: qf, useClass: qf, deps: [le, Wf, jl] }], WD = [{ provide: Td, useValue: "root" }, { provide: jn, useFactory: function CF() { return new jn }, deps: [] }, { provide: Ih, useClass: _F, multi: !0, deps: [We, le, sr] }, { provide: Ih, useClass: bF, multi: !0, deps: [We] }, BD, LD, OD, { provide: J_, useExisting: BD }, { provide: AD, useClass: lF, deps: [] }, []]; let SF = (() => { class e { constructor(t) { } static withServerTransition(t) { return { ngModule: e, providers: [{ provide: ol, useValue: t.appId }] } } static { this.\u0275fac = function (r) { return new (r || e)(k(IF, 12)) } } static { this.\u0275mod = bt({ type: e }) } static { this.\u0275inj = ct({ providers: [...WD, ...qD], imports: [x2, XN] }) } } return e })(), ZD = (() => { class e { constructor(t) { this._doc = t } getTitle() { return this._doc.title } setTitle(t) { this._doc.title = t || "" } static { this.\u0275fac = function (r) { return new (r || e)(k(We)) } } static { this.\u0275prov = F({ token: e, factory: function (r) { let i = null; return i = r ? new r : function xF() { return new ZD(k(We)) }(), i }, providedIn: "root" }) } } return e })(); typeof window < "u" && window; const { isArray: NF } = Array, { getPrototypeOf: OF, prototype: FF, keys: LF } = Object; function XD(e) { if (1 === e.length) { const n = e[0]; if (NF(n)) return { args: n, keys: null }; if (function jF(e) { return e && "object" == typeof e && OF(e) === FF }(n)) { const t = LF(n); return { args: t.map(r => n[r]), keys: t } } } return { args: e, keys: null } } const { isArray: VF } = Array; function Rh(e) { return re(n => function BF(e, n) { return VF(n) ? e(...n) : e(n) }(e, n)) } function JD(e, n) { return e.reduce((t, r, i) => (t[r] = n[i], t), {}) } function Ph(...e) { const n = vo(e), t = pg(e), { args: r, keys: i } = XD(e); if (0 === r.length) return He([], n); const o = new be(function UF(e, n, t = Yn) { return r => { eC(n, () => { const { length: i } = e, o = new Array(i); let s = i, a = i; for (let l = 0; l < i; l++)eC(n, () => { const c = He(e[l], n); let u = !1; c.subscribe(xe(r, d => { o[l] = d, u || (u = !0, a--), a || r.next(t(o.slice())) }, () => { --s || r.complete() })) }, r) }, r) } }(r, n, i ? s => JD(i, s) : Yn)); return t ? o.pipe(Rh(t)) : o } function eC(e, n, t) { e ? An(t, e, n) : n() } const oc = mo(e => function () { e(this), this.name = "EmptyError", this.message = "no elements in sequence" }); function Nh(...e) { return function HF() { return Qr(1) }()(He(e, vo(e))) } function tC(e) { return new be(n => { lt(e()).subscribe(n) }) } function Ji(e, n) { const t = ne(e) ? e : () => e, r = i => i.error(t()); return new be(n ? i => n.schedule(r, 0, i) : r) } function Oh() { return Ne((e, n) => { let t = null; e._refCount++; const r = xe(n, void 0, void 0, void 0, () => { if (!e || e._refCount <= 0 || 0 < --e._refCount) return void (t = null); const i = e._connection, o = t; t = null, i && (!o || i === o) && i.unsubscribe(), n.unsubscribe() }); e.subscribe(r), r.closed || (t = e.connect()) }) } class nC extends be { constructor(n, t) { super(), this.source = n, this.subjectFactory = t, this._subject = null, this._refCount = 0, this._connection = null, Jp(n) && (this.lift = n.lift) } _subscribe(n) { return this.getSubject().subscribe(n) } getSubject() { const n = this._subject; return (!n || n.isStopped) && (this._subject = this.subjectFactory()), this._subject } _teardown() { this._refCount = 0; const { _connection: n } = this; this._subject = this._connection = null, n?.unsubscribe() } connect() { let n = this._connection; if (!n) { n = this._connection = new Pe; const t = this.getSubject(); n.add(this.source.subscribe(xe(t, void 0, () => { this._teardown(), t.complete() }, r => { this._teardown(), t.error(r) }, () => this._teardown()))), n.closed && (this._connection = null, n = Pe.EMPTY) } return n } refCount() { return Oh()(this) } } function Cn(e) { return e <= 0 ? () => un : Ne((n, t) => { let r = 0; n.subscribe(xe(t, i => { ++r <= e && (t.next(i), e <= r && t.complete()) })) }) } function sc(...e) { const n = vo(e); return Ne((t, r) => { (n ? Nh(e, t, n) : Nh(e, t)).subscribe(r) }) } function an(e, n) { return Ne((t, r) => { let i = 0; t.subscribe(xe(r, o => e.call(n, o, i++) && r.next(o))) }) } function ac(e) { return Ne((n, t) => { let r = !1; n.subscribe(xe(t, i => { r = !0, t.next(i) }, () => { r || t.next(e), t.complete() })) }) } function rC(e = $F) { return Ne((n, t) => { let r = !1; n.subscribe(xe(t, i => { r = !0, t.next(i) }, () => r ? t.complete() : t.error(e()))) }) } function $F() { return new oc } function Lr(e, n) { const t = arguments.length >= 2; return r => r.pipe(e ? an((i, o) => e(i, o, r)) : Yn, Cn(1), t ? ac(n) : rC(() => new oc)) } function eo(e, n) { return ne(n) ? Ze(e, n, 1) : Ze(e, 1) } function Ue(e, n, t) { const r = ne(e) || n || t ? { next: e, error: n, complete: t } : e; return r ? Ne((i, o) => { var s; null === (s = r.subscribe) || void 0 === s || s.call(r); let a = !0; i.subscribe(xe(o, l => { var c; null === (c = r.next) || void 0 === c || c.call(r, l), o.next(l) }, () => { var l; a = !1, null === (l = r.complete) || void 0 === l || l.call(r), o.complete() }, l => { var c; a = !1, null === (c = r.error) || void 0 === c || c.call(r, l), o.error(l) }, () => { var l, c; a && (null === (l = r.unsubscribe) || void 0 === l || l.call(r)), null === (c = r.finalize) || void 0 === c || c.call(r) })) }) : Yn } function dr(e) { return Ne((n, t) => { let o, r = null, i = !1; r = n.subscribe(xe(t, void 0, void 0, s => { o = lt(e(s, dr(e)(n))), r ? (r.unsubscribe(), r = null, o.subscribe(t)) : i = !0 })), i && (r.unsubscribe(), r = null, o.subscribe(t)) }) } function Fh(e) { return e <= 0 ? () => un : Ne((n, t) => { let r = []; n.subscribe(xe(t, i => { r.push(i), e < r.length && r.shift() }, () => { for (const i of r) t.next(i); t.complete() }, void 0, () => { r = null })) }) } function Yt(e) { return Ne((n, t) => { try { n.subscribe(t) } finally { t.add(e) } }) } function Ss(e) { return Ne((n, t) => { lt(e).subscribe(xe(t, () => t.complete(), Jc)), !t.closed && n.subscribe(t) }) } const Y = "primary", Ts = Symbol("RouteTitle"); class ZF { constructor(n) { this.params = n || {} } has(n) { return Object.prototype.hasOwnProperty.call(this.params, n) } get(n) { if (this.has(n)) { const t = this.params[n]; return Array.isArray(t) ? t[0] : t } return null } getAll(n) { if (this.has(n)) { const t = this.params[n]; return Array.isArray(t) ? t : [t] } return [] } get keys() { return Object.keys(this.params) } } function to(e) { return new ZF(e) } function KF(e, n, t) { const r = t.path.split("/"); if (r.length > e.length || "full" === t.pathMatch && (n.hasChildren() || r.length < e.length)) return null; const i = {}; for (let o = 0; o < r.length; o++) { const s = r[o], a = e[o]; if (s.startsWith(":")) i[s.substring(1)] = a; else if (s !== a.path) return null } return { consumed: e.slice(0, r.length), posParams: i } } function wn(e, n) { const t = e ? Object.keys(e) : void 0, r = n ? Object.keys(n) : void 0; if (!t || !r || t.length != r.length) return !1; let i; for (let o = 0; o < t.length; o++)if (i = t[o], !iC(e[i], n[i])) return !1; return !0 } function iC(e, n) { if (Array.isArray(e) && Array.isArray(n)) { if (e.length !== n.length) return !1; const t = [...e].sort(), r = [...n].sort(); return t.every((i, o) => r[o] === i) } return e === n } function oC(e) { return e.length > 0 ? e[e.length - 1] : null } function fr(e) { return function PF(e) { return !!e && (e instanceof be || ne(e.lift) && ne(e.subscribe)) }(e) ? e : os(e) ? He(Promise.resolve(e)) : H(e) } const QF = { exact: function lC(e, n, t) { if (!jr(e.segments, n.segments) || !lc(e.segments, n.segments, t) || e.numberOfChildren !== n.numberOfChildren) return !1; for (const r in n.children) if (!e.children[r] || !lC(e.children[r], n.children[r], t)) return !1; return !0 }, subset: cC }, sC = { exact: function XF(e, n) { return wn(e, n) }, subset: function JF(e, n) { return Object.keys(n).length <= Object.keys(e).length && Object.keys(n).every(t => iC(e[t], n[t])) }, ignored: () => !0 }; function aC(e, n, t) { return QF[t.paths](e.root, n.root, t.matrixParams) && sC[t.queryParams](e.queryParams, n.queryParams) && !("exact" === t.fragment && e.fragment !== n.fragment) } function cC(e, n, t) { return uC(e, n, n.segments, t) } function uC(e, n, t, r) { if (e.segments.length > t.length) { const i = e.segments.slice(0, t.length); return !(!jr(i, t) || n.hasChildren() || !lc(i, t, r)) } if (e.segments.length === t.length) { if (!jr(e.segments, t) || !lc(e.segments, t, r)) return !1; for (const i in n.children) if (!e.children[i] || !cC(e.children[i], n.children[i], r)) return !1; return !0 } { const i = t.slice(0, e.segments.length), o = t.slice(e.segments.length); return !!(jr(e.segments, i) && lc(e.segments, i, r) && e.children[Y]) && uC(e.children[Y], n, o, r) } } function lc(e, n, t) { return n.every((r, i) => sC[t](e[i].parameters, r.parameters)) } class no { constructor(n = new _e([], {}), t = {}, r = null) { this.root = n, this.queryParams = t, this.fragment = r } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = to(this.queryParams)), this._queryParamMap } toString() { return nL.serialize(this) } } class _e { constructor(n, t) { this.segments = n, this.children = t, this.parent = null, Object.values(t).forEach(r => r.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return cc(this) } } class xs { constructor(n, t) { this.path = n, this.parameters = t } get parameterMap() { return this._parameterMap || (this._parameterMap = to(this.parameters)), this._parameterMap } toString() { return hC(this) } } function jr(e, n) { return e.length === n.length && e.every((t, r) => t.path === n[r].path) } let Ms = (() => { class e { static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = F({ token: e, factory: function () { return new Lh }, providedIn: "root" }) } } return e })(); class Lh { parse(n) { const t = new hL(n); return new no(t.parseRootSegment(), t.parseQueryParams(), t.parseFragment()) } serialize(n) { const t = `/${As(n.root, !0)}`, r = function oL(e) { const n = Object.keys(e).map(t => { const r = e[t]; return Array.isArray(r) ? r.map(i => `${uc(t)}=${uc(i)}`).join("&") : `${uc(t)}=${uc(r)}` }).filter(t => !!t); return n.length ? `?${n.join("&")}` : "" }(n.queryParams); return `${t}${r}${"string" == typeof n.fragment ? `#${function rL(e) { return encodeURI(e) }(n.fragment)}` : ""}` } } const nL = new Lh; function cc(e) { return e.segments.map(n => hC(n)).join("/") } function As(e, n) { if (!e.hasChildren()) return cc(e); if (n) { const t = e.children[Y] ? As(e.children[Y], !1) : "", r = []; return Object.entries(e.children).forEach(([i, o]) => { i !== Y && r.push(`${i}:${As(o, !1)}`) }), r.length > 0 ? `${t}(${r.join("//")})` : t } { const t = function tL(e, n) { let t = []; return Object.entries(e.children).forEach(([r, i]) => { r === Y && (t = t.concat(n(i, r))) }), Object.entries(e.children).forEach(([r, i]) => { r !== Y && (t = t.concat(n(i, r))) }), t }(e, (r, i) => i === Y ? [As(e.children[Y], !1)] : [`${i}:${As(r, !1)}`]); return 1 === Object.keys(e.children).length && null != e.children[Y] ? `${cc(e)}/${t[0]}` : `${cc(e)}/(${t.join("//")})` } } function dC(e) { return encodeURIComponent(e).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function uc(e) { return dC(e).replace(/%3B/gi, ";") } function jh(e) { return dC(e).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function dc(e) { return decodeURIComponent(e) } function fC(e) { return dc(e.replace(/\+/g, "%20")) } function hC(e) { return `${jh(e.path)}${function iL(e) { return Object.keys(e).map(n => `;${jh(n)}=${jh(e[n])}`).join("") }(e.parameters)}` } const sL = /^[^\/()?;#]+/; function Vh(e) { const n = e.match(sL); return n ? n[0] : "" } const aL = /^[^\/()?;=#]+/, cL = /^[^=?&#]+/, dL = /^[^&#]+/; class hL { constructor(n) { this.url = n, this.remaining = n } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new _e([], {}) : new _e([], this.parseChildren()) } parseQueryParams() { const n = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(n) } while (this.consumeOptional("&")); return n } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const n = []; for (this.peekStartsWith("(") || n.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), n.push(this.parseSegment()); let t = {}; this.peekStartsWith("/(") && (this.capture("/"), t = this.parseParens(!0)); let r = {}; return this.peekStartsWith("(") && (r = this.parseParens(!1)), (n.length > 0 || Object.keys(t).length > 0) && (r[Y] = new _e(n, t)), r } parseSegment() { const n = Vh(this.remaining); if ("" === n && this.peekStartsWith(";")) throw new x(4009, !1); return this.capture(n), new xs(dc(n), this.parseMatrixParams()) } parseMatrixParams() { const n = {}; for (; this.consumeOptional(";");)this.parseParam(n); return n } parseParam(n) { const t = function lL(e) { const n = e.match(aL); return n ? n[0] : "" }(this.remaining); if (!t) return; this.capture(t); let r = ""; if (this.consumeOptional("=")) { const i = Vh(this.remaining); i && (r = i, this.capture(r)) } n[dc(t)] = dc(r) } parseQueryParam(n) { const t = function uL(e) { const n = e.match(cL); return n ? n[0] : "" }(this.remaining); if (!t) return; this.capture(t); let r = ""; if (this.consumeOptional("=")) { const s = function fL(e) { const n = e.match(dL); return n ? n[0] : "" }(this.remaining); s && (r = s, this.capture(r)) } const i = fC(t), o = fC(r); if (n.hasOwnProperty(i)) { let s = n[i]; Array.isArray(s) || (s = [s], n[i] = s), s.push(o) } else n[i] = o } parseParens(n) { const t = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const r = Vh(this.remaining), i = this.remaining[r.length]; if ("/" !== i && ")" !== i && ";" !== i) throw new x(4010, !1); let o; r.indexOf(":") > -1 ? (o = r.slice(0, r.indexOf(":")), this.capture(o), this.capture(":")) : n && (o = Y); const s = this.parseChildren(); t[o] = 1 === Object.keys(s).length ? s[Y] : new _e([], s), this.consumeOptional("//") } return t } peekStartsWith(n) { return this.remaining.startsWith(n) } consumeOptional(n) { return !!this.peekStartsWith(n) && (this.remaining = this.remaining.substring(n.length), !0) } capture(n) { if (!this.consumeOptional(n)) throw new x(4011, !1) } } function pC(e) { return e.segments.length > 0 ? new _e([], { [Y]: e }) : e } function gC(e) { const n = {}; for (const r of Object.keys(e.children)) { const o = gC(e.children[r]); if (r === Y && 0 === o.segments.length && o.hasChildren()) for (const [s, a] of Object.entries(o.children)) n[s] = a; else (o.segments.length > 0 || o.hasChildren()) && (n[r] = o) } return function pL(e) { if (1 === e.numberOfChildren && e.children[Y]) { const n = e.children[Y]; return new _e(e.segments.concat(n.segments), n.children) } return e }(new _e(e.segments, n)) } function Vr(e) { return e instanceof no } function mC(e) { let n; const i = pC(function t(o) { const s = {}; for (const l of o.children) { const c = t(l); s[l.outlet] = c } const a = new _e(o.url, s); return o === e && (n = a), a }(e.root)); return n ?? i } function _C(e, n, t, r) { let i = e; for (; i.parent;)i = i.parent; if (0 === n.length) return Bh(i, i, i, t, r); const o = function mL(e) { if ("string" == typeof e[0] && 1 === e.length && "/" === e[0]) return new yC(!0, 0, e); let n = 0, t = !1; const r = e.reduce((i, o, s) => { if ("object" == typeof o && null != o) { if (o.outlets) { const a = {}; return Object.entries(o.outlets).forEach(([l, c]) => { a[l] = "string" == typeof c ? c.split("/") : c }), [...i, { outlets: a }] } if (o.segmentPath) return [...i, o.segmentPath] } return "string" != typeof o ? [...i, o] : 0 === s ? (o.split("/").forEach((a, l) => { 0 == l && "." === a || (0 == l && "" === a ? t = !0 : ".." === a ? n++ : "" != a && i.push(a)) }), i) : [...i, o] }, []); return new yC(t, n, r) }(n); if (o.toRoot()) return Bh(i, i, new _e([], {}), t, r); const s = function _L(e, n, t) { if (e.isAbsolute) return new hc(n, !0, 0); if (!t) return new hc(n, !1, NaN); if (null === t.parent) return new hc(t, !0, 0); const r = fc(e.commands[0]) ? 0 : 1; return function vL(e, n, t) { let r = e, i = n, o = t; for (; o > i;) { if (o -= i, r = r.parent, !r) throw new x(4005, !1); i = r.segments.length } return new hc(r, !1, i - o) }(t, t.segments.length - 1 + r, e.numberOfDoubleDots) }(o, i, e), a = s.processChildren ? Rs(s.segmentGroup, s.index, o.commands) : bC(s.segmentGroup, s.index, o.commands); return Bh(i, s.segmentGroup, a, t, r) } function fc(e) { return "object" == typeof e && null != e && !e.outlets && !e.segmentPath } function ks(e) { return "object" == typeof e && null != e && e.outlets } function Bh(e, n, t, r, i) { let s, o = {}; r && Object.entries(r).forEach(([l, c]) => { o[l] = Array.isArray(c) ? c.map(u => `${u}`) : `${c}` }), s = e === n ? t : vC(e, n, t); const a = pC(gC(s)); return new no(a, o, i) } function vC(e, n, t) { const r = {}; return Object.entries(e.children).forEach(([i, o]) => { r[i] = o === n ? t : vC(o, n, t) }), new _e(e.segments, r) } class yC { constructor(n, t, r) { if (this.isAbsolute = n, this.numberOfDoubleDots = t, this.commands = r, n && r.length > 0 && fc(r[0])) throw new x(4003, !1); const i = r.find(ks); if (i && i !== oC(r)) throw new x(4004, !1) } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class hc { constructor(n, t, r) { this.segmentGroup = n, this.processChildren = t, this.index = r } } function bC(e, n, t) { if (e || (e = new _e([], {})), 0 === e.segments.length && e.hasChildren()) return Rs(e, n, t); const r = function bL(e, n, t) { let r = 0, i = n; const o = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; i < e.segments.length;) { if (r >= t.length) return o; const s = e.segments[i], a = t[r]; if (ks(a)) break; const l = `${a}`, c = r < t.length - 1 ? t[r + 1] : null; if (i > 0 && void 0 === l) break; if (l && c && "object" == typeof c && void 0 === c.outlets) { if (!CC(l, c, s)) return o; r += 2 } else { if (!CC(l, {}, s)) return o; r++ } i++ } return { match: !0, pathIndex: i, commandIndex: r } }(e, n, t), i = t.slice(r.commandIndex); if (r.match && r.pathIndex < e.segments.length) { const o = new _e(e.segments.slice(0, r.pathIndex), {}); return o.children[Y] = new _e(e.segments.slice(r.pathIndex), e.children), Rs(o, 0, i) } return r.match && 0 === i.length ? new _e(e.segments, {}) : r.match && !e.hasChildren() ? Uh(e, n, t) : r.match ? Rs(e, 0, i) : Uh(e, n, t) } function Rs(e, n, t) { if (0 === t.length) return new _e(e.segments, {}); { const r = function yL(e) { return ks(e[0]) ? e[0].outlets : { [Y]: e } }(t), i = {}; if (Object.keys(r).some(o => o !== Y) && e.children[Y] && 1 === e.numberOfChildren && 0 === e.children[Y].segments.length) { const o = Rs(e.children[Y], n, t); return new _e(e.segments, o.children) } return Object.entries(r).forEach(([o, s]) => { "string" == typeof s && (s = [s]), null !== s && (i[o] = bC(e.children[o], n, s)) }), Object.entries(e.children).forEach(([o, s]) => { void 0 === r[o] && (i[o] = s) }), new _e(e.segments, i) } } function Uh(e, n, t) { const r = e.segments.slice(0, n); let i = 0; for (; i < t.length;) { const o = t[i]; if (ks(o)) { const l = DL(o.outlets); return new _e(r, l) } if (0 === i && fc(t[0])) { r.push(new xs(e.segments[n].path, DC(t[0]))), i++; continue } const s = ks(o) ? o.outlets[Y] : `${o}`, a = i < t.length - 1 ? t[i + 1] : null; s && a && fc(a) ? (r.push(new xs(s, DC(a))), i += 2) : (r.push(new xs(s, {})), i++) } return new _e(r, {}) } function DL(e) { const n = {}; return Object.entries(e).forEach(([t, r]) => { "string" == typeof r && (r = [r]), null !== r && (n[t] = Uh(new _e([], {}), 0, r)) }), n } function DC(e) { const n = {}; return Object.entries(e).forEach(([t, r]) => n[t] = `${r}`), n } function CC(e, n, t) { return e == t.path && wn(n, t.parameters) } const Ps = "imperative"; class En { constructor(n, t) { this.id = n, this.url = t } } class pc extends En { constructor(n, t, r = "imperative", i = null) { super(n, t), this.type = 0, this.navigationTrigger = r, this.restoredState = i } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class hr extends En { constructor(n, t, r) { super(n, t), this.urlAfterRedirects = r, this.type = 1 } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class Ns extends En { constructor(n, t, r, i) { super(n, t), this.reason = r, this.code = i, this.type = 2 } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class ro extends En { constructor(n, t, r, i) { super(n, t), this.reason = r, this.code = i, this.type = 16 } } class gc extends En { constructor(n, t, r, i) { super(n, t), this.error = r, this.target = i, this.type = 3 } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class wC extends En { constructor(n, t, r, i) { super(n, t), this.urlAfterRedirects = r, this.state = i, this.type = 4 } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class CL extends En { constructor(n, t, r, i) { super(n, t), this.urlAfterRedirects = r, this.state = i, this.type = 7 } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class wL extends En { constructor(n, t, r, i, o) { super(n, t), this.urlAfterRedirects = r, this.state = i, this.shouldActivate = o, this.type = 8 } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class EL extends En { constructor(n, t, r, i) { super(n, t), this.urlAfterRedirects = r, this.state = i, this.type = 5 } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class IL extends En { constructor(n, t, r, i) { super(n, t), this.urlAfterRedirects = r, this.state = i, this.type = 6 } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class SL { constructor(n) { this.route = n, this.type = 9 } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class TL { constructor(n) { this.route = n, this.type = 10 } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class xL { constructor(n) { this.snapshot = n, this.type = 11 } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class ML { constructor(n) { this.snapshot = n, this.type = 12 } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class AL { constructor(n) { this.snapshot = n, this.type = 13 } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class kL { constructor(n) { this.snapshot = n, this.type = 14 } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class EC { constructor(n, t, r) { this.routerEvent = n, this.position = t, this.anchor = r, this.type = 15 } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } class Hh { } class $h { constructor(n) { this.url = n } } class RL { constructor() { this.outlet = null, this.route = null, this.injector = null, this.children = new Os, this.attachRef = null } } let Os = (() => { class e { constructor() { this.contexts = new Map } onChildOutletCreated(t, r) { const i = this.getOrCreateContext(t); i.outlet = r, this.contexts.set(t, i) } onChildOutletDestroyed(t) { const r = this.getContext(t); r && (r.outlet = null, r.attachRef = null) } onOutletDeactivated() { const t = this.contexts; return this.contexts = new Map, t } onOutletReAttached(t) { this.contexts = t } getOrCreateContext(t) { let r = this.getContext(t); return r || (r = new RL, this.contexts.set(t, r)), r } getContext(t) { return this.contexts.get(t) || null } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); class IC { constructor(n) { this._root = n } get root() { return this._root.value } parent(n) { const t = this.pathFromRoot(n); return t.length > 1 ? t[t.length - 2] : null } children(n) { const t = zh(n, this._root); return t ? t.children.map(r => r.value) : [] } firstChild(n) { const t = zh(n, this._root); return t && t.children.length > 0 ? t.children[0].value : null } siblings(n) { const t = Gh(n, this._root); return t.length < 2 ? [] : t[t.length - 2].children.map(i => i.value).filter(i => i !== n) } pathFromRoot(n) { return Gh(n, this._root).map(t => t.value) } } function zh(e, n) { if (e === n.value) return n; for (const t of n.children) { const r = zh(e, t); if (r) return r } return null } function Gh(e, n) { if (e === n.value) return [n]; for (const t of n.children) { const r = Gh(e, t); if (r.length) return r.unshift(n), r } return [] } class qn { constructor(n, t) { this.value = n, this.children = t } toString() { return `TreeNode(${this.value})` } } function io(e) { const n = {}; return e && e.children.forEach(t => n[t.value.outlet] = t), n } class SC extends IC { constructor(n, t) { super(n), this.snapshot = t, qh(this, n) } toString() { return this.snapshot.toString() } } function TC(e, n) { const t = function PL(e, n) { const s = new mc([], {}, {}, "", {}, Y, n, null, {}); return new MC("", new qn(s, [])) }(0, n), r = new xt([new xs("", {})]), i = new xt({}), o = new xt({}), s = new xt({}), a = new xt(""), l = new ln(r, i, s, a, o, Y, n, t.root); return l.snapshot = t.root, new SC(new qn(l, []), t) } class ln { constructor(n, t, r, i, o, s, a, l) { this.urlSubject = n, this.paramsSubject = t, this.queryParamsSubject = r, this.fragmentSubject = i, this.dataSubject = o, this.outlet = s, this.component = a, this._futureSnapshot = l, this.title = this.dataSubject?.pipe(re(c => c[Ts])) ?? H(void 0), this.url = n, this.params = t, this.queryParams = r, this.fragment = i, this.data = o } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(re(n => to(n)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(re(n => to(n)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function xC(e, n = "emptyOnly") { const t = e.pathFromRoot; let r = 0; if ("always" !== n) for (r = t.length - 1; r >= 1;) { const i = t[r], o = t[r - 1]; if (i.routeConfig && "" === i.routeConfig.path) r--; else { if (o.component) break; r-- } } return function NL(e) { return e.reduce((n, t) => ({ params: { ...n.params, ...t.params }, data: { ...n.data, ...t.data }, resolve: { ...t.data, ...n.resolve, ...t.routeConfig?.data, ...t._resolvedData } }), { params: {}, data: {}, resolve: {} }) }(t.slice(r)) } class mc { get title() { return this.data?.[Ts] } constructor(n, t, r, i, o, s, a, l, c) { this.url = n, this.params = t, this.queryParams = r, this.fragment = i, this.data = o, this.outlet = s, this.component = a, this.routeConfig = l, this._resolve = c } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = to(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = to(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(r => r.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class MC extends IC { constructor(n, t) { super(t), this.url = n, qh(this, t) } toString() { return AC(this._root) } } function qh(e, n) { n.value._routerState = e, n.children.forEach(t => qh(e, t)) } function AC(e) { const n = e.children.length > 0 ? ` { ${e.children.map(AC).join(", ")} } ` : ""; return `${e.value}${n}` } function Wh(e) { if (e.snapshot) { const n = e.snapshot, t = e._futureSnapshot; e.snapshot = t, wn(n.queryParams, t.queryParams) || e.queryParamsSubject.next(t.queryParams), n.fragment !== t.fragment && e.fragmentSubject.next(t.fragment), wn(n.params, t.params) || e.paramsSubject.next(t.params), function YF(e, n) { if (e.length !== n.length) return !1; for (let t = 0; t < e.length; ++t)if (!wn(e[t], n[t])) return !1; return !0 }(n.url, t.url) || e.urlSubject.next(t.url), wn(n.data, t.data) || e.dataSubject.next(t.data) } else e.snapshot = e._futureSnapshot, e.dataSubject.next(e._futureSnapshot.data) } function Zh(e, n) { const t = wn(e.params, n.params) && function eL(e, n) { return jr(e, n) && e.every((t, r) => wn(t.parameters, n[r].parameters)) }(e.url, n.url); return t && !(!e.parent != !n.parent) && (!e.parent || Zh(e.parent, n.parent)) } let Fs = (() => { class e { constructor() { this.activated = null, this._activatedRoute = null, this.name = Y, this.activateEvents = new se, this.deactivateEvents = new se, this.attachEvents = new se, this.detachEvents = new se, this.parentContexts = O(Os), this.location = O(Wt), this.changeDetector = O(Pr), this.environmentInjector = O(Nt), this.inputBinder = O(_c, { optional: !0 }), this.supportsBindingToComponentInputs = !0 } get activatedComponentRef() { return this.activated } ngOnChanges(t) { if (t.name) { const { firstChange: r, previousValue: i } = t.name; if (r) return; this.isTrackedInParentContexts(i) && (this.deactivate(), this.parentContexts.onChildOutletDestroyed(i)), this.initializeOutletWithName() } } ngOnDestroy() { this.isTrackedInParentContexts(this.name) && this.parentContexts.onChildOutletDestroyed(this.name), this.inputBinder?.unsubscribeFromRouteData(this) } isTrackedInParentContexts(t) { return this.parentContexts.getContext(t)?.outlet === this } ngOnInit() { this.initializeOutletWithName() } initializeOutletWithName() { if (this.parentContexts.onChildOutletCreated(this.name, this), this.activated) return; const t = this.parentContexts.getContext(this.name); t?.route && (t.attachRef ? this.attach(t.attachRef, t.route) : this.activateWith(t.route, t.injector)) } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new x(4012, !1); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new x(4012, !1); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new x(4012, !1); this.location.detach(); const t = this.activated; return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(t.instance), t } attach(t, r) { this.activated = t, this._activatedRoute = r, this.location.insert(t.hostView), this.inputBinder?.bindActivatedRouteToOutletComponent(this), this.attachEvents.emit(t.instance) } deactivate() { if (this.activated) { const t = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(t) } } activateWith(t, r) { if (this.isActivated) throw new x(4013, !1); this._activatedRoute = t; const i = this.location, s = t.snapshot.component, a = this.parentContexts.getOrCreateContext(this.name).children, l = new OL(t, a, i.injector); this.activated = i.createComponent(s, { index: i.length, injector: l, environmentInjector: r ?? this.environmentInjector }), this.changeDetector.markForCheck(), this.inputBinder?.bindActivatedRouteToOutletComponent(this), this.activateEvents.emit(this.activated.instance) } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275dir = j({ type: e, selectors: [["router-outlet"]], inputs: { name: "name" }, outputs: { activateEvents: "activate", deactivateEvents: "deactivate", attachEvents: "attach", detachEvents: "detach" }, exportAs: ["outlet"], standalone: !0, features: [kt] }) } } return e })(); class OL { constructor(n, t, r) { this.route = n, this.childContexts = t, this.parent = r } get(n, t) { return n === ln ? this.route : n === Os ? this.childContexts : this.parent.get(n, t) } } const _c = new A(""); let kC = (() => { class e { constructor() { this.outletDataSubscriptions = new Map } bindActivatedRouteToOutletComponent(t) { this.unsubscribeFromRouteData(t), this.subscribeToRouteData(t) } unsubscribeFromRouteData(t) { this.outletDataSubscriptions.get(t)?.unsubscribe(), this.outletDataSubscriptions.delete(t) } subscribeToRouteData(t) { const { activatedRoute: r } = t, i = Ph([r.queryParams, r.params, r.data]).pipe(Vt(([o, s, a], l) => (a = { ...o, ...s, ...a }, 0 === l ? H(a) : Promise.resolve(a)))).subscribe(o => { if (!t.isActivated || !t.activatedComponentRef || t.activatedRoute !== r || null === r.component) return void this.unsubscribeFromRouteData(t); const s = function uO(e) { const n = ie(e); if (!n) return null; const t = new es(n); return { get selector() { return t.selector }, get type() { return t.componentType }, get inputs() { return t.inputs }, get outputs() { return t.outputs }, get ngContentSelectors() { return t.ngContentSelectors }, get isStandalone() { return n.standalone }, get isSignal() { return n.signals } } }(r.component); if (s) for (const { templateName: a } of s.inputs) t.activatedComponentRef.setInput(a, o[a]); else this.unsubscribeFromRouteData(t) }); this.outletDataSubscriptions.set(t, i) } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac }) } } return e })(); function Ls(e, n, t) { if (t && e.shouldReuseRoute(n.value, t.value.snapshot)) { const r = t.value; r._futureSnapshot = n.value; const i = function LL(e, n, t) { return n.children.map(r => { for (const i of t.children) if (e.shouldReuseRoute(r.value, i.value.snapshot)) return Ls(e, r, i); return Ls(e, r) }) }(e, n, t); return new qn(r, i) } { if (e.shouldAttach(n.value)) { const o = e.retrieve(n.value); if (null !== o) { const s = o.route; return s.value._futureSnapshot = n.value, s.children = n.children.map(a => Ls(e, a)), s } } const r = function jL(e) { return new ln(new xt(e.url), new xt(e.params), new xt(e.queryParams), new xt(e.fragment), new xt(e.data), e.outlet, e.component, e) }(n.value), i = n.children.map(o => Ls(e, o)); return new qn(r, i) } } const Kh = "ngNavigationCancelingError"; function RC(e, n) { const { redirectTo: t, navigationBehaviorOptions: r } = Vr(n) ? { redirectTo: n, navigationBehaviorOptions: void 0 } : n, i = PC(!1, 0, n); return i.url = t, i.navigationBehaviorOptions = r, i } function PC(e, n, t) { const r = new Error("NavigationCancelingError: " + (e || "")); return r[Kh] = !0, r.cancellationCode = n, t && (r.url = t), r } function NC(e) { return e && e[Kh] } let OC = (() => { class e { static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275cmp = rt({ type: e, selectors: [["ng-component"]], standalone: !0, features: [Fb], decls: 1, vars: 0, template: function (r, i) { 1 & r && M(0, "router-outlet") }, dependencies: [Fs], encapsulation: 2 }) } } return e })(); function Yh(e) { const n = e.children && e.children.map(Yh), t = n ? { ...e, children: n } : { ...e }; return !t.component && !t.loadComponent && (n || t.loadChildren) && t.outlet && t.outlet !== Y && (t.component = OC), t } function cn(e) { return e.outlet || Y } function js(e) { if (!e) return null; if (e.routeConfig?._injector) return e.routeConfig._injector; for (let n = e.parent; n; n = n.parent) { const t = n.routeConfig; if (t?._loadedInjector) return t._loadedInjector; if (t?._injector) return t._injector } return null } class qL { constructor(n, t, r, i, o) { this.routeReuseStrategy = n, this.futureState = t, this.currState = r, this.forwardEvent = i, this.inputBindingEnabled = o } activate(n) { const t = this.futureState._root, r = this.currState ? this.currState._root : null; this.deactivateChildRoutes(t, r, n), Wh(this.futureState.root), this.activateChildRoutes(t, r, n) } deactivateChildRoutes(n, t, r) { const i = io(t); n.children.forEach(o => { const s = o.value.outlet; this.deactivateRoutes(o, i[s], r), delete i[s] }), Object.values(i).forEach(o => { this.deactivateRouteAndItsChildren(o, r) }) } deactivateRoutes(n, t, r) { const i = n.value, o = t ? t.value : null; if (i === o) if (i.component) { const s = r.getContext(i.outlet); s && this.deactivateChildRoutes(n, t, s.children) } else this.deactivateChildRoutes(n, t, r); else o && this.deactivateRouteAndItsChildren(t, r) } deactivateRouteAndItsChildren(n, t) { n.value.component && this.routeReuseStrategy.shouldDetach(n.value.snapshot) ? this.detachAndStoreRouteSubtree(n, t) : this.deactivateRouteAndOutlet(n, t) } detachAndStoreRouteSubtree(n, t) { const r = t.getContext(n.value.outlet), i = r && n.value.component ? r.children : t, o = io(n); for (const s of Object.keys(o)) this.deactivateRouteAndItsChildren(o[s], i); if (r && r.outlet) { const s = r.outlet.detach(), a = r.children.onOutletDeactivated(); this.routeReuseStrategy.store(n.value.snapshot, { componentRef: s, route: n, contexts: a }) } } deactivateRouteAndOutlet(n, t) { const r = t.getContext(n.value.outlet), i = r && n.value.component ? r.children : t, o = io(n); for (const s of Object.keys(o)) this.deactivateRouteAndItsChildren(o[s], i); r && (r.outlet && (r.outlet.deactivate(), r.children.onOutletDeactivated()), r.attachRef = null, r.route = null) } activateChildRoutes(n, t, r) { const i = io(t); n.children.forEach(o => { this.activateRoutes(o, i[o.value.outlet], r), this.forwardEvent(new kL(o.value.snapshot)) }), n.children.length && this.forwardEvent(new ML(n.value.snapshot)) } activateRoutes(n, t, r) { const i = n.value, o = t ? t.value : null; if (Wh(i), i === o) if (i.component) { const s = r.getOrCreateContext(i.outlet); this.activateChildRoutes(n, t, s.children) } else this.activateChildRoutes(n, t, r); else if (i.component) { const s = r.getOrCreateContext(i.outlet); if (this.routeReuseStrategy.shouldAttach(i.snapshot)) { const a = this.routeReuseStrategy.retrieve(i.snapshot); this.routeReuseStrategy.store(i.snapshot, null), s.children.onOutletReAttached(a.contexts), s.attachRef = a.componentRef, s.route = a.route.value, s.outlet && s.outlet.attach(a.componentRef, a.route.value), Wh(a.route.value), this.activateChildRoutes(n, null, s.children) } else { const a = js(i.snapshot); s.attachRef = null, s.route = i, s.injector = a, s.outlet && s.outlet.activateWith(i, s.injector), this.activateChildRoutes(n, null, s.children) } } else this.activateChildRoutes(n, null, r) } } class FC { constructor(n) { this.path = n, this.route = this.path[this.path.length - 1] } } class vc { constructor(n, t) { this.component = n, this.route = t } } function WL(e, n, t) { const r = e._root; return Vs(r, n ? n._root : null, t, [r.value]) } function oo(e, n) { const t = Symbol(), r = n.get(e, t); return r === t ? "function" != typeof e || function MI(e) { return null !== ga(e) }(e) ? n.get(e) : e : r } function Vs(e, n, t, r, i = { canDeactivateChecks: [], canActivateChecks: [] }) { const o = io(n); return e.children.forEach(s => { (function KL(e, n, t, r, i = { canDeactivateChecks: [], canActivateChecks: [] }) { const o = e.value, s = n ? n.value : null, a = t ? t.getContext(e.value.outlet) : null; if (s && o.routeConfig === s.routeConfig) { const l = function YL(e, n, t) { if ("function" == typeof t) return t(e, n); switch (t) { case "pathParamsChange": return !jr(e.url, n.url); case "pathParamsOrQueryParamsChange": return !jr(e.url, n.url) || !wn(e.queryParams, n.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !Zh(e, n) || !wn(e.queryParams, n.queryParams); default: return !Zh(e, n) } }(s, o, o.routeConfig.runGuardsAndResolvers); l ? i.canActivateChecks.push(new FC(r)) : (o.data = s.data, o._resolvedData = s._resolvedData), Vs(e, n, o.component ? a ? a.children : null : t, r, i), l && a && a.outlet && a.outlet.isActivated && i.canDeactivateChecks.push(new vc(a.outlet.component, s)) } else s && Bs(n, a, i), i.canActivateChecks.push(new FC(r)), Vs(e, null, o.component ? a ? a.children : null : t, r, i) })(s, o[s.value.outlet], t, r.concat([s.value]), i), delete o[s.value.outlet] }), Object.entries(o).forEach(([s, a]) => Bs(a, t.getContext(s), i)), i } function Bs(e, n, t) { const r = io(e), i = e.value; Object.entries(r).forEach(([o, s]) => { Bs(s, i.component ? n ? n.children.getContext(o) : null : n, t) }), t.canDeactivateChecks.push(new vc(i.component && n && n.outlet && n.outlet.isActivated ? n.outlet.component : null, i)) } function Us(e) { return "function" == typeof e } function LC(e) { return e instanceof oc || "EmptyError" === e?.name } const yc = Symbol("INITIAL_VALUE"); function so() { return Vt(e => Ph(e.map(n => n.pipe(Cn(1), sc(yc)))).pipe(re(n => { for (const t of n) if (!0 !== t) { if (t === yc) return yc; if (!1 === t || t instanceof no) return t } return !0 }), an(n => n !== yc), Cn(1))) } function jC(e) { return function xE(...e) { return Yp(e) }(Ue(n => { if (Vr(n)) throw RC(0, n) }), re(n => !0 === n)) } class bc { constructor(n) { this.segmentGroup = n || null } } class VC { constructor(n) { this.urlTree = n } } function ao(e) { return Ji(new bc(e)) } function BC(e) { return Ji(new VC(e)) } class mj { constructor(n, t) { this.urlSerializer = n, this.urlTree = t } noMatchError(n) { return new x(4002, !1) } lineralizeSegments(n, t) { let r = [], i = t.root; for (; ;) { if (r = r.concat(i.segments), 0 === i.numberOfChildren) return H(r); if (i.numberOfChildren > 1 || !i.children[Y]) return Ji(new x(4e3, !1)); i = i.children[Y] } } applyRedirectCommands(n, t, r) { return this.applyRedirectCreateUrlTree(t, this.urlSerializer.parse(t), n, r) } applyRedirectCreateUrlTree(n, t, r, i) { const o = this.createSegmentGroup(n, t.root, r, i); return new no(o, this.createQueryParams(t.queryParams, this.urlTree.queryParams), t.fragment) } createQueryParams(n, t) { const r = {}; return Object.entries(n).forEach(([i, o]) => { if ("string" == typeof o && o.startsWith(":")) { const a = o.substring(1); r[i] = t[a] } else r[i] = o }), r } createSegmentGroup(n, t, r, i) { const o = this.createSegments(n, t.segments, r, i); let s = {}; return Object.entries(t.children).forEach(([a, l]) => { s[a] = this.createSegmentGroup(n, l, r, i) }), new _e(o, s) } createSegments(n, t, r, i) { return t.map(o => o.path.startsWith(":") ? this.findPosParam(n, o, i) : this.findOrReturn(o, r)) } findPosParam(n, t, r) { const i = r[t.path.substring(1)]; if (!i) throw new x(4001, !1); return i } findOrReturn(n, t) { let r = 0; for (const i of t) { if (i.path === n.path) return t.splice(r), i; r++ } return n } } const Qh = { matched: !1, consumedSegments: [], remainingSegments: [], parameters: {}, positionalParamSegments: {} }; function _j(e, n, t, r, i) { const o = Xh(e, n, t); return o.matched ? (r = function BL(e, n) { return e.providers && !e._injector && (e._injector = Tf(e.providers, n, `Route: ${e.path}`)), e._injector ?? n }(n, r), function hj(e, n, t, r) { const i = n.canMatch; return i && 0 !== i.length ? H(i.map(s => { const a = oo(s, e); return fr(function nj(e) { return e && Us(e.canMatch) }(a) ? a.canMatch(n, t) : e.runInContext(() => a(n, t))) })).pipe(so(), jC()) : H(!0) }(r, n, t).pipe(re(s => !0 === s ? o : { ...Qh }))) : H(o) } function Xh(e, n, t) { if ("" === n.path) return "full" === n.pathMatch && (e.hasChildren() || t.length > 0) ? { ...Qh } : { matched: !0, consumedSegments: [], remainingSegments: t, parameters: {}, positionalParamSegments: {} }; const i = (n.matcher || KF)(t, e, n); if (!i) return { ...Qh }; const o = {}; Object.entries(i.posParams ?? {}).forEach(([a, l]) => { o[a] = l.path }); const s = i.consumed.length > 0 ? { ...o, ...i.consumed[i.consumed.length - 1].parameters } : o; return { matched: !0, consumedSegments: i.consumed, remainingSegments: t.slice(i.consumed.length), parameters: s, positionalParamSegments: i.posParams ?? {} } } function UC(e, n, t, r) { return t.length > 0 && function bj(e, n, t) { return t.some(r => Dc(e, n, r) && cn(r) !== Y) }(e, t, r) ? { segmentGroup: new _e(n, yj(r, new _e(t, e.children))), slicedSegments: [] } : 0 === t.length && function Dj(e, n, t) { return t.some(r => Dc(e, n, r)) }(e, t, r) ? { segmentGroup: new _e(e.segments, vj(e, 0, t, r, e.children)), slicedSegments: t } : { segmentGroup: new _e(e.segments, e.children), slicedSegments: t } } function vj(e, n, t, r, i) { const o = {}; for (const s of r) if (Dc(e, t, s) && !i[cn(s)]) { const a = new _e([], {}); o[cn(s)] = a } return { ...i, ...o } } function yj(e, n) { const t = {}; t[Y] = n; for (const r of e) if ("" === r.path && cn(r) !== Y) { const i = new _e([], {}); t[cn(r)] = i } return t } function Dc(e, n, t) { return (!(e.hasChildren() || n.length > 0) || "full" !== t.pathMatch) && "" === t.path } class Ij { constructor(n, t, r, i, o, s, a) { this.injector = n, this.configLoader = t, this.rootComponentType = r, this.config = i, this.urlTree = o, this.paramsInheritanceStrategy = s, this.urlSerializer = a, this.allowRedirects = !0, this.applyRedirects = new mj(this.urlSerializer, this.urlTree) } noMatchError(n) { return new x(4002, !1) } recognize() { const n = UC(this.urlTree.root, [], [], this.config).segmentGroup; return this.processSegmentGroup(this.injector, this.config, n, Y).pipe(dr(t => { if (t instanceof VC) return this.allowRedirects = !1, this.urlTree = t.urlTree, this.match(t.urlTree); throw t instanceof bc ? this.noMatchError(t) : t }), re(t => { const r = new mc([], Object.freeze({}), Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, {}, Y, this.rootComponentType, null, {}), i = new qn(r, t), o = new MC("", i), s = function gL(e, n, t = null, r = null) { return _C(mC(e), n, t, r) }(r, [], this.urlTree.queryParams, this.urlTree.fragment); return s.queryParams = this.urlTree.queryParams, o.url = this.urlSerializer.serialize(s), this.inheritParamsAndData(o._root), { state: o, tree: s } })) } match(n) { return this.processSegmentGroup(this.injector, this.config, n.root, Y).pipe(dr(r => { throw r instanceof bc ? this.noMatchError(r) : r })) } inheritParamsAndData(n) { const t = n.value, r = xC(t, this.paramsInheritanceStrategy); t.params = Object.freeze(r.params), t.data = Object.freeze(r.data), n.children.forEach(i => this.inheritParamsAndData(i)) } processSegmentGroup(n, t, r, i) { return 0 === r.segments.length && r.hasChildren() ? this.processChildren(n, t, r) : this.processSegment(n, t, r, r.segments, i, !0) } processChildren(n, t, r) { const i = []; for (const o of Object.keys(r.children)) "primary" === o ? i.unshift(o) : i.push(o); return He(i).pipe(eo(o => { const s = r.children[o], a = function zL(e, n) { const t = e.filter(r => cn(r) === n); return t.push(...e.filter(r => cn(r) !== n)), t }(t, o); return this.processSegmentGroup(n, a, s, o) }), function GF(e, n) { return Ne(function zF(e, n, t, r, i) { return (o, s) => { let a = t, l = n, c = 0; o.subscribe(xe(s, u => { const d = c++; l = a ? e(l, u, d) : (a = !0, u), r && s.next(l) }, i && (() => { a && s.next(l), s.complete() }))) } }(e, n, arguments.length >= 2, !0)) }((o, s) => (o.push(...s), o)), ac(null), function qF(e, n) { const t = arguments.length >= 2; return r => r.pipe(e ? an((i, o) => e(i, o, r)) : Yn, Fh(1), t ? ac(n) : rC(() => new oc)) }(), Ze(o => { if (null === o) return ao(r); const s = HC(o); return function Sj(e) { e.sort((n, t) => n.value.outlet === Y ? -1 : t.value.outlet === Y ? 1 : n.value.outlet.localeCompare(t.value.outlet)) }(s), H(s) })) } processSegment(n, t, r, i, o, s) { return He(t).pipe(eo(a => this.processSegmentAgainstRoute(a._injector ?? n, t, a, r, i, o, s).pipe(dr(l => { if (l instanceof bc) return H(null); throw l }))), Lr(a => !!a), dr(a => { if (LC(a)) return function wj(e, n, t) { return 0 === n.length && !e.children[t] }(r, i, o) ? H([]) : ao(r); throw a })) } processSegmentAgainstRoute(n, t, r, i, o, s, a) { return function Cj(e, n, t, r) { return !!(cn(e) === r || r !== Y && Dc(n, t, e)) && ("**" === e.path || Xh(n, e, t).matched) }(r, i, o, s) ? void 0 === r.redirectTo ? this.matchSegmentAgainstRoute(n, i, r, o, s, a) : a && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(n, i, t, r, o, s) : ao(i) : ao(i) } expandSegmentAgainstRouteUsingRedirect(n, t, r, i, o, s) { return "**" === i.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(n, r, i, s) : this.expandRegularSegmentAgainstRouteUsingRedirect(n, t, r, i, o, s) } expandWildCardWithParamsAgainstRouteUsingRedirect(n, t, r, i) { const o = this.applyRedirects.applyRedirectCommands([], r.redirectTo, {}); return r.redirectTo.startsWith("/") ? BC(o) : this.applyRedirects.lineralizeSegments(r, o).pipe(Ze(s => { const a = new _e(s, {}); return this.processSegment(n, t, a, s, i, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(n, t, r, i, o, s) { const { matched: a, consumedSegments: l, remainingSegments: c, positionalParamSegments: u } = Xh(t, i, o); if (!a) return ao(t); const d = this.applyRedirects.applyRedirectCommands(l, i.redirectTo, u); return i.redirectTo.startsWith("/") ? BC(d) : this.applyRedirects.lineralizeSegments(i, d).pipe(Ze(p => this.processSegment(n, r, t, p.concat(c), s, !1))) } matchSegmentAgainstRoute(n, t, r, i, o, s) { let a; if ("**" === r.path) { const l = i.length > 0 ? oC(i).parameters : {}; a = H({ snapshot: new mc(i, l, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, $C(r), cn(r), r.component ?? r._loadedComponent ?? null, r, zC(r)), consumedSegments: [], remainingSegments: [] }), t.children = {} } else a = _j(t, r, i, n).pipe(re(({ matched: l, consumedSegments: c, remainingSegments: u, parameters: d }) => l ? { snapshot: new mc(c, d, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, $C(r), cn(r), r.component ?? r._loadedComponent ?? null, r, zC(r)), consumedSegments: c, remainingSegments: u } : null)); return a.pipe(Vt(l => null === l ? ao(t) : this.getChildConfig(n = r._injector ?? n, r, i).pipe(Vt(({ routes: c }) => { const u = r._loadedInjector ?? n, { snapshot: d, consumedSegments: p, remainingSegments: m } = l, { segmentGroup: v, slicedSegments: y } = UC(t, p, m, c); if (0 === y.length && v.hasChildren()) return this.processChildren(u, c, v).pipe(re(T => null === T ? null : [new qn(d, T)])); if (0 === c.length && 0 === y.length) return H([new qn(d, [])]); const C = cn(r) === o; return this.processSegment(u, c, v, y, C ? Y : o, !0).pipe(re(T => [new qn(d, T)])) })))) } getChildConfig(n, t, r) { return t.children ? H({ routes: t.children, injector: n }) : t.loadChildren ? void 0 !== t._loadedRoutes ? H({ routes: t._loadedRoutes, injector: t._loadedInjector }) : function fj(e, n, t, r) { const i = n.canLoad; return void 0 === i || 0 === i.length ? H(!0) : H(i.map(s => { const a = oo(s, e); return fr(function XL(e) { return e && Us(e.canLoad) }(a) ? a.canLoad(n, t) : e.runInContext(() => a(n, t))) })).pipe(so(), jC()) }(n, t, r).pipe(Ze(i => i ? this.configLoader.loadChildren(n, t).pipe(Ue(o => { t._loadedRoutes = o.routes, t._loadedInjector = o.injector })) : function gj(e) { return Ji(PC(!1, 3)) }())) : H({ routes: [], injector: n }) } } function Tj(e) { const n = e.value.routeConfig; return n && "" === n.path } function HC(e) { const n = [], t = new Set; for (const r of e) { if (!Tj(r)) { n.push(r); continue } const i = n.find(o => r.value.routeConfig === o.value.routeConfig); void 0 !== i ? (i.children.push(...r.children), t.add(i)) : n.push(r) } for (const r of t) { const i = HC(r.children); n.push(new qn(r.value, i)) } return n.filter(r => !t.has(r)) } function $C(e) { return e.data || {} } function zC(e) { return e.resolve || {} } function GC(e) { return "string" == typeof e.title || null === e.title } function Jh(e) { return Vt(n => { const t = e(n); return t ? He(t).pipe(re(() => n)) : H(n) }) } const lo = new A("ROUTES"); let ep = (() => { class e { constructor() { this.componentLoaders = new WeakMap, this.childrenLoaders = new WeakMap, this.compiler = O(T0) } loadComponent(t) { if (this.componentLoaders.get(t)) return this.componentLoaders.get(t); if (t._loadedComponent) return H(t._loadedComponent); this.onLoadStartListener && this.onLoadStartListener(t); const r = fr(t.loadComponent()).pipe(re(qC), Ue(o => { this.onLoadEndListener && this.onLoadEndListener(t), t._loadedComponent = o }), Yt(() => { this.componentLoaders.delete(t) })), i = new nC(r, () => new X).pipe(Oh()); return this.componentLoaders.set(t, i), i } loadChildren(t, r) { if (this.childrenLoaders.get(r)) return this.childrenLoaders.get(r); if (r._loadedRoutes) return H({ routes: r._loadedRoutes, injector: r._loadedInjector }); this.onLoadStartListener && this.onLoadStartListener(r); const o = function Nj(e, n, t, r) { return fr(e.loadChildren()).pipe(re(qC), Ze(i => i instanceof Nb || Array.isArray(i) ? H(i) : He(n.compileModuleAsync(i))), re(i => { r && r(e); let o, s, a = !1; return Array.isArray(i) ? (s = i, !0) : (o = i.create(t).injector, s = o.get(lo, [], { optional: !0, self: !0 }).flat()), { routes: s.map(Yh), injector: o } })) }(r, this.compiler, t, this.onLoadEndListener).pipe(Yt(() => { this.childrenLoaders.delete(r) })), s = new nC(o, () => new X).pipe(Oh()); return this.childrenLoaders.set(r, s), s } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); function qC(e) { return function Oj(e) { return e && "object" == typeof e && "default" in e }(e) ? e.default : e } let Cc = (() => { class e { get hasRequestedNavigation() { return 0 !== this.navigationId } constructor() { this.currentNavigation = null, this.currentTransition = null, this.lastSuccessfulNavigation = null, this.events = new X, this.transitionAbortSubject = new X, this.configLoader = O(ep), this.environmentInjector = O(Nt), this.urlSerializer = O(Ms), this.rootContexts = O(Os), this.inputBindingEnabled = null !== O(_c, { optional: !0 }), this.navigationId = 0, this.afterPreactivation = () => H(void 0), this.rootComponentType = null, this.configLoader.onLoadEndListener = i => this.events.next(new TL(i)), this.configLoader.onLoadStartListener = i => this.events.next(new SL(i)) } complete() { this.transitions?.complete() } handleNavigationRequest(t) { const r = ++this.navigationId; this.transitions?.next({ ...this.transitions.value, ...t, id: r }) } setupNavigations(t, r, i) { return this.transitions = new xt({ id: 0, currentUrlTree: r, currentRawUrl: r, currentBrowserUrl: r, extractedUrl: t.urlHandlingStrategy.extract(r), urlAfterRedirects: t.urlHandlingStrategy.extract(r), rawUrl: r, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: Ps, restoredState: null, currentSnapshot: i.snapshot, targetSnapshot: null, currentRouterState: i, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.transitions.pipe(an(o => 0 !== o.id), re(o => ({ ...o, extractedUrl: t.urlHandlingStrategy.extract(o.rawUrl) })), Vt(o => { this.currentTransition = o; let s = !1, a = !1; return H(o).pipe(Ue(l => { this.currentNavigation = { id: l.id, initialUrl: l.rawUrl, extractedUrl: l.extractedUrl, trigger: l.source, extras: l.extras, previousNavigation: this.lastSuccessfulNavigation ? { ...this.lastSuccessfulNavigation, previousNavigation: null } : null } }), Vt(l => { const c = l.currentBrowserUrl.toString(), u = !t.navigated || l.extractedUrl.toString() !== c || c !== l.currentUrlTree.toString(); if (!u && "reload" !== (l.extras.onSameUrlNavigation ?? t.onSameUrlNavigation)) { const p = ""; return this.events.next(new ro(l.id, this.urlSerializer.serialize(l.rawUrl), p, 0)), l.resolve(null), un } if (t.urlHandlingStrategy.shouldProcessUrl(l.rawUrl)) return H(l).pipe(Vt(p => { const m = this.transitions?.getValue(); return this.events.next(new pc(p.id, this.urlSerializer.serialize(p.extractedUrl), p.source, p.restoredState)), m !== this.transitions?.getValue() ? un : Promise.resolve(p) }), function xj(e, n, t, r, i, o) { return Ze(s => function Ej(e, n, t, r, i, o, s = "emptyOnly") { return new Ij(e, n, t, r, i, s, o).recognize() }(e, n, t, r, s.extractedUrl, i, o).pipe(re(({ state: a, tree: l }) => ({ ...s, targetSnapshot: a, urlAfterRedirects: l })))) }(this.environmentInjector, this.configLoader, this.rootComponentType, t.config, this.urlSerializer, t.paramsInheritanceStrategy), Ue(p => { o.targetSnapshot = p.targetSnapshot, o.urlAfterRedirects = p.urlAfterRedirects, this.currentNavigation = { ...this.currentNavigation, finalUrl: p.urlAfterRedirects }; const m = new wC(p.id, this.urlSerializer.serialize(p.extractedUrl), this.urlSerializer.serialize(p.urlAfterRedirects), p.targetSnapshot); this.events.next(m) })); if (u && t.urlHandlingStrategy.shouldProcessUrl(l.currentRawUrl)) { const { id: p, extractedUrl: m, source: v, restoredState: y, extras: C } = l, T = new pc(p, this.urlSerializer.serialize(m), v, y); this.events.next(T); const w = TC(0, this.rootComponentType).snapshot; return this.currentTransition = o = { ...l, targetSnapshot: w, urlAfterRedirects: m, extras: { ...C, skipLocationChange: !1, replaceUrl: !1 } }, H(o) } { const p = ""; return this.events.next(new ro(l.id, this.urlSerializer.serialize(l.extractedUrl), p, 1)), l.resolve(null), un } }), Ue(l => { const c = new CL(l.id, this.urlSerializer.serialize(l.extractedUrl), this.urlSerializer.serialize(l.urlAfterRedirects), l.targetSnapshot); this.events.next(c) }), re(l => (this.currentTransition = o = { ...l, guards: WL(l.targetSnapshot, l.currentSnapshot, this.rootContexts) }, o)), function ij(e, n) { return Ze(t => { const { targetSnapshot: r, currentSnapshot: i, guards: { canActivateChecks: o, canDeactivateChecks: s } } = t; return 0 === s.length && 0 === o.length ? H({ ...t, guardsResult: !0 }) : function oj(e, n, t, r) { return He(e).pipe(Ze(i => function dj(e, n, t, r, i) { const o = n && n.routeConfig ? n.routeConfig.canDeactivate : null; return o && 0 !== o.length ? H(o.map(a => { const l = js(n) ?? i, c = oo(a, l); return fr(function tj(e) { return e && Us(e.canDeactivate) }(c) ? c.canDeactivate(e, n, t, r) : l.runInContext(() => c(e, n, t, r))).pipe(Lr()) })).pipe(so()) : H(!0) }(i.component, i.route, t, n, r)), Lr(i => !0 !== i, !0)) }(s, r, i, e).pipe(Ze(a => a && function QL(e) { return "boolean" == typeof e }(a) ? function sj(e, n, t, r) { return He(n).pipe(eo(i => Nh(function lj(e, n) { return null !== e && n && n(new xL(e)), H(!0) }(i.route.parent, r), function aj(e, n) { return null !== e && n && n(new AL(e)), H(!0) }(i.route, r), function uj(e, n, t) { const r = n[n.length - 1], o = n.slice(0, n.length - 1).reverse().map(s => function ZL(e) { const n = e.routeConfig ? e.routeConfig.canActivateChild : null; return n && 0 !== n.length ? { node: e, guards: n } : null }(s)).filter(s => null !== s).map(s => tC(() => H(s.guards.map(l => { const c = js(s.node) ?? t, u = oo(l, c); return fr(function ej(e) { return e && Us(e.canActivateChild) }(u) ? u.canActivateChild(r, e) : c.runInContext(() => u(r, e))).pipe(Lr()) })).pipe(so()))); return H(o).pipe(so()) }(e, i.path, t), function cj(e, n, t) { const r = n.routeConfig ? n.routeConfig.canActivate : null; if (!r || 0 === r.length) return H(!0); const i = r.map(o => tC(() => { const s = js(n) ?? t, a = oo(o, s); return fr(function JL(e) { return e && Us(e.canActivate) }(a) ? a.canActivate(n, e) : s.runInContext(() => a(n, e))).pipe(Lr()) })); return H(i).pipe(so()) }(e, i.route, t))), Lr(i => !0 !== i, !0)) }(r, o, e, n) : H(a)), re(a => ({ ...t, guardsResult: a }))) }) }(this.environmentInjector, l => this.events.next(l)), Ue(l => { if (o.guardsResult = l.guardsResult, Vr(l.guardsResult)) throw RC(0, l.guardsResult); const c = new wL(l.id, this.urlSerializer.serialize(l.extractedUrl), this.urlSerializer.serialize(l.urlAfterRedirects), l.targetSnapshot, !!l.guardsResult); this.events.next(c) }), an(l => !!l.guardsResult || (this.cancelNavigationTransition(l, "", 3), !1)), Jh(l => { if (l.guards.canActivateChecks.length) return H(l).pipe(Ue(c => { const u = new EL(c.id, this.urlSerializer.serialize(c.extractedUrl), this.urlSerializer.serialize(c.urlAfterRedirects), c.targetSnapshot); this.events.next(u) }), Vt(c => { let u = !1; return H(c).pipe(function Mj(e, n) { return Ze(t => { const { targetSnapshot: r, guards: { canActivateChecks: i } } = t; if (!i.length) return H(t); let o = 0; return He(i).pipe(eo(s => function Aj(e, n, t, r) { const i = e.routeConfig, o = e._resolve; return void 0 !== i?.title && !GC(i) && (o[Ts] = i.title), function kj(e, n, t, r) { const i = function Rj(e) { return [...Object.keys(e), ...Object.getOwnPropertySymbols(e)] }(e); if (0 === i.length) return H({}); const o = {}; return He(i).pipe(Ze(s => function Pj(e, n, t, r) { const i = js(n) ?? r, o = oo(e, i); return fr(o.resolve ? o.resolve(n, t) : i.runInContext(() => o(n, t))) }(e[s], n, t, r).pipe(Lr(), Ue(a => { o[s] = a }))), Fh(1), function WF(e) { return re(() => e) }(o), dr(s => LC(s) ? un : Ji(s))) }(o, e, n, r).pipe(re(s => (e._resolvedData = s, e.data = xC(e, t).resolve, i && GC(i) && (e.data[Ts] = i.title), null))) }(s.route, r, e, n)), Ue(() => o++), Fh(1), Ze(s => o === i.length ? H(t) : un)) }) }(t.paramsInheritanceStrategy, this.environmentInjector), Ue({ next: () => u = !0, complete: () => { u || this.cancelNavigationTransition(c, "", 2) } })) }), Ue(c => { const u = new IL(c.id, this.urlSerializer.serialize(c.extractedUrl), this.urlSerializer.serialize(c.urlAfterRedirects), c.targetSnapshot); this.events.next(u) })) }), Jh(l => { const c = u => { const d = []; u.routeConfig?.loadComponent && !u.routeConfig._loadedComponent && d.push(this.configLoader.loadComponent(u.routeConfig).pipe(Ue(p => { u.component = p }), re(() => { }))); for (const p of u.children) d.push(...c(p)); return d }; return Ph(c(l.targetSnapshot.root)).pipe(ac(), Cn(1)) }), Jh(() => this.afterPreactivation()), re(l => { const c = function FL(e, n, t) { const r = Ls(e, n._root, t ? t._root : void 0); return new SC(r, n) }(t.routeReuseStrategy, l.targetSnapshot, l.currentRouterState); return this.currentTransition = o = { ...l, targetRouterState: c }, o }), Ue(() => { this.events.next(new Hh) }), ((e, n, t, r) => re(i => (new qL(n, i.targetRouterState, i.currentRouterState, t, r).activate(e), i)))(this.rootContexts, t.routeReuseStrategy, l => this.events.next(l), this.inputBindingEnabled), Cn(1), Ue({ next: l => { s = !0, this.lastSuccessfulNavigation = this.currentNavigation, this.events.next(new hr(l.id, this.urlSerializer.serialize(l.extractedUrl), this.urlSerializer.serialize(l.urlAfterRedirects))), t.titleStrategy?.updateTitle(l.targetRouterState.snapshot), l.resolve(!0) }, complete: () => { s = !0 } }), Ss(this.transitionAbortSubject.pipe(Ue(l => { throw l }))), Yt(() => { s || a || this.cancelNavigationTransition(o, "", 1), this.currentNavigation?.id === o.id && (this.currentNavigation = null) }), dr(l => { if (a = !0, NC(l)) this.events.next(new Ns(o.id, this.urlSerializer.serialize(o.extractedUrl), l.message, l.cancellationCode)), function VL(e) { return NC(e) && Vr(e.url) }(l) ? this.events.next(new $h(l.url)) : o.resolve(!1); else { this.events.next(new gc(o.id, this.urlSerializer.serialize(o.extractedUrl), l, o.targetSnapshot ?? void 0)); try { o.resolve(t.errorHandler(l)) } catch (c) { o.reject(c) } } return un })) })) } cancelNavigationTransition(t, r, i) { const o = new Ns(t.id, this.urlSerializer.serialize(t.extractedUrl), r, i); this.events.next(o), t.resolve(!1) } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); function WC(e) { return e !== Ps } let ZC = (() => { class e { buildTitle(t) { let r, i = t.root; for (; void 0 !== i;)r = this.getResolvedTitleForRoute(i) ?? r, i = i.children.find(o => o.outlet === Y); return r } getResolvedTitleForRoute(t) { return t.data[Ts] } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = F({ token: e, factory: function () { return O(Fj) }, providedIn: "root" }) } } return e })(), Fj = (() => { class e extends ZC { constructor(t) { super(), this.title = t } updateTitle(t) { const r = this.buildTitle(t); void 0 !== r && this.title.setTitle(r) } static { this.\u0275fac = function (r) { return new (r || e)(k(ZD)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(), Lj = (() => { class e { static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = F({ token: e, factory: function () { return O(Vj) }, providedIn: "root" }) } } return e })(); class jj { shouldDetach(n) { return !1 } store(n, t) { } shouldAttach(n) { return !1 } retrieve(n) { return null } shouldReuseRoute(n, t) { return n.routeConfig === t.routeConfig } } let Vj = (() => { class e extends jj { static { this.\u0275fac = function () { let t; return function (i) { return (t || (t = et(e)))(i || e) } }() } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); const wc = new A("", { providedIn: "root", factory: () => ({}) }); let Bj = (() => { class e { static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = F({ token: e, factory: function () { return O(Uj) }, providedIn: "root" }) } } return e })(), Uj = (() => { class e { shouldProcessUrl(t) { return !0 } extract(t) { return t } merge(t, r) { return t } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); var Hs = function (e) { return e[e.COMPLETE = 0] = "COMPLETE", e[e.FAILED = 1] = "FAILED", e[e.REDIRECTING = 2] = "REDIRECTING", e }(Hs || {}); function KC(e, n) { e.events.pipe(an(t => t instanceof hr || t instanceof Ns || t instanceof gc || t instanceof ro), re(t => t instanceof hr || t instanceof ro ? Hs.COMPLETE : t instanceof Ns && (0 === t.code || 1 === t.code) ? Hs.REDIRECTING : Hs.FAILED), an(t => t !== Hs.REDIRECTING), Cn(1)).subscribe(() => { n() }) } function Hj(e) { throw e } function $j(e, n, t) { return n.parse("/") } const zj = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, Gj = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }; let Re = (() => { class e { get navigationId() { return this.navigationTransitions.navigationId } get browserPageId() { return "computed" !== this.canceledNavigationResolution ? this.currentPageId : this.location.getState()?.\u0275routerPageId ?? this.currentPageId } get events() { return this._events } constructor() { this.disposed = !1, this.currentPageId = 0, this.console = O(S0), this.isNgZoneEnabled = !1, this._events = new X, this.options = O(wc, { optional: !0 }) || {}, this.pendingTasks = O(Fl), this.errorHandler = this.options.errorHandler || Hj, this.malformedUriErrorHandler = this.options.malformedUriErrorHandler || $j, this.navigated = !1, this.lastSuccessfulId = -1, this.urlHandlingStrategy = O(Bj), this.routeReuseStrategy = O(Lj), this.titleStrategy = O(ZC), this.onSameUrlNavigation = this.options.onSameUrlNavigation || "ignore", this.paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || "emptyOnly", this.urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred", this.canceledNavigationResolution = this.options.canceledNavigationResolution || "replace", this.config = O(lo, { optional: !0 })?.flat() ?? [], this.navigationTransitions = O(Cc), this.urlSerializer = O(Ms), this.location = O(zl), this.componentInputBindingEnabled = !!O(_c, { optional: !0 }), this.eventsSubscription = new Pe, this.isNgZoneEnabled = O(le) instanceof le && le.isInAngularZone(), this.resetConfig(this.config), this.currentUrlTree = new no, this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.routerState = TC(0, null), this.navigationTransitions.setupNavigations(this, this.currentUrlTree, this.routerState).subscribe(t => { this.lastSuccessfulId = t.id, this.currentPageId = this.browserPageId }, t => { this.console.warn(`Unhandled Navigation Error: ${t}`) }), this.subscribeToNavigationEvents() } subscribeToNavigationEvents() { const t = this.navigationTransitions.events.subscribe(r => { try { const { currentTransition: i } = this.navigationTransitions; if (null === i) return void (YC(r) && this._events.next(r)); if (r instanceof pc) WC(i.source) && (this.browserUrlTree = i.extractedUrl); else if (r instanceof ro) this.rawUrlTree = i.rawUrl; else if (r instanceof wC) { if ("eager" === this.urlUpdateStrategy) { if (!i.extras.skipLocationChange) { const o = this.urlHandlingStrategy.merge(i.urlAfterRedirects, i.rawUrl); this.setBrowserUrl(o, i) } this.browserUrlTree = i.urlAfterRedirects } } else if (r instanceof Hh) this.currentUrlTree = i.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(i.urlAfterRedirects, i.rawUrl), this.routerState = i.targetRouterState, "deferred" === this.urlUpdateStrategy && (i.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, i), this.browserUrlTree = i.urlAfterRedirects); else if (r instanceof Ns) 0 !== r.code && 1 !== r.code && (this.navigated = !0), (3 === r.code || 2 === r.code) && this.restoreHistory(i); else if (r instanceof $h) { const o = this.urlHandlingStrategy.merge(r.url, i.currentRawUrl), s = { skipLocationChange: i.extras.skipLocationChange, replaceUrl: "eager" === this.urlUpdateStrategy || WC(i.source) }; this.scheduleNavigation(o, Ps, null, s, { resolve: i.resolve, reject: i.reject, promise: i.promise }) } r instanceof gc && this.restoreHistory(i, !0), r instanceof hr && (this.navigated = !0), YC(r) && this._events.next(r) } catch (i) { this.navigationTransitions.transitionAbortSubject.next(i) } }); this.eventsSubscription.add(t) } resetRootComponentType(t) { this.routerState.root.component = t, this.navigationTransitions.rootComponentType = t } initialNavigation() { if (this.setUpLocationChangeListener(), !this.navigationTransitions.hasRequestedNavigation) { const t = this.location.getState(); this.navigateToSyncWithBrowser(this.location.path(!0), Ps, t) } } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(t => { const r = "popstate" === t.type ? "popstate" : "hashchange"; "popstate" === r && setTimeout(() => { this.navigateToSyncWithBrowser(t.url, r, t.state) }, 0) })) } navigateToSyncWithBrowser(t, r, i) { const o = { replaceUrl: !0 }, s = i?.navigationId ? i : null; if (i) { const l = { ...i }; delete l.navigationId, delete l.\u0275routerPageId, 0 !== Object.keys(l).length && (o.state = l) } const a = this.parseUrl(t); this.scheduleNavigation(a, r, s, o) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.navigationTransitions.currentNavigation } get lastSuccessfulNavigation() { return this.navigationTransitions.lastSuccessfulNavigation } resetConfig(t) { this.config = t.map(Yh), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.navigationTransitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0, this.eventsSubscription.unsubscribe() } createUrlTree(t, r = {}) { const { relativeTo: i, queryParams: o, fragment: s, queryParamsHandling: a, preserveFragment: l } = r, c = l ? this.currentUrlTree.fragment : s; let d, u = null; switch (a) { case "merge": u = { ...this.currentUrlTree.queryParams, ...o }; break; case "preserve": u = this.currentUrlTree.queryParams; break; default: u = o || null }null !== u && (u = this.removeEmptyProps(u)); try { d = mC(i ? i.snapshot : this.routerState.snapshot.root) } catch { ("string" != typeof t[0] || !t[0].startsWith("/")) && (t = []), d = this.currentUrlTree.root } return _C(d, t, u, c ?? null) } navigateByUrl(t, r = { skipLocationChange: !1 }) { const i = Vr(t) ? t : this.parseUrl(t), o = this.urlHandlingStrategy.merge(i, this.rawUrlTree); return this.scheduleNavigation(o, Ps, null, r) } navigate(t, r = { skipLocationChange: !1 }) { return function qj(e) { for (let n = 0; n < e.length; n++)if (null == e[n]) throw new x(4008, !1) }(t), this.navigateByUrl(this.createUrlTree(t, r), r) } serializeUrl(t) { return this.urlSerializer.serialize(t) } parseUrl(t) { let r; try { r = this.urlSerializer.parse(t) } catch (i) { r = this.malformedUriErrorHandler(i, this.urlSerializer, t) } return r } isActive(t, r) { let i; if (i = !0 === r ? { ...zj } : !1 === r ? { ...Gj } : r, Vr(t)) return aC(this.currentUrlTree, t, i); const o = this.parseUrl(t); return aC(this.currentUrlTree, o, i) } removeEmptyProps(t) { return Object.keys(t).reduce((r, i) => { const o = t[i]; return null != o && (r[i] = o), r }, {}) } scheduleNavigation(t, r, i, o, s) { if (this.disposed) return Promise.resolve(!1); let a, l, c; s ? (a = s.resolve, l = s.reject, c = s.promise) : c = new Promise((d, p) => { a = d, l = p }); const u = this.pendingTasks.add(); return KC(this, () => { queueMicrotask(() => this.pendingTasks.remove(u)) }), this.navigationTransitions.handleNavigationRequest({ source: r, restoredState: i, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, currentBrowserUrl: this.browserUrlTree, rawUrl: t, extras: o, resolve: a, reject: l, promise: c, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), c.catch(d => Promise.reject(d)) } setBrowserUrl(t, r) { const i = this.urlSerializer.serialize(t); if (this.location.isCurrentPathEqualTo(i) || r.extras.replaceUrl) { const s = { ...r.extras.state, ...this.generateNgRouterState(r.id, this.browserPageId) }; this.location.replaceState(i, "", s) } else { const o = { ...r.extras.state, ...this.generateNgRouterState(r.id, this.browserPageId + 1) }; this.location.go(i, "", o) } } restoreHistory(t, r = !1) { if ("computed" === this.canceledNavigationResolution) { const o = this.currentPageId - this.browserPageId; 0 !== o ? this.location.historyGo(o) : this.currentUrlTree === this.getCurrentNavigation()?.finalUrl && 0 === o && (this.resetState(t), this.browserUrlTree = t.currentUrlTree, this.resetUrlToCurrentUrlTree()) } else "replace" === this.canceledNavigationResolution && (r && this.resetState(t), this.resetUrlToCurrentUrlTree()) } resetState(t) { this.routerState = t.currentRouterState, this.currentUrlTree = t.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, t.rawUrl) } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)) } generateNgRouterState(t, r) { return "computed" === this.canceledNavigationResolution ? { navigationId: t, \u0275routerPageId: r } : { navigationId: t } } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); function YC(e) { return !(e instanceof Hh || e instanceof $h) } let In = (() => { class e { constructor(t, r, i, o, s, a) { this.router = t, this.route = r, this.tabIndexAttribute = i, this.renderer = o, this.el = s, this.locationStrategy = a, this.href = null, this.commands = null, this.onChanges = new X, this.preserveFragment = !1, this.skipLocationChange = !1, this.replaceUrl = !1; const l = s.nativeElement.tagName?.toLowerCase(); this.isAnchorElement = "a" === l || "area" === l, this.isAnchorElement ? this.subscription = t.events.subscribe(c => { c instanceof hr && this.updateHref() }) : this.setTabIndexIfNotOnNativeEl("0") } setTabIndexIfNotOnNativeEl(t) { null != this.tabIndexAttribute || this.isAnchorElement || this.applyAttributeValue("tabindex", t) } ngOnChanges(t) { this.isAnchorElement && this.updateHref(), this.onChanges.next(this) } set routerLink(t) { null != t ? (this.commands = Array.isArray(t) ? t : [t], this.setTabIndexIfNotOnNativeEl("0")) : (this.commands = null, this.setTabIndexIfNotOnNativeEl(null)) } onClick(t, r, i, o, s) { return !!(null === this.urlTree || this.isAnchorElement && (0 !== t || r || i || o || s || "string" == typeof this.target && "_self" != this.target)) || (this.router.navigateByUrl(this.urlTree, { skipLocationChange: this.skipLocationChange, replaceUrl: this.replaceUrl, state: this.state }), !this.isAnchorElement) } ngOnDestroy() { this.subscription?.unsubscribe() } updateHref() { this.href = null !== this.urlTree && this.locationStrategy ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) : null; const t = null === this.href ? null : function j_(e, n, t) { return function Px(e, n) { return "src" === n && ("embed" === e || "frame" === e || "iframe" === e || "media" === e || "script" === e) || "href" === n && ("base" === e || "link" === e) ? L_ : F_ }(n, t)(e) }(this.href, this.el.nativeElement.tagName.toLowerCase(), "href"); this.applyAttributeValue("href", t) } applyAttributeValue(t, r) { const i = this.renderer, o = this.el.nativeElement; null !== r ? i.setAttribute(o, t, r) : i.removeAttribute(o, t) } get urlTree() { return null === this.commands ? null : this.router.createUrlTree(this.commands, { relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: this.preserveFragment }) } static { this.\u0275fac = function (r) { return new (r || e)(D(Re), D(ln), function Fa(e) { return function JS(e, n) { if ("class" === n) return e.classes; if ("style" === n) return e.styles; const t = e.attrs; if (t) { const r = t.length; let i = 0; for (; i < r;) { const o = t[i]; if (Ag(o)) break; if (0 === o) i += 2; else if ("number" == typeof o) for (i++; i < r && "string" == typeof t[i];)i++; else { if (o === n) return t[i + 1]; i += 2 } } } return null }(Je(), e) }("tabindex"), D(Ln), D(tt), D(Or)) } } static { this.\u0275dir = j({ type: e, selectors: [["", "routerLink", ""]], hostVars: 1, hostBindings: function (r, i) { 1 & r && R("click", function (s) { return i.onClick(s.button, s.ctrlKey, s.shiftKey, s.altKey, s.metaKey) }), 2 & r && nt("target", i.target) }, inputs: { target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", state: "state", relativeTo: "relativeTo", preserveFragment: ["preserveFragment", "preserveFragment", Yi], skipLocationChange: ["skipLocationChange", "skipLocationChange", Yi], replaceUrl: ["replaceUrl", "replaceUrl", Yi], routerLink: "routerLink" }, standalone: !0, features: [Qv, kt] }) } } return e })(), QC = (() => { class e { get isActive() { return this._isActive } constructor(t, r, i, o, s) { this.router = t, this.element = r, this.renderer = i, this.cdr = o, this.link = s, this.classes = [], this._isActive = !1, this.routerLinkActiveOptions = { exact: !1 }, this.isActiveChange = new se, this.routerEventsSubscription = t.events.subscribe(a => { a instanceof hr && this.update() }) } ngAfterContentInit() { H(this.links.changes, H(null)).pipe(Qr()).subscribe(t => { this.update(), this.subscribeToEachLinkOnChanges() }) } subscribeToEachLinkOnChanges() { this.linkInputChangesSubscription?.unsubscribe(); const t = [...this.links.toArray(), this.link].filter(r => !!r).map(r => r.onChanges); this.linkInputChangesSubscription = He(t).pipe(Qr()).subscribe(r => { this._isActive !== this.isLinkActive(this.router)(r) && this.update() }) } set routerLinkActive(t) { const r = Array.isArray(t) ? t : t.split(" "); this.classes = r.filter(i => !!i) } ngOnChanges(t) { this.update() } ngOnDestroy() { this.routerEventsSubscription.unsubscribe(), this.linkInputChangesSubscription?.unsubscribe() } update() { !this.links || !this.router.navigated || queueMicrotask(() => { const t = this.hasActiveLinks(); this._isActive !== t && (this._isActive = t, this.cdr.markForCheck(), this.classes.forEach(r => { t ? this.renderer.addClass(this.element.nativeElement, r) : this.renderer.removeClass(this.element.nativeElement, r) }), t && void 0 !== this.ariaCurrentWhenActive ? this.renderer.setAttribute(this.element.nativeElement, "aria-current", this.ariaCurrentWhenActive.toString()) : this.renderer.removeAttribute(this.element.nativeElement, "aria-current"), this.isActiveChange.emit(t)) }) } isLinkActive(t) { const r = function Wj(e) { return !!e.paths }(this.routerLinkActiveOptions) ? this.routerLinkActiveOptions : this.routerLinkActiveOptions.exact || !1; return i => !!i.urlTree && t.isActive(i.urlTree, r) } hasActiveLinks() { const t = this.isLinkActive(this.router); return this.link && t(this.link) || this.links.some(t) } static { this.\u0275fac = function (r) { return new (r || e)(D(Re), D(tt), D(Ln), D(Pr), D(In, 8)) } } static { this.\u0275dir = j({ type: e, selectors: [["", "routerLinkActive", ""]], contentQueries: function (r, i, o) { if (1 & r && vs(o, In, 5), 2 & r) { let s; Gi(s = qi()) && (i.links = s) } }, inputs: { routerLinkActiveOptions: "routerLinkActiveOptions", ariaCurrentWhenActive: "ariaCurrentWhenActive", routerLinkActive: "routerLinkActive" }, outputs: { isActiveChange: "isActiveChange" }, exportAs: ["routerLinkActive"], standalone: !0, features: [kt] }) } } return e })(); class XC { } let Zj = (() => { class e { constructor(t, r, i, o, s) { this.router = t, this.injector = i, this.preloadingStrategy = o, this.loader = s } setUpPreloading() { this.subscription = this.router.events.pipe(an(t => t instanceof hr), eo(() => this.preload())).subscribe(() => { }) } preload() { return this.processRoutes(this.injector, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(t, r) { const i = []; for (const o of r) { o.providers && !o._injector && (o._injector = Tf(o.providers, t, `Route: ${o.path}`)); const s = o._injector ?? t, a = o._loadedInjector ?? s; (o.loadChildren && !o._loadedRoutes && void 0 === o.canLoad || o.loadComponent && !o._loadedComponent) && i.push(this.preloadConfig(s, o)), (o.children || o._loadedRoutes) && i.push(this.processRoutes(a, o.children ?? o._loadedRoutes)) } return He(i).pipe(Qr()) } preloadConfig(t, r) { return this.preloadingStrategy.preload(r, () => { let i; i = r.loadChildren && void 0 === r.canLoad ? this.loader.loadChildren(t, r) : H(null); const o = i.pipe(Ze(s => null === s ? H(void 0) : (r._loadedRoutes = s.routes, r._loadedInjector = s.injector, this.processRoutes(s.injector ?? t, s.routes)))); return r.loadComponent && !r._loadedComponent ? He([o, this.loader.loadComponent(r)]).pipe(Qr()) : o }) } static { this.\u0275fac = function (r) { return new (r || e)(k(Re), k(T0), k(Nt), k(XC), k(ep)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); const tp = new A(""); let JC = (() => { class e { constructor(t, r, i, o, s = {}) { this.urlSerializer = t, this.transitions = r, this.viewportScroller = i, this.zone = o, this.options = s, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, s.scrollPositionRestoration = s.scrollPositionRestoration || "disabled", s.anchorScrolling = s.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.transitions.events.subscribe(t => { t instanceof pc ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = t.navigationTrigger, this.restoredId = t.restoredState ? t.restoredState.navigationId : 0) : t instanceof hr ? (this.lastId = t.id, this.scheduleScrollEvent(t, this.urlSerializer.parse(t.urlAfterRedirects).fragment)) : t instanceof ro && 0 === t.code && (this.lastSource = void 0, this.restoredId = 0, this.scheduleScrollEvent(t, this.urlSerializer.parse(t.url).fragment)) }) } consumeScrollEvents() { return this.transitions.events.subscribe(t => { t instanceof EC && (t.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(t.position) : t.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(t.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(t, r) { this.zone.runOutsideAngular(() => { setTimeout(() => { this.zone.run(() => { this.transitions.events.next(new EC(t, "popstate" === this.lastSource ? this.store[this.restoredId] : null, r)) }) }, 0) }) } ngOnDestroy() { this.routerEventsSubscription?.unsubscribe(), this.scrollEventsSubscription?.unsubscribe() } static { this.\u0275fac = function (r) { !function Ev() { throw new Error("invalid") }() } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac }) } } return e })(); function Wn(e, n) { return { \u0275kind: e, \u0275providers: n } } function tw() { const e = O(Ot); return n => { const t = e.get(Ki); if (n !== t.components[0]) return; const r = e.get(Re), i = e.get(nw); 1 === e.get(np) && r.initialNavigation(), e.get(rw, null, J.Optional)?.setUpPreloading(), e.get(tp, null, J.Optional)?.init(), r.resetRootComponentType(t.componentTypes[0]), i.closed || (i.next(), i.complete(), i.unsubscribe()) } } const nw = new A("", { factory: () => new X }), np = new A("", { providedIn: "root", factory: () => 1 }), rw = new A(""); function Xj(e) { return Wn(0, [{ provide: rw, useExisting: Zj }, { provide: XC, useExisting: e }]) } const iw = new A("ROUTER_FORROOT_GUARD"), e3 = [zl, { provide: Ms, useClass: Lh }, Re, Os, { provide: ln, useFactory: function ew(e) { return e.routerState.root }, deps: [Re] }, ep, []]; function t3() { return new N0("Router", Re) } let ow = (() => { class e { constructor(t) { } static forRoot(t, r) { return { ngModule: e, providers: [e3, [], { provide: lo, multi: !0, useValue: t }, { provide: iw, useFactory: o3, deps: [[Re, new Va, new Ba]] }, { provide: wc, useValue: r || {} }, r?.useHash ? { provide: Or, useClass: gO } : { provide: Or, useClass: dD }, { provide: tp, useFactory: () => { const e = O(P2), n = O(le), t = O(wc), r = O(Cc), i = O(Ms); return t.scrollOffset && e.setOffset(t.scrollOffset), new JC(i, r, e, n, t) } }, r?.preloadingStrategy ? Xj(r.preloadingStrategy).\u0275providers : [], { provide: N0, multi: !0, useFactory: t3 }, r?.initialNavigation ? s3(r) : [], r?.bindToComponentInputs ? Wn(8, [kC, { provide: _c, useExisting: kC }]).\u0275providers : [], [{ provide: sw, useFactory: tw }, { provide: Yf, multi: !0, useExisting: sw }]] } } static forChild(t) { return { ngModule: e, providers: [{ provide: lo, multi: !0, useValue: t }] } } static { this.\u0275fac = function (r) { return new (r || e)(k(iw, 8)) } } static { this.\u0275mod = bt({ type: e }) } static { this.\u0275inj = ct({}) } } return e })(); function o3(e) { return "guarded" } function s3(e) { return ["disabled" === e.initialNavigation ? Wn(3, [{ provide: Hf, multi: !0, useFactory: () => { const n = O(Re); return () => { n.setUpLocationChangeListener() } } }, { provide: np, useValue: 2 }]).\u0275providers : [], "enabledBlocking" === e.initialNavigation ? Wn(2, [{ provide: np, useValue: 0 }, { provide: Hf, multi: !0, deps: [Ot], useFactory: n => { const t = n.get(hO, Promise.resolve()); return () => t.then(() => new Promise(r => { const i = n.get(Re), o = n.get(nw); KC(i, () => { r(!0) }), n.get(Cc).afterPreactivation = () => (r(!0), o.closed ? H(void 0) : o), i.initialNavigation() })) } }]).\u0275providers : []] } const sw = new A(""); class Ec { } class Ic { } class Sn { constructor(n) { this.normalizedNames = new Map, this.lazyUpdate = null, n ? "string" == typeof n ? this.lazyInit = () => { this.headers = new Map, n.split("\n").forEach(t => { const r = t.indexOf(":"); if (r > 0) { const i = t.slice(0, r), o = i.toLowerCase(), s = t.slice(r + 1).trim(); this.maybeSetNormalizedName(i, o), this.headers.has(o) ? this.headers.get(o).push(s) : this.headers.set(o, [s]) } }) } : typeof Headers < "u" && n instanceof Headers ? (this.headers = new Map, n.forEach((t, r) => { this.setHeaderEntries(r, t) })) : this.lazyInit = () => { this.headers = new Map, Object.entries(n).forEach(([t, r]) => { this.setHeaderEntries(t, r) }) } : this.headers = new Map } has(n) { return this.init(), this.headers.has(n.toLowerCase()) } get(n) { this.init(); const t = this.headers.get(n.toLowerCase()); return t && t.length > 0 ? t[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(n) { return this.init(), this.headers.get(n.toLowerCase()) || null } append(n, t) { return this.clone({ name: n, value: t, op: "a" }) } set(n, t) { return this.clone({ name: n, value: t, op: "s" }) } delete(n, t) { return this.clone({ name: n, value: t, op: "d" }) } maybeSetNormalizedName(n, t) { this.normalizedNames.has(t) || this.normalizedNames.set(t, n) } init() { this.lazyInit && (this.lazyInit instanceof Sn ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(n => this.applyUpdate(n)), this.lazyUpdate = null)) } copyFrom(n) { n.init(), Array.from(n.headers.keys()).forEach(t => { this.headers.set(t, n.headers.get(t)), this.normalizedNames.set(t, n.normalizedNames.get(t)) }) } clone(n) { const t = new Sn; return t.lazyInit = this.lazyInit && this.lazyInit instanceof Sn ? this.lazyInit : this, t.lazyUpdate = (this.lazyUpdate || []).concat([n]), t } applyUpdate(n) { const t = n.name.toLowerCase(); switch (n.op) { case "a": case "s": let r = n.value; if ("string" == typeof r && (r = [r]), 0 === r.length) return; this.maybeSetNormalizedName(n.name, t); const i = ("a" === n.op ? this.headers.get(t) : void 0) || []; i.push(...r), this.headers.set(t, i); break; case "d": const o = n.value; if (o) { let s = this.headers.get(t); if (!s) return; s = s.filter(a => -1 === o.indexOf(a)), 0 === s.length ? (this.headers.delete(t), this.normalizedNames.delete(t)) : this.headers.set(t, s) } else this.headers.delete(t), this.normalizedNames.delete(t) } } setHeaderEntries(n, t) { const r = (Array.isArray(t) ? t : [t]).map(o => o.toString()), i = n.toLowerCase(); this.headers.set(i, r), this.maybeSetNormalizedName(n, i) } forEach(n) { this.init(), Array.from(this.normalizedNames.keys()).forEach(t => n(this.normalizedNames.get(t), this.headers.get(t))) } } class l3 { encodeKey(n) { return aw(n) } encodeValue(n) { return aw(n) } decodeKey(n) { return decodeURIComponent(n) } decodeValue(n) { return decodeURIComponent(n) } } const u3 = /%(\d[a-f0-9])/gi, d3 = { 40: "@", "3A": ":", 24: "$", "2C": ",", "3B": ";", "3D": "=", "3F": "?", "2F": "/" }; function aw(e) { return encodeURIComponent(e).replace(u3, (n, t) => d3[t] ?? n) } function Sc(e) { return `${e}` } class Zn { constructor(n = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = n.encoder || new l3, n.fromString) { if (n.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function c3(e, n) { const t = new Map; return e.length > 0 && e.replace(/^\?/, "").split("&").forEach(i => { const o = i.indexOf("="), [s, a] = -1 == o ? [n.decodeKey(i), ""] : [n.decodeKey(i.slice(0, o)), n.decodeValue(i.slice(o + 1))], l = t.get(s) || []; l.push(a), t.set(s, l) }), t }(n.fromString, this.encoder) } else n.fromObject ? (this.map = new Map, Object.keys(n.fromObject).forEach(t => { const r = n.fromObject[t], i = Array.isArray(r) ? r.map(Sc) : [Sc(r)]; this.map.set(t, i) })) : this.map = null } has(n) { return this.init(), this.map.has(n) } get(n) { this.init(); const t = this.map.get(n); return t ? t[0] : null } getAll(n) { return this.init(), this.map.get(n) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(n, t) { return this.clone({ param: n, value: t, op: "a" }) } appendAll(n) { const t = []; return Object.keys(n).forEach(r => { const i = n[r]; Array.isArray(i) ? i.forEach(o => { t.push({ param: r, value: o, op: "a" }) }) : t.push({ param: r, value: i, op: "a" }) }), this.clone(t) } set(n, t) { return this.clone({ param: n, value: t, op: "s" }) } delete(n, t) { return this.clone({ param: n, value: t, op: "d" }) } toString() { return this.init(), this.keys().map(n => { const t = this.encoder.encodeKey(n); return this.map.get(n).map(r => t + "=" + this.encoder.encodeValue(r)).join("&") }).filter(n => "" !== n).join("&") } clone(n) { const t = new Zn({ encoder: this.encoder }); return t.cloneFrom = this.cloneFrom || this, t.updates = (this.updates || []).concat(n), t } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(n => this.map.set(n, this.cloneFrom.map.get(n))), this.updates.forEach(n => { switch (n.op) { case "a": case "s": const t = ("a" === n.op ? this.map.get(n.param) : void 0) || []; t.push(Sc(n.value)), this.map.set(n.param, t); break; case "d": if (void 0 === n.value) { this.map.delete(n.param); break } { let r = this.map.get(n.param) || []; const i = r.indexOf(Sc(n.value)); -1 !== i && r.splice(i, 1), r.length > 0 ? this.map.set(n.param, r) : this.map.delete(n.param) } } }), this.cloneFrom = this.updates = null) } } class f3 { constructor() { this.map = new Map } set(n, t) { return this.map.set(n, t), this } get(n) { return this.map.has(n) || this.map.set(n, n.defaultValue()), this.map.get(n) } delete(n) { return this.map.delete(n), this } has(n) { return this.map.has(n) } keys() { return this.map.keys() } } function lw(e) { return typeof ArrayBuffer < "u" && e instanceof ArrayBuffer } function cw(e) { return typeof Blob < "u" && e instanceof Blob } function uw(e) { return typeof FormData < "u" && e instanceof FormData } class $s { constructor(n, t, r, i) { let o; if (this.url = t, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = n.toUpperCase(), function h3(e) { switch (e) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || i ? (this.body = void 0 !== r ? r : null, o = i) : o = r, o && (this.reportProgress = !!o.reportProgress, this.withCredentials = !!o.withCredentials, o.responseType && (this.responseType = o.responseType), o.headers && (this.headers = o.headers), o.context && (this.context = o.context), o.params && (this.params = o.params)), this.headers || (this.headers = new Sn), this.context || (this.context = new f3), this.params) { const s = this.params.toString(); if (0 === s.length) this.urlWithParams = t; else { const a = t.indexOf("?"); this.urlWithParams = t + (-1 === a ? "?" : a < t.length - 1 ? "&" : "") + s } } else this.params = new Zn, this.urlWithParams = t } serializeBody() { return null === this.body ? null : lw(this.body) || cw(this.body) || uw(this.body) || function p3(e) { return typeof URLSearchParams < "u" && e instanceof URLSearchParams }(this.body) || "string" == typeof this.body ? this.body : this.body instanceof Zn ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || uw(this.body) ? null : cw(this.body) ? this.body.type || null : lw(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof Zn ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body ? "application/json" : null } clone(n = {}) { const t = n.method || this.method, r = n.url || this.url, i = n.responseType || this.responseType, o = void 0 !== n.body ? n.body : this.body, s = void 0 !== n.withCredentials ? n.withCredentials : this.withCredentials, a = void 0 !== n.reportProgress ? n.reportProgress : this.reportProgress; let l = n.headers || this.headers, c = n.params || this.params; const u = n.context ?? this.context; return void 0 !== n.setHeaders && (l = Object.keys(n.setHeaders).reduce((d, p) => d.set(p, n.setHeaders[p]), l)), n.setParams && (c = Object.keys(n.setParams).reduce((d, p) => d.set(p, n.setParams[p]), c)), new $s(t, r, o, { params: c, headers: l, context: u, reportProgress: a, responseType: i, withCredentials: s }) } } var co = function (e) { return e[e.Sent = 0] = "Sent", e[e.UploadProgress = 1] = "UploadProgress", e[e.ResponseHeader = 2] = "ResponseHeader", e[e.DownloadProgress = 3] = "DownloadProgress", e[e.Response = 4] = "Response", e[e.User = 5] = "User", e }(co || {}); class rp { constructor(n, t = 200, r = "OK") { this.headers = n.headers || new Sn, this.status = void 0 !== n.status ? n.status : t, this.statusText = n.statusText || r, this.url = n.url || null, this.ok = this.status >= 200 && this.status < 300 } } class ip extends rp { constructor(n = {}) { super(n), this.type = co.ResponseHeader } clone(n = {}) { return new ip({ headers: n.headers || this.headers, status: void 0 !== n.status ? n.status : this.status, statusText: n.statusText || this.statusText, url: n.url || this.url || void 0 }) } } class uo extends rp { constructor(n = {}) { super(n), this.type = co.Response, this.body = void 0 !== n.body ? n.body : null } clone(n = {}) { return new uo({ body: void 0 !== n.body ? n.body : this.body, headers: n.headers || this.headers, status: void 0 !== n.status ? n.status : this.status, statusText: n.statusText || this.statusText, url: n.url || this.url || void 0 }) } } class dw extends rp { constructor(n) { super(n, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${n.url || "(unknown url)"}` : `Http failure response for ${n.url || "(unknown url)"}: ${n.status} ${n.statusText}`, this.error = n.error || null } } function op(e, n) { return { body: n, headers: e.headers, context: e.context, observe: e.observe, params: e.params, reportProgress: e.reportProgress, responseType: e.responseType, withCredentials: e.withCredentials } } let sp = (() => { class e { constructor(t) { this.handler = t } request(t, r, i = {}) { let o; if (t instanceof $s) o = t; else { let l, c; l = i.headers instanceof Sn ? i.headers : new Sn(i.headers), i.params && (c = i.params instanceof Zn ? i.params : new Zn({ fromObject: i.params })), o = new $s(t, r, void 0 !== i.body ? i.body : null, { headers: l, context: i.context, params: c, reportProgress: i.reportProgress, responseType: i.responseType || "json", withCredentials: i.withCredentials }) } const s = H(o).pipe(eo(l => this.handler.handle(l))); if (t instanceof $s || "events" === i.observe) return s; const a = s.pipe(an(l => l instanceof uo)); switch (i.observe || "body") { case "body": switch (o.responseType) { case "arraybuffer": return a.pipe(re(l => { if (null !== l.body && !(l.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return l.body })); case "blob": return a.pipe(re(l => { if (null !== l.body && !(l.body instanceof Blob)) throw new Error("Response is not a Blob."); return l.body })); case "text": return a.pipe(re(l => { if (null !== l.body && "string" != typeof l.body) throw new Error("Response is not a string."); return l.body })); default: return a.pipe(re(l => l.body)) }case "response": return a; default: throw new Error(`Unreachable: unhandled observe type ${i.observe}}`) } } delete(t, r = {}) { return this.request("DELETE", t, r) } get(t, r = {}) { return this.request("GET", t, r) } head(t, r = {}) { return this.request("HEAD", t, r) } jsonp(t, r) { return this.request("JSONP", t, { params: (new Zn).append(r, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(t, r = {}) { return this.request("OPTIONS", t, r) } patch(t, r, i = {}) { return this.request("PATCH", t, op(i, r)) } post(t, r, i = {}) { return this.request("POST", t, op(i, r)) } put(t, r, i = {}) { return this.request("PUT", t, op(i, r)) } static { this.\u0275fac = function (r) { return new (r || e)(k(Ec)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac }) } } return e })(); function pw(e, n) { return n(e) } function m3(e, n) { return (t, r) => n.intercept(t, { handle: i => e(i, r) }) } const ap = new A(""), zs = new A(""), gw = new A(""); function v3() { let e = null; return (n, t) => { null === e && (e = (O(ap, { optional: !0 }) ?? []).reduceRight(m3, pw)); const r = O(Fl), i = r.add(); return e(n, t).pipe(Yt(() => r.remove(i))) } } let mw = (() => { class e extends Ec { constructor(t, r) { super(), this.backend = t, this.injector = r, this.chain = null, this.pendingTasks = O(Fl) } handle(t) { if (null === this.chain) { const i = Array.from(new Set([...this.injector.get(zs), ...this.injector.get(gw, [])])); this.chain = i.reduceRight((o, s) => function _3(e, n, t) { return (r, i) => t.runInContext(() => n(r, o => e(o, i))) }(o, s, this.injector), pw) } const r = this.pendingTasks.add(); return this.chain(t, i => this.backend.handle(i)).pipe(Yt(() => this.pendingTasks.remove(r))) } static { this.\u0275fac = function (r) { return new (r || e)(k(Ic), k(Nt)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac }) } } return e })(); const C3 = /^\)\]\}',?\n/; let vw = (() => { class e { constructor(t) { this.xhrFactory = t } handle(t) { if ("JSONP" === t.method) throw new x(-2800, !1); const r = this.xhrFactory; return (r.\u0275loadImpl ? He(r.\u0275loadImpl()) : H(null)).pipe(Vt(() => new be(o => { const s = r.build(); if (s.open(t.method, t.urlWithParams), t.withCredentials && (s.withCredentials = !0), t.headers.forEach((y, C) => s.setRequestHeader(y, C.join(","))), t.headers.has("Accept") || s.setRequestHeader("Accept", "application/json, text/plain, */*"), !t.headers.has("Content-Type")) { const y = t.detectContentTypeHeader(); null !== y && s.setRequestHeader("Content-Type", y) } if (t.responseType) { const y = t.responseType.toLowerCase(); s.responseType = "json" !== y ? y : "text" } const a = t.serializeBody(); let l = null; const c = () => { if (null !== l) return l; const y = s.statusText || "OK", C = new Sn(s.getAllResponseHeaders()), T = function w3(e) { return "responseURL" in e && e.responseURL ? e.responseURL : /^X-Request-URL:/m.test(e.getAllResponseHeaders()) ? e.getResponseHeader("X-Request-URL") : null }(s) || t.url; return l = new ip({ headers: C, status: s.status, statusText: y, url: T }), l }, u = () => { let { headers: y, status: C, statusText: T, url: w } = c(), P = null; 204 !== C && (P = typeof s.response > "u" ? s.responseText : s.response), 0 === C && (C = P ? 200 : 0); let L = C >= 200 && C < 300; if ("json" === t.responseType && "string" == typeof P) { const Q = P; P = P.replace(C3, ""); try { P = "" !== P ? JSON.parse(P) : null } catch (Ke) { P = Q, L && (L = !1, P = { error: Ke, text: P }) } } L ? (o.next(new uo({ body: P, headers: y, status: C, statusText: T, url: w || void 0 })), o.complete()) : o.error(new dw({ error: P, headers: y, status: C, statusText: T, url: w || void 0 })) }, d = y => { const { url: C } = c(), T = new dw({ error: y, status: s.status || 0, statusText: s.statusText || "Unknown Error", url: C || void 0 }); o.error(T) }; let p = !1; const m = y => { p || (o.next(c()), p = !0); let C = { type: co.DownloadProgress, loaded: y.loaded }; y.lengthComputable && (C.total = y.total), "text" === t.responseType && s.responseText && (C.partialText = s.responseText), o.next(C) }, v = y => { let C = { type: co.UploadProgress, loaded: y.loaded }; y.lengthComputable && (C.total = y.total), o.next(C) }; return s.addEventListener("load", u), s.addEventListener("error", d), s.addEventListener("timeout", d), s.addEventListener("abort", d), t.reportProgress && (s.addEventListener("progress", m), null !== a && s.upload && s.upload.addEventListener("progress", v)), s.send(a), o.next({ type: co.Sent }), () => { s.removeEventListener("error", d), s.removeEventListener("abort", d), s.removeEventListener("load", u), s.removeEventListener("timeout", d), t.reportProgress && (s.removeEventListener("progress", m), null !== a && s.upload && s.upload.removeEventListener("progress", v)), s.readyState !== s.DONE && s.abort() } }))) } static { this.\u0275fac = function (r) { return new (r || e)(k(AD)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac }) } } return e })(); const lp = new A("XSRF_ENABLED"), yw = new A("XSRF_COOKIE_NAME", { providedIn: "root", factory: () => "XSRF-TOKEN" }), bw = new A("XSRF_HEADER_NAME", { providedIn: "root", factory: () => "X-XSRF-TOKEN" }); class Dw { } let S3 = (() => { class e { constructor(t, r, i) { this.doc = t, this.platform = r, this.cookieName = i, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const t = this.doc.cookie || ""; return t !== this.lastCookieString && (this.parseCount++, this.lastToken = DD(t, this.cookieName), this.lastCookieString = t), this.lastToken } static { this.\u0275fac = function (r) { return new (r || e)(k(We), k(sr), k(yw)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac }) } } return e })(); function T3(e, n) { const t = e.url.toLowerCase(); if (!O(lp) || "GET" === e.method || "HEAD" === e.method || t.startsWith("http://") || t.startsWith("https://")) return n(e); const r = O(Dw).getToken(), i = O(bw); return null != r && !e.headers.has(i) && (e = e.clone({ headers: e.headers.set(i, r) })), n(e) } var pr = function (e) { return e[e.Interceptors = 0] = "Interceptors", e[e.LegacyInterceptors = 1] = "LegacyInterceptors", e[e.CustomXsrfConfiguration = 2] = "CustomXsrfConfiguration", e[e.NoXsrfProtection = 3] = "NoXsrfProtection", e[e.JsonpSupport = 4] = "JsonpSupport", e[e.RequestsMadeViaParent = 5] = "RequestsMadeViaParent", e[e.Fetch = 6] = "Fetch", e }(pr || {}); function Br(e, n) { return { \u0275kind: e, \u0275providers: n } } function x3(...e) { const n = [sp, vw, mw, { provide: Ec, useExisting: mw }, { provide: Ic, useExisting: vw }, { provide: zs, useValue: T3, multi: !0 }, { provide: lp, useValue: !0 }, { provide: Dw, useClass: S3 }]; for (const t of e) n.push(...t.\u0275providers); return function Ed(e) { return { \u0275providers: e } }(n) } const Cw = new A("LEGACY_INTERCEPTOR_FN"); let A3 = (() => { class e { static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275mod = bt({ type: e }) } static { this.\u0275inj = ct({ providers: [x3(Br(pr.LegacyInterceptors, [{ provide: Cw, useFactory: v3 }, { provide: zs, useExisting: Cw, multi: !0 }]))] }) } } return e })(); const ww_apiBase = ""; let gr = (() => { class e { constructor(t) { this.http = t, this.base = "https://backeendtasklink.onrender.com/api" } getTasks() { return this.http.get(`${this.base}/tasks`) } getTasksByProject(t) { return t ? this.http.get(`${this.base}/projects/${t}/tasks`) : this.getTasks() } getTask(t) { return this.http.get(`${this.base}/tasks/${t}`) } createTask(t, r) { const i = { ...t, projectId: r ?? t.projectId }; return this.http.post(`${this.base}/tasks`, i) } updateTask(t, r) { return this.http.put(`${this.base}/tasks/${t}`, r) } deleteTask(t) { return this.http.delete(`${this.base}/tasks/${t}`) } getProjects() { return this.http.get(`${this.base}/projects`) } getProject(t) { return this.http.get(`${this.base}/projects/${t}`) } createProject(t) { return this.http.post(`${this.base}/projects`, t) } inviteMember(t, r, i = "MEMBER") { return this.http.post(`${this.base}/projects/${t}/members/invite`, { email: r, role: i }) } getMyMembership(t) { return this.http.get(`${this.base}/projects/${t}/me`) } verifyInvite(t) { return this.http.get(`${this.base}/auth/verify`, { params: { token: t } }) } acceptInvite(t) { return this.http.post(`${this.base}/projects/invites/accept`, null, { params: { token: t } }) } getProjectMembers(t) { return this.http.get(`${this.base}/projects/${t}/members/list`) } assignTask(t, r) { const i = (new Zn).set("userId", String(r)); return this.http.post(`${this.base}/tasks/${t}/assign`, null, { params: i }) } getProjectSummary() { return this.http.get(`${this.base}/projects/summary`) } checkUserExists(t) { return this.http.get(`${this.base}/auth/check-user?email=${encodeURIComponent(t)}`) } static { this.\u0275fac = function (r) { return new (r || e)(k(sp)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(), Tn = (() => { class e { constructor(t, r) { this.http = t, this.router = r, this.base = `${ww_apiBase}/auth`, this.currentUserSubject = new xt(null), this.currentUser$ = this.currentUserSubject.asObservable(); const i = this.getToken(), o = this.getStoredUser(); i && !this.isTokenExpired(i) && this.currentUserSubject.next(o || this.decodeUserFromToken(i)) } login(t) { return this.http.post(`${this.base}/login`, t).pipe(Ue(r => this.setSession(r))) } register(t) { return this.http.post(`${this.base}/register`, { email: t.email, password: t.password, firstname: t.firstname, lastname: t.lastname, inviteToken: t.inviteToken }).pipe(Ue(i => this.setSession(i))) } getToken() { return localStorage.getItem("token") } isLoggedIn() { const t = this.getToken(); return !!t && !this.isTokenExpired(t) } logout() { localStorage.removeItem("token"), localStorage.removeItem("user"), this.currentUserSubject.next(null), this.router.navigate(["/login"]) } setSession(t) { localStorage.setItem("token", t.token); const r = { email: t.email, firstname: t.firstname, lastname: t.lastname, name: [t.firstname, t.lastname].filter(Boolean).join(" ").trim() || t.email }; localStorage.setItem("user", JSON.stringify(r)), this.currentUserSubject.next(r) } getStoredUser() { try { const t = localStorage.getItem("user"); return t ? JSON.parse(t) : null } catch { return null } } decodeUserFromToken(t) { try { const r = JSON.parse(atob(t.split(".")[1])), i = r.given_name || r.firstname, o = r.family_name || r.lastname, s = r.sub || r.email || ""; return { email: s, firstname: i, lastname: o, name: [i, o].filter(Boolean).join(" ").trim() || s } } catch { return { email: "" } } } isTokenExpired(t) { try { const r = JSON.parse(atob(t.split(".")[1])), i = r.exp ? 1e3 * r.exp : 0; return !!i && Date.now() > i } catch { return !0 } } static { this.\u0275fac = function (r) { return new (r || e)(k(sp), k(Re)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); function F3(e, n) { if (1 & e && (ge(0), g(1), qt(2, "async"), qt(3, "async"), me()), 2 & e) { const t = E(); let r; _(1), U(" ", (null == (r = gs(2, 1, t.user$)) ? null : r.name) || (null == (r = gs(3, 3, t.user$)) ? null : r.email) || "there", " ") } } function L3(e, n) { 1 & e && M(0, "span", 30) } function j3(e, n) { if (1 & e) { const t = ve(); f(0, "button", 32), R("click", function () { const o = V(t).$implicit; return B(E(2).goProject(o)) }), f(1, "div", 15)(2, "span", 33), g(3), qt(4, "slice"), h(), f(5, "div", 34)(6, "div", 35), g(7), h(), f(8, "div", 36), g(9, "Project"), h()()()() } if (2 & e) { const t = n.$implicit; _(3), U(" ", zi(4, 2, t.name, 0, 1), " "), _(4), te(t.name) } } function V3(e, n) { if (1 & e && (ge(0), f(1, "div", 13), I(2, j3, 10, 6, "button", 31), qt(3, "slice"), h(), me()), 2 & e) { const t = E(); _(2), b("ngForOf", zi(3, 1, t.projects, 0, 4)) } } function B3(e, n) { 1 & e && (f(0, "div", 38)(1, "div", 39), M(2, "span", 40), f(3, "div", 41), M(4, "div", 42)(5, "div", 43), h()()()) } const Ew = function () { return [1, 2, 3, 4] }; function U3(e, n) { 1 & e && (f(0, "div", 13), I(1, B3, 6, 0, "div", 37), h()), 2 & e && (_(1), b("ngForOf", Gt(1, Ew))) } function H3(e, n) { 1 & e && (f(0, "div", 45)(1, "div", 46)(2, "div", 41), M(3, "div", 47), f(4, "div", 48), M(5, "div", 49)(6, "div", 50)(7, "div", 51), h()(), M(8, "div", 52), h()()) } function $3(e, n) { 1 & e && (ge(0), I(1, H3, 9, 0, "div", 44), me()), 2 & e && (_(1), b("ngForOf", Gt(1, Ew))) } function z3(e, n) { 1 & e && (f(0, "div", 55), g(1, " Nothing yet \u2014 create a task to get started. "), h()) } const G3 = function (e, n, t) { return { "bg-slate-50 text-slate-700 border-slate-200": e, "bg-amber-50 text-amber-700 border-amber-200": n, "bg-emerald-50 text-emerald-700 border-emerald-200": t } }; function q3(e, n) { if (1 & e && (f(0, "div", 62)(1, "div", 63)(2, "div", 34)(3, "div", 35), g(4), h(), f(5, "div", 64)(6, "span", 65), g(7), h(), f(8, "span", 66), g(9), h(), f(10, "span", 67), g(11), h()()(), f(12, "div", 68), g(13), h()()()), 2 & e) { const t = n.$implicit, r = E(3); _(4), te(t.title), _(3), U(" ", t.key || "TASK-" + t.id, " "), _(2), U(" ", r.projectName(t.projectId) || "General", " "), _(1), b("ngClass", hs(6, G3, "OPEN" === (t.status || "OPEN"), "IN_PROGRESS" === t.status, "DONE" === t.status)), _(1), U(" ", t.status || "OPEN", " "), _(2), U(" ", r.timeAgo(t.updatedAt || t.createdAt), " ") } } function W3(e, n) { if (1 & e) { const t = ve(); ge(0), f(1, "button", 69), R("click", function () { const o = V(t).$implicit; return B(E(3).setTasksPage(o)) }), g(2), h(), me() } if (2 & e) { const t = n.$implicit, r = E(3); _(1), b("ngClass", t === r.tasksPage ? "bg-slate-900 text-white border-slate-900" : "bg-white text-slate-700 border-slate-300 hover:bg-slate-50"), nt("aria-current", t === r.tasksPage ? "page" : null), _(1), U(" ", t, " ") } } function Z3(e, n) { if (1 & e) { const t = ve(); ge(0), I(1, q3, 14, 10, "div", 56), f(2, "div", 57)(3, "div", 4), g(4), h(), f(5, "div", 58)(6, "button", 59), R("click", function () { return V(t), B(E(2).prevTasksPage()) }), g(7, " Prev "), h(), I(8, W3, 3, 3, "ng-container", 60), f(9, "button", 61), R("click", function () { return V(t), B(E(2).nextTasksPage()) }), g(10, " Next "), h()()(), me() } if (2 & e) { const t = E(2); _(1), b("ngForOf", t.recentTasksPaged)("ngForTrackBy", t.trackTaskById), _(3), Ui(" Showing ", t.tasksPageStart + 1, "\u2013", t.tasksPageEnd, " of ", t.recentTasks.length, " "), _(2), b("disabled", 1 === t.tasksPage), _(2), b("ngForOf", t.tasksPages), _(1), b("disabled", t.tasksPage === t.tasksTotalPages) } } function K3(e, n) { if (1 & e && (I(0, z3, 2, 0, "div", 53), I(1, Z3, 11, 8, "ng-container", 54)), 2 & e) { const t = E(); b("ngIf", !(null != t.recentTasks && t.recentTasks.length)), _(1), b("ngIf", null == t.recentTasks ? null : t.recentTasks.length) } } let Iw = (() => { class e { get tasksTotalPages() { return Math.max(1, Math.ceil(this.recentTasks.length / this.tasksPageSize)) } get tasksPageStart() { return (this.tasksPage - 1) * this.tasksPageSize } get tasksPageEnd() { return Math.min(this.tasksPageStart + this.tasksPageSize, this.recentTasks.length) } get recentTasksPaged() { return this.recentTasks.slice(this.tasksPageStart, this.tasksPageEnd) } get tasksPages() { return Array.from({ length: this.tasksTotalPages }, (t, r) => r + 1) } setTasksPage(t) { this.tasksPage = Math.min(Math.max(1, t), this.tasksTotalPages) } prevTasksPage() { this.setTasksPage(this.tasksPage - 1) } nextTasksPage() { this.setTasksPage(this.tasksPage + 1) } trackTaskById(t, r) { return r.id ?? t } constructor(t, r, i) { this.api = t, this.auth = r, this.router = i, this.today = new Date, this.user$ = this.auth.currentUser$, this.projects = [], this.projectMap = new Map, this.recentTasks = [], this.loadingProjects = !0, this.loadingTasks = !0, this.userLoading = !0, this.tasksPageSize = 3, this.tasksPage = 1 } ngOnInit() { this.auth.currentUser$.pipe(Cn(1)).subscribe({ next: () => this.userLoading = !1, error: () => this.userLoading = !1 }), this.api.getProjects().pipe(Yt(() => this.loadingProjects = !1)).subscribe(t => { this.projects = t || [], t?.forEach(r => { null != r.id && this.projectMap.set(r.id, r.name) }) }), this.api.getTasks().pipe(Yt(() => this.loadingTasks = !1)).subscribe(t => { this.recentTasks = [...t || []].sort((i, o) => { const s = new Date(i.updatedAt || i.createdAt || 0).getTime() || (i.id ? i.id : 0); return (new Date(o.updatedAt || o.createdAt || 0).getTime() || (o.id ? o.id : 0)) - s }), this.tasksPage > this.tasksTotalPages && (this.tasksPage = this.tasksTotalPages) }), console.log(this.auth.currentUser$) } goProject(t) { null != t.id && this.router.navigate(["/projects", t.id, "board"]) } projectName(t) { return t && this.projectMap.get(t) || "" } timeAgo(t) { if (!t) return ""; const r = Date.now() - new Date(t).getTime(), i = Math.floor(r / 1e3), o = Math.floor(i / 60), s = Math.floor(o / 60), a = Math.floor(s / 24); return a > 0 ? `${a} day${a > 1 ? "s" : ""} ago` : s > 0 ? `${s} hour${s > 1 ? "s" : ""} ago` : o > 0 ? `${o} min ago` : "just now" } static { this.\u0275fac = function (r) { return new (r || e)(D(gr), D(Tn), D(Re)) } } static { this.\u0275cmp = rt({ type: e, selectors: [["app-dashboard"]], decls: 75, vars: 10, consts: [[1, "space-y-8"], [1, "relative", "overflow-hidden", "rounded-2xl", "border", "border-slate-200", "bg-gradient-to-r", "from-sky-50", "via-white", "to-emerald-50", "shadow"], [1, "absolute", "inset-0", "opacity-40", "pointer-events-none", 2, "background-image", "radial-gradient(circle at 10% 10%, rgba(56,189,248,0.15), transparent 40%),\n           radial-gradient(circle at 90% 30%, rgba(251,191,36,0.12), transparent 35%),\n           radial-gradient(circle at 50% 80%, rgba(16,185,129,0.15), transparent 30%)"], [1, "relative", "z-10", "p-6", "md:p-7", "flex", "items-center", "justify-between"], [1, "text-sm", "text-slate-600"], [1, "text-2xl", "md:text-3xl", "font-semibold", "mt-1", "tracking-tight"], [4, "ngIf", "ngIfElse"], [1, "mt-1", "text-sm", "text-slate-500"], ["routerLink", "/tasks", 1, "px-4", "py-2.5", "rounded-lg", "text-white", "bg-gradient-to-r", "from-slate-900", "to-slate-700", "hover:from-slate-800", "hover:to-slate-700", "shadow"], ["userNameSkeleton", ""], [1, "space-y-3"], [1, "flex", "items-center", "justify-between"], [1, "text-lg", "font-semibold"], [1, "grid", "sm:grid-cols-2", "lg:grid-cols-4", "gap-4"], ["routerLink", "/board", 1, "group", "block", "rounded-2xl", "border", "border-slate-200", "bg-white", "p-4", "hover:shadow-sm", "transition"], [1, "flex", "items-center", "gap-3"], [1, "inline-flex", "items-center", "justify-center", "w-9", "h-9", "rounded-lg", "bg-sky-50", "text-sky-600", "border", "border-sky-100"], [1, "font-medium"], [1, "text-sm", "text-slate-500"], ["routerLink", "/backlog", 1, "group", "block", "rounded-2xl", "border", "border-slate-200", "bg-white", "p-4", "hover:shadow-sm", "transition"], [1, "inline-flex", "items-center", "justify-center", "w-9", "h-9", "rounded-lg", "bg-amber-50", "text-amber-600", "border", "border-amber-100"], ["routerLink", "/projects", 1, "group", "block", "rounded-2xl", "border", "border-slate-200", "bg-white", "p-4", "hover:shadow-sm", "transition"], [1, "inline-flex", "items-center", "justify-center", "w-9", "h-9", "rounded-lg", "bg-emerald-50", "text-emerald-600", "border", "border-emerald-100"], ["routerLink", "/profile", 1, "group", "block", "rounded-2xl", "border", "border-slate-200", "bg-white", "p-4", "hover:shadow-sm", "transition"], [1, "inline-flex", "items-center", "justify-center", "w-9", "h-9", "rounded-lg", "bg-violet-50", "text-violet-600", "border", "border-violet-100"], ["routerLink", "/board", 1, "text-sm", "px-3", "py-1.5", "rounded-md", "border", "border-slate-300", "bg-white", "text-slate-700", "hover:bg-slate-50"], ["projectsSkeleton", ""], [1, "rounded-2xl", "border", "border-slate-200", "bg-white", "overflow-hidden"], [1, "h-1", "w-full", "bg-gradient-to-r", "from-emerald-400", "via-sky-400", "to-violet-500"], ["tasksLoaded", ""], [1, "inline-block", "align-middle", "w-24", "h-6", "md:h-7", "rounded", "bg-slate-200", "animate-pulse"], ["type", "button", "class", "text-left p-4 rounded-2xl border border-slate-200 bg-white hover:shadow-sm hover:bg-slate-50 transition", 3, "click", 4, "ngFor", "ngForOf"], ["type", "button", 1, "text-left", "p-4", "rounded-2xl", "border", "border-slate-200", "bg-white", "hover:shadow-sm", "hover:bg-slate-50", "transition", 3, "click"], [1, "inline-flex", "items-center", "justify-center", "w-8", "h-8", "rounded-lg", "border", "border-slate-200", "bg-slate-50", "text-slate-600"], [1, "min-w-0"], [1, "font-medium", "truncate"], [1, "text-xs", "text-slate-500", "mt-0.5"], ["class", "p-4 rounded-2xl border border-slate-200 bg-white", 4, "ngFor", "ngForOf"], [1, "p-4", "rounded-2xl", "border", "border-slate-200", "bg-white"], [1, "flex", "items-center", "gap-3", "animate-pulse"], [1, "inline-flex", "w-8", "h-8", "rounded-lg", "bg-slate-200"], [1, "min-w-0", "flex-1"], [1, "h-4", "bg-slate-200", "rounded", "w-3/4", "mb-2"], [1, "h-3", "bg-slate-100", "rounded", "w-1/3"], ["class", "p-4 border-b border-slate-100 last:border-b-0", 4, "ngFor", "ngForOf"], [1, "p-4", "border-b", "border-slate-100", "last:border-b-0"], [1, "flex", "items-center", "justify-between", "gap-3", "animate-pulse"], [1, "h-4", "bg-slate-200", "rounded", "w-2/3", "mb-2"], [1, "flex", "items-center", "gap-2"], [1, "h-5", "w-20", "bg-slate-100", "rounded"], [1, "h-3", "w-24", "bg-slate-100", "rounded"], [1, "h-5", "w-16", "bg-slate-100", "rounded"], [1, "h-3", "w-16", "bg-slate-100", "rounded"], ["class", "p-6 text-center text-slate-500", 4, "ngIf"], [4, "ngIf"], [1, "p-6", "text-center", "text-slate-500"], ["class", "p-4 border-b border-slate-100 last:border-b-0 hover:bg-slate-50 transition", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "flex", "items-center", "justify-between", "px-4", "py-3", "bg-white"], [1, "flex", "items-center", "gap-1"], ["aria-label", "Previous tasks page", 1, "px-3", "py-1.5", "rounded-md", "border", "border-slate-300", "bg-white", "text-slate-700", "hover:bg-slate-50", "disabled:opacity-50", 3, "disabled", "click"], [4, "ngFor", "ngForOf"], ["aria-label", "Next tasks page", 1, "px-3", "py-1.5", "rounded-md", "border", "border-slate-300", "bg-white", "text-slate-700", "hover:bg-slate-50", "disabled:opacity-50", 3, "disabled", "click"], [1, "p-4", "border-b", "border-slate-100", "last:border-b-0", "hover:bg-slate-50", "transition"], [1, "flex", "items-center", "justify-between", "gap-3"], [1, "text-xs", "text-slate-500", "truncate", "mt-0.5", "flex", "items-center", "gap-2"], [1, "px-2", "py-0.5", "rounded-full", "border", "bg-slate-50"], [1, "truncate"], [1, "px-2", "py-0.5", "rounded-full", "border", 3, "ngClass"], [1, "text-xs", "text-slate-500", "shrink-0"], [1, "px-3", "py-1.5", "rounded-md", "border", 3, "ngClass", "click"]], template: function (r, i) { if (1 & r && (f(0, "div", 0)(1, "div", 1), M(2, "div", 2), f(3, "div", 3)(4, "div")(5, "div", 4), g(6), qt(7, "date"), h(), f(8, "div", 5), g(9, " Hello, "), I(10, F3, 4, 5, "ng-container", 6), h(), f(11, "div", 7), g(12, " Let\u2019s get things done today. "), h()(), f(13, "a", 8), g(14, " + Create "), h()()(), I(15, L3, 1, 0, "ng-template", null, 9, qe), f(17, "div", 10)(18, "div", 11)(19, "div", 12), g(20, "Your apps"), h()(), f(21, "div", 13)(22, "a", 14)(23, "div", 15)(24, "span", 16), g(25, "\u{1f9ed}"), h(), f(26, "div")(27, "div", 17), g(28, "Board"), h(), f(29, "div", 18), g(30, "Kanban board"), h()()()(), f(31, "a", 19)(32, "div", 15)(33, "span", 20), g(34, "\u{1f9fe}"), h(), f(35, "div")(36, "div", 17), g(37, "Backlog"), h(), f(38, "div", 18), g(39, "Prioritize issues"), h()()()(), f(40, "a", 21)(41, "div", 15)(42, "span", 22), g(43, "\u{1f4c1}"), h(), f(44, "div")(45, "div", 17), g(46, "Projects"), h(), f(47, "div", 18), g(48, "Manage projects"), h()()()(), f(49, "a", 23)(50, "div", 15)(51, "span", 24), g(52, "\u2699\ufe0f"), h(), f(53, "div")(54, "div", 17), g(55, "Account settings"), h(), f(56, "div", 18), g(57, "Your profile"), h()()()()()(), f(58, "div", 10)(59, "div", 11)(60, "div", 12), g(61, "Frequent places"), h(), f(62, "a", 25), g(63, " View all "), h()(), I(64, V3, 4, 5, "ng-container", 6), I(65, U3, 2, 2, "ng-template", null, 26, qe), h(), f(67, "div", 10)(68, "div", 12), g(69, "What\u2019s Next"), h(), f(70, "div", 27), M(71, "div", 28), I(72, $3, 2, 2, "ng-container", 6), I(73, K3, 2, 2, "ng-template", null, 29, qe), h()()()), 2 & r) { const o = Ve(16), s = Ve(66), a = Ve(74); _(6), U(" ", Af(7, 7, i.today, "EEEE, MMMM d"), " "), _(4), b("ngIf", !i.userLoading)("ngIfElse", o), _(54), b("ngIf", !i.loadingProjects)("ngIfElse", s), _(8), b("ngIf", i.loadingTasks)("ngIfElse", a) } }, dependencies: [Xi, Fr, Dn, In, vh, tc, yh], encapsulation: 2 }) } } return e })(), Sw = (() => { class e { constructor(t, r) { this._renderer = t, this._elementRef = r, this.onChange = i => { }, this.onTouched = () => { } } setProperty(t, r) { this._renderer.setProperty(this._elementRef.nativeElement, t, r) } registerOnTouched(t) { this.onTouched = t } registerOnChange(t) { this.onChange = t } setDisabledState(t) { this.setProperty("disabled", t) } static { this.\u0275fac = function (r) { return new (r || e)(D(Ln), D(tt)) } } static { this.\u0275dir = j({ type: e }) } } return e })(), Ur = (() => { class e extends Sw { static { this.\u0275fac = function () { let t; return function (i) { return (t || (t = et(e)))(i || e) } }() } static { this.\u0275dir = j({ type: e, features: [pe] }) } } return e })(); const xn = new A("NgValueAccessor"), X3 = { provide: xn, useExisting: De(() => Kn), multi: !0 }, eV = new A("CompositionEventMode"); let Kn = (() => { class e extends Sw { constructor(t, r, i) { super(t, r), this._compositionMode = i, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function J3() { const e = cr() ? cr().getUserAgent() : ""; return /android (\d+)/.test(e.toLowerCase()) }()) } writeValue(t) { this.setProperty("value", t ?? "") } _handleInput(t) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(t) } _compositionStart() { this._composing = !0 } _compositionEnd(t) { this._composing = !1, this._compositionMode && this.onChange(t) } static { this.\u0275fac = function (r) { return new (r || e)(D(Ln), D(tt), D(eV, 8)) } } static { this.\u0275dir = j({ type: e, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function (r, i) { 1 & r && R("input", function (s) { return i._handleInput(s.target.value) })("blur", function () { return i.onTouched() })("compositionstart", function () { return i._compositionStart() })("compositionend", function (s) { return i._compositionEnd(s.target.value) }) }, features: [fe([X3]), pe] }) } } return e })(); function mr(e) { return null == e || ("string" == typeof e || Array.isArray(e)) && 0 === e.length } function xw(e) { return null != e && "number" == typeof e.length } const at = new A("NgValidators"), _r = new A("NgAsyncValidators"), tV = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/; class jt { static min(n) { return function Mw(e) { return n => { if (mr(n.value) || mr(e)) return null; const t = parseFloat(n.value); return !isNaN(t) && t < e ? { min: { min: e, actual: n.value } } : null } }(n) } static max(n) { return function Aw(e) { return n => { if (mr(n.value) || mr(e)) return null; const t = parseFloat(n.value); return !isNaN(t) && t > e ? { max: { max: e, actual: n.value } } : null } }(n) } static required(n) { return kw(n) } static requiredTrue(n) { return function Rw(e) { return !0 === e.value ? null : { required: !0 } }(n) } static email(n) { return function Pw(e) { return mr(e.value) || tV.test(e.value) ? null : { email: !0 } }(n) } static minLength(n) { return function Nw(e) { return n => mr(n.value) || !xw(n.value) ? null : n.value.length < e ? { minlength: { requiredLength: e, actualLength: n.value.length } } : null }(n) } static maxLength(n) { return function Ow(e) { return n => xw(n.value) && n.value.length > e ? { maxlength: { requiredLength: e, actualLength: n.value.length } } : null }(n) } static pattern(n) { return function Fw(e) { if (!e) return xc; let n, t; return "string" == typeof e ? (t = "", "^" !== e.charAt(0) && (t += "^"), t += e, "$" !== e.charAt(e.length - 1) && (t += "$"), n = new RegExp(t)) : (t = e.toString(), n = e), r => { if (mr(r.value)) return null; const i = r.value; return n.test(i) ? null : { pattern: { requiredPattern: t, actualValue: i } } } }(n) } static nullValidator(n) { return null } static compose(n) { return Hw(n) } static composeAsync(n) { return $w(n) } } function kw(e) { return mr(e.value) ? { required: !0 } : null } function xc(e) { return null } function Lw(e) { return null != e } function jw(e) { return os(e) ? He(e) : e } function Vw(e) { let n = {}; return e.forEach(t => { n = null != t ? { ...n, ...t } : n }), 0 === Object.keys(n).length ? null : n } function Bw(e, n) { return n.map(t => t(e)) } function Uw(e) { return e.map(n => function nV(e) { return !e.validate }(n) ? n : t => n.validate(t)) } function Hw(e) { if (!e) return null; const n = e.filter(Lw); return 0 == n.length ? null : function (t) { return Vw(Bw(t, n)) } } function cp(e) { return null != e ? Hw(Uw(e)) : null } function $w(e) { if (!e) return null; const n = e.filter(Lw); return 0 == n.length ? null : function (t) { return function Y3(...e) { const n = pg(e), { args: t, keys: r } = XD(e), i = new be(o => { const { length: s } = t; if (!s) return void o.complete(); const a = new Array(s); let l = s, c = s; for (let u = 0; u < s; u++) { let d = !1; lt(t[u]).subscribe(xe(o, p => { d || (d = !0, c--), a[u] = p }, () => l--, void 0, () => { (!l || !d) && (c || o.next(r ? JD(r, a) : a), o.complete()) })) } }); return n ? i.pipe(Rh(n)) : i }(Bw(t, n).map(jw)).pipe(re(Vw)) } } function up(e) { return null != e ? $w(Uw(e)) : null } function zw(e, n) { return null === e ? [n] : Array.isArray(e) ? [...e, n] : [e, n] } function Gw(e) { return e._rawValidators } function qw(e) { return e._rawAsyncValidators } function dp(e) { return e ? Array.isArray(e) ? e : [e] : [] } function Mc(e, n) { return Array.isArray(e) ? e.includes(n) : e === n } function Ww(e, n) { const t = dp(n); return dp(e).forEach(i => { Mc(t, i) || t.push(i) }), t } function Zw(e, n) { return dp(n).filter(t => !Mc(e, t)) } class Kw { constructor() { this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = [] } get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } _setValidators(n) { this._rawValidators = n || [], this._composedValidatorFn = cp(this._rawValidators) } _setAsyncValidators(n) { this._rawAsyncValidators = n || [], this._composedAsyncValidatorFn = up(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn || null } get asyncValidator() { return this._composedAsyncValidatorFn || null } _registerOnDestroy(n) { this._onDestroyCallbacks.push(n) } _invokeOnDestroyCallbacks() { this._onDestroyCallbacks.forEach(n => n()), this._onDestroyCallbacks = [] } reset(n = void 0) { this.control && this.control.reset(n) } hasError(n, t) { return !!this.control && this.control.hasError(n, t) } getError(n, t) { return this.control ? this.control.getError(n, t) : null } } class vt extends Kw { get formDirective() { return null } get path() { return null } } class vr extends Kw { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null } } class Yw { constructor(n) { this._cd = n } get isTouched() { return !!this._cd?.control?.touched } get isUntouched() { return !!this._cd?.control?.untouched } get isPristine() { return !!this._cd?.control?.pristine } get isDirty() { return !!this._cd?.control?.dirty } get isValid() { return !!this._cd?.control?.valid } get isInvalid() { return !!this._cd?.control?.invalid } get isPending() { return !!this._cd?.control?.pending } get isSubmitted() { return !!this._cd?.submitted } } let Hr = (() => { class e extends Yw { constructor(t) { super(t) } static { this.\u0275fac = function (r) { return new (r || e)(D(vr, 2)) } } static { this.\u0275dir = j({ type: e, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function (r, i) { 2 & r && zt("ng-untouched", i.isUntouched)("ng-touched", i.isTouched)("ng-pristine", i.isPristine)("ng-dirty", i.isDirty)("ng-valid", i.isValid)("ng-invalid", i.isInvalid)("ng-pending", i.isPending) }, features: [pe] }) } } return e })(), $r = (() => { class e extends Yw { constructor(t) { super(t) } static { this.\u0275fac = function (r) { return new (r || e)(D(vt, 10)) } } static { this.\u0275dir = j({ type: e, selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]], hostVars: 16, hostBindings: function (r, i) { 2 & r && zt("ng-untouched", i.isUntouched)("ng-touched", i.isTouched)("ng-pristine", i.isPristine)("ng-dirty", i.isDirty)("ng-valid", i.isValid)("ng-invalid", i.isInvalid)("ng-pending", i.isPending)("ng-submitted", i.isSubmitted) }, features: [pe] }) } } return e })(); const Gs = "VALID", kc = "INVALID", fo = "PENDING", qs = "DISABLED"; function pp(e) { return (Rc(e) ? e.validators : e) || null } function gp(e, n) { return (Rc(n) ? n.asyncValidators : e) || null } function Rc(e) { return null != e && !Array.isArray(e) && "object" == typeof e } function Xw(e, n, t) { const r = e.controls; if (!(n ? Object.keys(r) : r).length) throw new x(1e3, ""); if (!r[t]) throw new x(1001, "") } function Jw(e, n, t) { e._forEachChild((r, i) => { if (void 0 === t[i]) throw new x(1002, "") }) } class Pc { constructor(n, t) { this._pendingDirty = !1, this._hasOwnPendingAsyncValidator = !1, this._pendingTouched = !1, this._onCollectionChange = () => { }, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._assignValidators(n), this._assignAsyncValidators(t) } get validator() { return this._composedValidatorFn } set validator(n) { this._rawValidators = this._composedValidatorFn = n } get asyncValidator() { return this._composedAsyncValidatorFn } set asyncValidator(n) { this._rawAsyncValidators = this._composedAsyncValidatorFn = n } get parent() { return this._parent } get valid() { return this.status === Gs } get invalid() { return this.status === kc } get pending() { return this.status == fo } get disabled() { return this.status === qs } get enabled() { return this.status !== qs } get dirty() { return !this.pristine } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(n) { this._assignValidators(n) } setAsyncValidators(n) { this._assignAsyncValidators(n) } addValidators(n) { this.setValidators(Ww(n, this._rawValidators)) } addAsyncValidators(n) { this.setAsyncValidators(Ww(n, this._rawAsyncValidators)) } removeValidators(n) { this.setValidators(Zw(n, this._rawValidators)) } removeAsyncValidators(n) { this.setAsyncValidators(Zw(n, this._rawAsyncValidators)) } hasValidator(n) { return Mc(this._rawValidators, n) } hasAsyncValidator(n) { return Mc(this._rawAsyncValidators, n) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(n = {}) { this.touched = !0, this._parent && !n.onlySelf && this._parent.markAsTouched(n) } markAllAsTouched() { this.markAsTouched({ onlySelf: !0 }), this._forEachChild(n => n.markAllAsTouched()) } markAsUntouched(n = {}) { this.touched = !1, this._pendingTouched = !1, this._forEachChild(t => { t.markAsUntouched({ onlySelf: !0 }) }), this._parent && !n.onlySelf && this._parent._updateTouched(n) } markAsDirty(n = {}) { this.pristine = !1, this._parent && !n.onlySelf && this._parent.markAsDirty(n) } markAsPristine(n = {}) { this.pristine = !0, this._pendingDirty = !1, this._forEachChild(t => { t.markAsPristine({ onlySelf: !0 }) }), this._parent && !n.onlySelf && this._parent._updatePristine(n) } markAsPending(n = {}) { this.status = fo, !1 !== n.emitEvent && this.statusChanges.emit(this.status), this._parent && !n.onlySelf && this._parent.markAsPending(n) } disable(n = {}) { const t = this._parentMarkedDirty(n.onlySelf); this.status = qs, this.errors = null, this._forEachChild(r => { r.disable({ ...n, onlySelf: !0 }) }), this._updateValue(), !1 !== n.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors({ ...n, skipPristineCheck: t }), this._onDisabledChange.forEach(r => r(!0)) } enable(n = {}) { const t = this._parentMarkedDirty(n.onlySelf); this.status = Gs, this._forEachChild(r => { r.enable({ ...n, onlySelf: !0 }) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: n.emitEvent }), this._updateAncestors({ ...n, skipPristineCheck: t }), this._onDisabledChange.forEach(r => r(!1)) } _updateAncestors(n) { this._parent && !n.onlySelf && (this._parent.updateValueAndValidity(n), n.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched()) } setParent(n) { this._parent = n } getRawValue() { return this.value } updateValueAndValidity(n = {}) { this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), (this.status === Gs || this.status === fo) && this._runAsyncValidator(n.emitEvent)), !1 !== n.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !n.onlySelf && this._parent.updateValueAndValidity(n) } _updateTreeValidity(n = { emitEvent: !0 }) { this._forEachChild(t => t._updateTreeValidity(n)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: n.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? qs : Gs } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(n) { if (this.asyncValidator) { this.status = fo, this._hasOwnPendingAsyncValidator = !0; const t = jw(this.asyncValidator(this)); this._asyncValidationSubscription = t.subscribe(r => { this._hasOwnPendingAsyncValidator = !1, this.setErrors(r, { emitEvent: n }) }) } } _cancelExistingSubscription() { this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1) } setErrors(n, t = {}) { this.errors = n, this._updateControlsErrors(!1 !== t.emitEvent) } get(n) { let t = n; return null == t || (Array.isArray(t) || (t = t.split(".")), 0 === t.length) ? null : t.reduce((r, i) => r && r._find(i), this) } getError(n, t) { const r = t ? this.get(t) : this; return r && r.errors ? r.errors[n] : null } hasError(n, t) { return !!this.getError(n, t) } get root() { let n = this; for (; n._parent;)n = n._parent; return n } _updateControlsErrors(n) { this.status = this._calculateStatus(), n && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(n) } _initObservables() { this.valueChanges = new se, this.statusChanges = new se } _calculateStatus() { return this._allControlsDisabled() ? qs : this.errors ? kc : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(fo) ? fo : this._anyControlsHaveStatus(kc) ? kc : Gs } _anyControlsHaveStatus(n) { return this._anyControls(t => t.status === n) } _anyControlsDirty() { return this._anyControls(n => n.dirty) } _anyControlsTouched() { return this._anyControls(n => n.touched) } _updatePristine(n = {}) { this.pristine = !this._anyControlsDirty(), this._parent && !n.onlySelf && this._parent._updatePristine(n) } _updateTouched(n = {}) { this.touched = this._anyControlsTouched(), this._parent && !n.onlySelf && this._parent._updateTouched(n) } _registerOnCollectionChange(n) { this._onCollectionChange = n } _setUpdateStrategy(n) { Rc(n) && null != n.updateOn && (this._updateOn = n.updateOn) } _parentMarkedDirty(n) { return !n && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty() } _find(n) { return null } _assignValidators(n) { this._rawValidators = Array.isArray(n) ? n.slice() : n, this._composedValidatorFn = function sV(e) { return Array.isArray(e) ? cp(e) : e || null }(this._rawValidators) } _assignAsyncValidators(n) { this._rawAsyncValidators = Array.isArray(n) ? n.slice() : n, this._composedAsyncValidatorFn = function aV(e) { return Array.isArray(e) ? up(e) : e || null }(this._rawAsyncValidators) } } class Ws extends Pc { constructor(n, t, r) { super(pp(t), gp(r, t)), this.controls = n, this._initObservables(), this._setUpdateStrategy(t), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } registerControl(n, t) { return this.controls[n] ? this.controls[n] : (this.controls[n] = t, t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange), t) } addControl(n, t, r = {}) { this.registerControl(n, t), this.updateValueAndValidity({ emitEvent: r.emitEvent }), this._onCollectionChange() } removeControl(n, t = {}) { this.controls[n] && this.controls[n]._registerOnCollectionChange(() => { }), delete this.controls[n], this.updateValueAndValidity({ emitEvent: t.emitEvent }), this._onCollectionChange() } setControl(n, t, r = {}) { this.controls[n] && this.controls[n]._registerOnCollectionChange(() => { }), delete this.controls[n], t && this.registerControl(n, t), this.updateValueAndValidity({ emitEvent: r.emitEvent }), this._onCollectionChange() } contains(n) { return this.controls.hasOwnProperty(n) && this.controls[n].enabled } setValue(n, t = {}) { Jw(this, 0, n), Object.keys(n).forEach(r => { Xw(this, !0, r), this.controls[r].setValue(n[r], { onlySelf: !0, emitEvent: t.emitEvent }) }), this.updateValueAndValidity(t) } patchValue(n, t = {}) { null != n && (Object.keys(n).forEach(r => { const i = this.controls[r]; i && i.patchValue(n[r], { onlySelf: !0, emitEvent: t.emitEvent }) }), this.updateValueAndValidity(t)) } reset(n = {}, t = {}) { this._forEachChild((r, i) => { r.reset(n ? n[i] : null, { onlySelf: !0, emitEvent: t.emitEvent }) }), this._updatePristine(t), this._updateTouched(t), this.updateValueAndValidity(t) } getRawValue() { return this._reduceChildren({}, (n, t, r) => (n[r] = t.getRawValue(), n)) } _syncPendingControls() { let n = this._reduceChildren(!1, (t, r) => !!r._syncPendingControls() || t); return n && this.updateValueAndValidity({ onlySelf: !0 }), n } _forEachChild(n) { Object.keys(this.controls).forEach(t => { const r = this.controls[t]; r && n(r, t) }) } _setUpControls() { this._forEachChild(n => { n.setParent(this), n._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(n) { for (const [t, r] of Object.entries(this.controls)) if (this.contains(t) && n(r)) return !0; return !1 } _reduceValue() { return this._reduceChildren({}, (t, r, i) => ((r.enabled || this.disabled) && (t[i] = r.value), t)) } _reduceChildren(n, t) { let r = n; return this._forEachChild((i, o) => { r = t(r, i, o) }), r } _allControlsDisabled() { for (const n of Object.keys(this.controls)) if (this.controls[n].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } _find(n) { return this.controls.hasOwnProperty(n) ? this.controls[n] : null } } class e1 extends Ws { } const zr = new A("CallSetDisabledState", { providedIn: "root", factory: () => Zs }), Zs = "always"; function Nc(e, n) { return [...n.path, e] } function Ks(e, n, t = Zs) { mp(e, n), n.valueAccessor.writeValue(e.value), (e.disabled || "always" === t) && n.valueAccessor.setDisabledState?.(e.disabled), function cV(e, n) { n.valueAccessor.registerOnChange(t => { e._pendingValue = t, e._pendingChange = !0, e._pendingDirty = !0, "change" === e.updateOn && t1(e, n) }) }(e, n), function dV(e, n) { const t = (r, i) => { n.valueAccessor.writeValue(r), i && n.viewToModelUpdate(r) }; e.registerOnChange(t), n._registerOnDestroy(() => { e._unregisterOnChange(t) }) }(e, n), function uV(e, n) { n.valueAccessor.registerOnTouched(() => { e._pendingTouched = !0, "blur" === e.updateOn && e._pendingChange && t1(e, n), "submit" !== e.updateOn && e.markAsTouched() }) }(e, n), function lV(e, n) { if (n.valueAccessor.setDisabledState) { const t = r => { n.valueAccessor.setDisabledState(r) }; e.registerOnDisabledChange(t), n._registerOnDestroy(() => { e._unregisterOnDisabledChange(t) }) } }(e, n) } function Oc(e, n, t = !0) { const r = () => { }; n.valueAccessor && (n.valueAccessor.registerOnChange(r), n.valueAccessor.registerOnTouched(r)), Lc(e, n), e && (n._invokeOnDestroyCallbacks(), e._registerOnCollectionChange(() => { })) } function Fc(e, n) { e.forEach(t => { t.registerOnValidatorChange && t.registerOnValidatorChange(n) }) } function mp(e, n) { const t = Gw(e); null !== n.validator ? e.setValidators(zw(t, n.validator)) : "function" == typeof t && e.setValidators([t]); const r = qw(e); null !== n.asyncValidator ? e.setAsyncValidators(zw(r, n.asyncValidator)) : "function" == typeof r && e.setAsyncValidators([r]); const i = () => e.updateValueAndValidity(); Fc(n._rawValidators, i), Fc(n._rawAsyncValidators, i) } function Lc(e, n) { let t = !1; if (null !== e) { if (null !== n.validator) { const i = Gw(e); if (Array.isArray(i) && i.length > 0) { const o = i.filter(s => s !== n.validator); o.length !== i.length && (t = !0, e.setValidators(o)) } } if (null !== n.asyncValidator) { const i = qw(e); if (Array.isArray(i) && i.length > 0) { const o = i.filter(s => s !== n.asyncValidator); o.length !== i.length && (t = !0, e.setAsyncValidators(o)) } } } const r = () => { }; return Fc(n._rawValidators, r), Fc(n._rawAsyncValidators, r), t } function t1(e, n) { e._pendingDirty && e.markAsDirty(), e.setValue(e._pendingValue, { emitModelToViewChange: !1 }), n.viewToModelUpdate(e._pendingValue), e._pendingChange = !1 } function n1(e, n) { mp(e, n) } function vp(e, n) { if (!e.hasOwnProperty("model")) return !1; const t = e.model; return !!t.isFirstChange() || !Object.is(n, t.currentValue) } function r1(e, n) { e._syncPendingControls(), n.forEach(t => { const r = t.control; "submit" === r.updateOn && r._pendingChange && (t.viewToModelUpdate(r._pendingValue), r._pendingChange = !1) }) } function yp(e, n) { if (!n) return null; let t, r, i; return Array.isArray(n), n.forEach(o => { o.constructor === Kn ? t = o : function pV(e) { return Object.getPrototypeOf(e.constructor) === Ur }(o) ? r = o : i = o }), i || r || t || null } const mV = { provide: vt, useExisting: De(() => Qs) }, Ys = (() => Promise.resolve())(); let Qs = (() => { class e extends vt { constructor(t, r, i) { super(), this.callSetDisabledState = i, this.submitted = !1, this._directives = new Set, this.ngSubmit = new se, this.form = new Ws({}, cp(t), up(r)) } ngAfterViewInit() { this._setUpdateStrategy() } get formDirective() { return this } get control() { return this.form } get path() { return [] } get controls() { return this.form.controls } addControl(t) { Ys.then(() => { const r = this._findContainer(t.path); t.control = r.registerControl(t.name, t.control), Ks(t.control, t, this.callSetDisabledState), t.control.updateValueAndValidity({ emitEvent: !1 }), this._directives.add(t) }) } getControl(t) { return this.form.get(t.path) } removeControl(t) { Ys.then(() => { const r = this._findContainer(t.path); r && r.removeControl(t.name), this._directives.delete(t) }) } addFormGroup(t) { Ys.then(() => { const r = this._findContainer(t.path), i = new Ws({}); n1(i, t), r.registerControl(t.name, i), i.updateValueAndValidity({ emitEvent: !1 }) }) } removeFormGroup(t) { Ys.then(() => { const r = this._findContainer(t.path); r && r.removeControl(t.name) }) } getFormGroup(t) { return this.form.get(t.path) } updateModel(t, r) { Ys.then(() => { this.form.get(t.path).setValue(r) }) } setValue(t) { this.control.setValue(t) } onSubmit(t) { return this.submitted = !0, r1(this.form, this._directives), this.ngSubmit.emit(t), "dialog" === t?.target?.method } onReset() { this.resetForm() } resetForm(t = void 0) { this.form.reset(t), this.submitted = !1 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.form._updateOn = this.options.updateOn) } _findContainer(t) { return t.pop(), t.length ? this.form.get(t) : this.form } static { this.\u0275fac = function (r) { return new (r || e)(D(at, 10), D(_r, 10), D(zr, 8)) } } static { this.\u0275dir = j({ type: e, selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]], hostBindings: function (r, i) { 1 & r && R("submit", function (s) { return i.onSubmit(s) })("reset", function () { return i.onReset() }) }, inputs: { options: ["ngFormOptions", "options"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [fe([mV]), pe] }) } } return e })(); function o1(e, n) { const t = e.indexOf(n); t > -1 && e.splice(t, 1) } function s1(e) { return "object" == typeof e && null !== e && 2 === Object.keys(e).length && "value" in e && "disabled" in e } const Xs = class extends Pc { constructor(n = null, t, r) { super(pp(t), gp(r, t)), this.defaultValue = null, this._onChange = [], this._pendingChange = !1, this._applyFormState(n), this._setUpdateStrategy(t), this._initObservables(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }), Rc(t) && (t.nonNullable || t.initialValueIsDefault) && (this.defaultValue = s1(n) ? n.value : n) } setValue(n, t = {}) { this.value = this._pendingValue = n, this._onChange.length && !1 !== t.emitModelToViewChange && this._onChange.forEach(r => r(this.value, !1 !== t.emitViewToModelChange)), this.updateValueAndValidity(t) } patchValue(n, t = {}) { this.setValue(n, t) } reset(n = this.defaultValue, t = {}) { this._applyFormState(n), this.markAsPristine(t), this.markAsUntouched(t), this.setValue(this.value, t), this._pendingChange = !1 } _updateValue() { } _anyControls(n) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(n) { this._onChange.push(n) } _unregisterOnChange(n) { o1(this._onChange, n) } registerOnDisabledChange(n) { this._onDisabledChange.push(n) } _unregisterOnDisabledChange(n) { o1(this._onDisabledChange, n) } _forEachChild(n) { } _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(n) { s1(n) ? (this.value = this._pendingValue = n.value, n.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = n } }, yV = { provide: vr, useExisting: De(() => Js) }, c1 = (() => Promise.resolve())(); let Js = (() => { class e extends vr { constructor(t, r, i, o, s, a) { super(), this._changeDetectorRef = s, this.callSetDisabledState = a, this.control = new Xs, this._registered = !1, this.name = "", this.update = new se, this._parent = t, this._setValidators(r), this._setAsyncValidators(i), this.valueAccessor = yp(0, o) } ngOnChanges(t) { if (this._checkForErrors(), !this._registered || "name" in t) { if (this._registered && (this._checkName(), this.formDirective)) { const r = t.name.previousValue; this.formDirective.removeControl({ name: r, path: this._getPath(r) }) } this._setUpControl() } "isDisabled" in t && this._updateDisabled(t), vp(t, this.viewModel) && (this._updateValue(this.model), this.viewModel = this.model) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } get path() { return this._getPath(this.name) } get formDirective() { return this._parent ? this._parent.formDirective : null } viewToModelUpdate(t) { this.viewModel = t, this.update.emit(t) } _setUpControl() { this._setUpdateStrategy(), this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this), this._registered = !0 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.control._updateOn = this.options.updateOn) } _isStandalone() { return !this._parent || !(!this.options || !this.options.standalone) } _setUpStandalone() { Ks(this.control, this, this.callSetDisabledState), this.control.updateValueAndValidity({ emitEvent: !1 }) } _checkForErrors() { this._isStandalone() || this._checkParentType(), this._checkName() } _checkParentType() { } _checkName() { this.options && this.options.name && (this.name = this.options.name), this._isStandalone() } _updateValue(t) { c1.then(() => { this.control.setValue(t, { emitViewToModelChange: !1 }), this._changeDetectorRef?.markForCheck() }) } _updateDisabled(t) { const r = t.isDisabled.currentValue, i = 0 !== r && Yi(r); c1.then(() => { i && !this.control.disabled ? this.control.disable() : !i && this.control.disabled && this.control.enable(), this._changeDetectorRef?.markForCheck() }) } _getPath(t) { return this._parent ? Nc(t, this._parent) : [t] } static { this.\u0275fac = function (r) { return new (r || e)(D(vt, 9), D(at, 10), D(_r, 10), D(xn, 10), D(Pr, 8), D(zr, 8)) } } static { this.\u0275dir = j({ type: e, selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]], inputs: { name: "name", isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"], options: ["ngModelOptions", "options"] }, outputs: { update: "ngModelChange" }, exportAs: ["ngModel"], features: [fe([yV]), pe, kt] }) } } return e })(), Gr = (() => { class e { static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275dir = j({ type: e, selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]], hostAttrs: ["novalidate", ""] }) } } return e })(), d1 = (() => { class e { static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275mod = bt({ type: e }) } static { this.\u0275inj = ct({}) } } return e })(); const bp = new A("NgModelWithFormControlWarning"), IV = { provide: vt, useExisting: De(() => qr) }; let qr = (() => { class e extends vt { constructor(t, r, i) { super(), this.callSetDisabledState = i, this.submitted = !1, this._onCollectionChange = () => this._updateDomValue(), this.directives = [], this.form = null, this.ngSubmit = new se, this._setValidators(t), this._setAsyncValidators(r) } ngOnChanges(t) { this._checkFormPresent(), t.hasOwnProperty("form") && (this._updateValidators(), this._updateDomValue(), this._updateRegistrations(), this._oldForm = this.form) } ngOnDestroy() { this.form && (Lc(this.form, this), this.form._onCollectionChange === this._onCollectionChange && this.form._registerOnCollectionChange(() => { })) } get formDirective() { return this } get control() { return this.form } get path() { return [] } addControl(t) { const r = this.form.get(t.path); return Ks(r, t, this.callSetDisabledState), r.updateValueAndValidity({ emitEvent: !1 }), this.directives.push(t), r } getControl(t) { return this.form.get(t.path) } removeControl(t) { Oc(t.control || null, t, !1), function gV(e, n) { const t = e.indexOf(n); t > -1 && e.splice(t, 1) }(this.directives, t) } addFormGroup(t) { this._setUpFormContainer(t) } removeFormGroup(t) { this._cleanUpFormContainer(t) } getFormGroup(t) { return this.form.get(t.path) } addFormArray(t) { this._setUpFormContainer(t) } removeFormArray(t) { this._cleanUpFormContainer(t) } getFormArray(t) { return this.form.get(t.path) } updateModel(t, r) { this.form.get(t.path).setValue(r) } onSubmit(t) { return this.submitted = !0, r1(this.form, this.directives), this.ngSubmit.emit(t), "dialog" === t?.target?.method } onReset() { this.resetForm() } resetForm(t = void 0) { this.form.reset(t), this.submitted = !1 } _updateDomValue() { this.directives.forEach(t => { const r = t.control, i = this.form.get(t.path); r !== i && (Oc(r || null, t), (e => e instanceof Xs)(i) && (Ks(i, t, this.callSetDisabledState), t.control = i)) }), this.form._updateTreeValidity({ emitEvent: !1 }) } _setUpFormContainer(t) { const r = this.form.get(t.path); n1(r, t), r.updateValueAndValidity({ emitEvent: !1 }) } _cleanUpFormContainer(t) { if (this.form) { const r = this.form.get(t.path); r && function fV(e, n) { return Lc(e, n) }(r, t) && r.updateValueAndValidity({ emitEvent: !1 }) } } _updateRegistrations() { this.form._registerOnCollectionChange(this._onCollectionChange), this._oldForm && this._oldForm._registerOnCollectionChange(() => { }) } _updateValidators() { mp(this.form, this), this._oldForm && Lc(this._oldForm, this) } _checkFormPresent() { } static { this.\u0275fac = function (r) { return new (r || e)(D(at, 10), D(_r, 10), D(zr, 8)) } } static { this.\u0275dir = j({ type: e, selectors: [["", "formGroup", ""]], hostBindings: function (r, i) { 1 & r && R("submit", function (s) { return i.onSubmit(s) })("reset", function () { return i.onReset() }) }, inputs: { form: ["formGroup", "form"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [fe([IV]), pe, kt] }) } } return e })(); const xV = { provide: vr, useExisting: De(() => ho) }; let ho = (() => { class e extends vr { set isDisabled(t) { } static { this._ngModelWarningSentOnce = !1 } constructor(t, r, i, o, s) { super(), this._ngModelWarningConfig = s, this._added = !1, this.name = null, this.update = new se, this._ngModelWarningSent = !1, this._parent = t, this._setValidators(r), this._setAsyncValidators(i), this.valueAccessor = yp(0, o) } ngOnChanges(t) { this._added || this._setUpControl(), vp(t, this.viewModel) && (this.viewModel = this.model, this.formDirective.updateModel(this, this.model)) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } viewToModelUpdate(t) { this.viewModel = t, this.update.emit(t) } get path() { return Nc(null == this.name ? this.name : this.name.toString(), this._parent) } get formDirective() { return this._parent ? this._parent.formDirective : null } _checkParentType() { } _setUpControl() { this._checkParentType(), this.control = this.formDirective.addControl(this), this._added = !0 } static { this.\u0275fac = function (r) { return new (r || e)(D(vt, 13), D(at, 10), D(_r, 10), D(xn, 10), D(bp, 8)) } } static { this.\u0275dir = j({ type: e, selectors: [["", "formControlName", ""]], inputs: { name: ["formControlName", "name"], isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"] }, outputs: { update: "ngModelChange" }, features: [fe([xV]), pe, kt] }) } } return e })(); const MV = { provide: xn, useExisting: De(() => ea), multi: !0 }; function m1(e, n) { return null == e ? `${n}` : (n && "object" == typeof n && (n = "Object"), `${e}: ${n}`.slice(0, 50)) } let ea = (() => { class e extends Ur { constructor() { super(...arguments), this._optionMap = new Map, this._idCounter = 0, this._compareWith = Object.is } set compareWith(t) { this._compareWith = t } writeValue(t) { this.value = t; const i = m1(this._getOptionId(t), t); this.setProperty("value", i) } registerOnChange(t) { this.onChange = r => { this.value = this._getOptionValue(r), t(this.value) } } _registerOption() { return (this._idCounter++).toString() } _getOptionId(t) { for (const r of this._optionMap.keys()) if (this._compareWith(this._optionMap.get(r), t)) return r; return null } _getOptionValue(t) { const r = function AV(e) { return e.split(":")[0] }(t); return this._optionMap.has(r) ? this._optionMap.get(r) : t } static { this.\u0275fac = function () { let t; return function (i) { return (t || (t = et(e)))(i || e) } }() } static { this.\u0275dir = j({ type: e, selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]], hostBindings: function (r, i) { 1 & r && R("change", function (s) { return i.onChange(s.target.value) })("blur", function () { return i.onTouched() }) }, inputs: { compareWith: "compareWith" }, features: [fe([MV]), pe] }) } } return e })(), wp = (() => { class e { constructor(t, r, i) { this._element = t, this._renderer = r, this._select = i, this._select && (this.id = this._select._registerOption()) } set ngValue(t) { null != this._select && (this._select._optionMap.set(this.id, t), this._setElementValue(m1(this.id, t)), this._select.writeValue(this._select.value)) } set value(t) { this._setElementValue(t), this._select && this._select.writeValue(this._select.value) } _setElementValue(t) { this._renderer.setProperty(this._element.nativeElement, "value", t) } ngOnDestroy() { this._select && (this._select._optionMap.delete(this.id), this._select.writeValue(this._select.value)) } static { this.\u0275fac = function (r) { return new (r || e)(D(tt), D(Ln), D(ea, 9)) } } static { this.\u0275dir = j({ type: e, selectors: [["option"]], inputs: { ngValue: "ngValue", value: "value" } }) } } return e })(); const kV = { provide: xn, useExisting: De(() => Ep), multi: !0 }; function _1(e, n) { return null == e ? `${n}` : ("string" == typeof n && (n = `'${n}'`), n && "object" == typeof n && (n = "Object"), `${e}: ${n}`.slice(0, 50)) } let Ep = (() => { class e extends Ur { constructor() { super(...arguments), this._optionMap = new Map, this._idCounter = 0, this._compareWith = Object.is } set compareWith(t) { this._compareWith = t } writeValue(t) { let r; if (this.value = t, Array.isArray(t)) { const i = t.map(o => this._getOptionId(o)); r = (o, s) => { o._setSelected(i.indexOf(s.toString()) > -1) } } else r = (i, o) => { i._setSelected(!1) }; this._optionMap.forEach(r) } registerOnChange(t) { this.onChange = r => { const i = [], o = r.selectedOptions; if (void 0 !== o) { const s = o; for (let a = 0; a < s.length; a++) { const c = this._getOptionValue(s[a].value); i.push(c) } } else { const s = r.options; for (let a = 0; a < s.length; a++) { const l = s[a]; if (l.selected) { const c = this._getOptionValue(l.value); i.push(c) } } } this.value = i, t(i) } } _registerOption(t) { const r = (this._idCounter++).toString(); return this._optionMap.set(r, t), r } _getOptionId(t) { for (const r of this._optionMap.keys()) if (this._compareWith(this._optionMap.get(r)._value, t)) return r; return null } _getOptionValue(t) { const r = function RV(e) { return e.split(":")[0] }(t); return this._optionMap.has(r) ? this._optionMap.get(r)._value : t } static { this.\u0275fac = function () { let t; return function (i) { return (t || (t = et(e)))(i || e) } }() } static { this.\u0275dir = j({ type: e, selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]], hostBindings: function (r, i) { 1 & r && R("change", function (s) { return i.onChange(s.target) })("blur", function () { return i.onTouched() }) }, inputs: { compareWith: "compareWith" }, features: [fe([kV]), pe] }) } } return e })(), Ip = (() => { class e { constructor(t, r, i) { this._element = t, this._renderer = r, this._select = i, this._select && (this.id = this._select._registerOption(this)) } set ngValue(t) { null != this._select && (this._value = t, this._setElementValue(_1(this.id, t)), this._select.writeValue(this._select.value)) } set value(t) { this._select ? (this._value = t, this._setElementValue(_1(this.id, t)), this._select.writeValue(this._select.value)) : this._setElementValue(t) } _setElementValue(t) { this._renderer.setProperty(this._element.nativeElement, "value", t) } _setSelected(t) { this._renderer.setProperty(this._element.nativeElement, "selected", t) } ngOnDestroy() { this._select && (this._select._optionMap.delete(this.id), this._select.writeValue(this._select.value)) } static { this.\u0275fac = function (r) { return new (r || e)(D(tt), D(Ln), D(Ep, 9)) } } static { this.\u0275dir = j({ type: e, selectors: [["option"]], inputs: { ngValue: "ngValue", value: "value" } }) } } return e })(), Wr = (() => { class e { constructor() { this._validator = xc } ngOnChanges(t) { if (this.inputName in t) { const r = this.normalizeInput(t[this.inputName].currentValue); this._enabled = this.enabled(r), this._validator = this._enabled ? this.createValidator(r) : xc, this._onChange && this._onChange() } } validate(t) { return this._validator(t) } registerOnValidatorChange(t) { this._onChange = t } enabled(t) { return null != t } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275dir = j({ type: e, features: [kt] }) } } return e })(); const OV = { provide: at, useExisting: De(() => jc), multi: !0 }; let jc = (() => { class e extends Wr { constructor() { super(...arguments), this.inputName = "required", this.normalizeInput = Yi, this.createValidator = t => kw } enabled(t) { return t } static { this.\u0275fac = function () { let t; return function (i) { return (t || (t = et(e)))(i || e) } }() } static { this.\u0275dir = j({ type: e, selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]], hostVars: 1, hostBindings: function (r, i) { 2 & r && nt("required", i._enabled ? "" : null) }, inputs: { required: "required" }, features: [fe([OV]), pe] }) } } return e })(), T1 = (() => { class e { static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275mod = bt({ type: e }) } static { this.\u0275inj = ct({ imports: [d1] }) } } return e })(); class x1 extends Pc { constructor(n, t, r) { super(pp(t), gp(r, t)), this.controls = n, this._initObservables(), this._setUpdateStrategy(t), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } at(n) { return this.controls[this._adjustIndex(n)] } push(n, t = {}) { this.controls.push(n), this._registerControl(n), this.updateValueAndValidity({ emitEvent: t.emitEvent }), this._onCollectionChange() } insert(n, t, r = {}) { this.controls.splice(n, 0, t), this._registerControl(t), this.updateValueAndValidity({ emitEvent: r.emitEvent }) } removeAt(n, t = {}) { let r = this._adjustIndex(n); r < 0 && (r = 0), this.controls[r] && this.controls[r]._registerOnCollectionChange(() => { }), this.controls.splice(r, 1), this.updateValueAndValidity({ emitEvent: t.emitEvent }) } setControl(n, t, r = {}) { let i = this._adjustIndex(n); i < 0 && (i = 0), this.controls[i] && this.controls[i]._registerOnCollectionChange(() => { }), this.controls.splice(i, 1), t && (this.controls.splice(i, 0, t), this._registerControl(t)), this.updateValueAndValidity({ emitEvent: r.emitEvent }), this._onCollectionChange() } get length() { return this.controls.length } setValue(n, t = {}) { Jw(this, 0, n), n.forEach((r, i) => { Xw(this, !1, i), this.at(i).setValue(r, { onlySelf: !0, emitEvent: t.emitEvent }) }), this.updateValueAndValidity(t) } patchValue(n, t = {}) { null != n && (n.forEach((r, i) => { this.at(i) && this.at(i).patchValue(r, { onlySelf: !0, emitEvent: t.emitEvent }) }), this.updateValueAndValidity(t)) } reset(n = [], t = {}) { this._forEachChild((r, i) => { r.reset(n[i], { onlySelf: !0, emitEvent: t.emitEvent }) }), this._updatePristine(t), this._updateTouched(t), this.updateValueAndValidity(t) } getRawValue() { return this.controls.map(n => n.getRawValue()) } clear(n = {}) { this.controls.length < 1 || (this._forEachChild(t => t._registerOnCollectionChange(() => { })), this.controls.splice(0), this.updateValueAndValidity({ emitEvent: n.emitEvent })) } _adjustIndex(n) { return n < 0 ? n + this.length : n } _syncPendingControls() { let n = this.controls.reduce((t, r) => !!r._syncPendingControls() || t, !1); return n && this.updateValueAndValidity({ onlySelf: !0 }), n } _forEachChild(n) { this.controls.forEach((t, r) => { n(t, r) }) } _updateValue() { this.value = this.controls.filter(n => n.enabled || this.disabled).map(n => n.value) } _anyControls(n) { return this.controls.some(t => t.enabled && n(t)) } _setUpControls() { this._forEachChild(n => this._registerControl(n)) } _allControlsDisabled() { for (const n of this.controls) if (n.enabled) return !1; return this.controls.length > 0 || this.disabled } _registerControl(n) { n.setParent(this), n._registerOnCollectionChange(this._onCollectionChange) } _find(n) { return this.at(n) ?? null } } function M1(e) { return !!e && (void 0 !== e.asyncValidators || void 0 !== e.validators || void 0 !== e.updateOn) } let Vc = (() => { class e { constructor() { this.useNonNullable = !1 } get nonNullable() { const t = new e; return t.useNonNullable = !0, t } group(t, r = null) { const i = this._reduceControls(t); let o = {}; return M1(r) ? o = r : null !== r && (o.validators = r.validator, o.asyncValidators = r.asyncValidator), new Ws(i, o) } record(t, r = null) { const i = this._reduceControls(t); return new e1(i, r) } control(t, r, i) { let o = {}; return this.useNonNullable ? (M1(r) ? o = r : (o.validators = r, o.asyncValidators = i), new Xs(t, { ...o, nonNullable: !0 })) : new Xs(t, r, i) } array(t, r, i) { const o = t.map(s => this._createControl(s)); return new x1(o, r, i) } _reduceControls(t) { const r = {}; return Object.keys(t).forEach(i => { r[i] = this._createControl(t[i]) }), r } _createControl(t) { return t instanceof Xs || t instanceof Pc ? t : Array.isArray(t) ? this.control(t[0], t.length > 1 ? t[1] : null, t.length > 2 ? t[2] : null) : this.control(t) } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(), UV = (() => { class e { static withConfig(t) { return { ngModule: e, providers: [{ provide: zr, useValue: t.callSetDisabledState ?? Zs }] } } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275mod = bt({ type: e }) } static { this.\u0275inj = ct({ imports: [T1] }) } } return e })(), HV = (() => { class e { static withConfig(t) { return { ngModule: e, providers: [{ provide: bp, useValue: t.warnOnNgModelWithFormControl ?? "always" }, { provide: zr, useValue: t.callSetDisabledState ?? Zs }] } } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275mod = bt({ type: e }) } static { this.\u0275inj = ct({ imports: [T1] }) } } return e })(); function $V(e, n) { if (1 & e && (f(0, "div", 10), g(1), h()), 2 & e) { const t = E(); _(1), te(t.success) } } function zV(e, n) { if (1 & e && (f(0, "div", 11), g(1), h()), 2 & e) { const t = E(); _(1), te(t.error) } } function GV(e, n) { 1 & e && (f(0, "div", 12), g(1, " Enter a valid email. "), h()) } function qV(e, n) { 1 & e && (f(0, "div", 12), g(1, " Password must be at least 6 characters. "), h()) } let WV = (() => { class e { constructor(t, r, i, o, s) { this.fb = t, this.auth = r, this.router = i, this.route = o, this.api = s, this.loading = !1, this.error = "", this.success = "", this.inviteToken = null, this.form = this.fb.group({ email: ["", [jt.required, jt.email]], password: ["", [jt.required, jt.minLength(6)]] }) } ngOnInit() { this.route.queryParamMap.subscribe(t => { this.inviteToken = t.get("token"), "1" === t.get("registered") && (this.success = "Account created. Please log in.") }) } submit() { this.form.invalid ? this.form.markAllAsTouched() : (this.loading = !0, this.auth.login({ email: this.form.value.email ?? "", password: this.form.value.password ?? "", inviteToken: this.inviteToken || void 0 }).subscribe({ next: s => { this.loading = !1, this.router.navigate(["/dashboard"]) }, error: s => { this.error = s?.error?.message || s?.message || "Login failed", this.loading = !1 } })) } static { this.\u0275fac = function (r) { return new (r || e)(D(Vc), D(Tn), D(Re), D(ln), D(gr)) } } static { this.\u0275cmp = rt({ type: e, selectors: [["app-login"]], decls: 19, vars: 7, consts: [[1, "space-y-4", 3, "formGroup", "ngSubmit"], ["class", "text-green-600 text-sm", 4, "ngIf"], ["class", "text-red-600 text-sm", 4, "ngIf"], [1, "text-sm", "font-medium"], ["type", "email", "formControlName", "email", 1, "mt-1", "w-full"], ["class", "text-xs text-red-600 mt-1", 4, "ngIf"], ["type", "password", "formControlName", "password", 1, "mt-1", "w-full"], ["type", "submit", 1, "w-full", "py-2", "bg-blue-600", "text-white", "rounded", "hover:bg-blue-500", "disabled:opacity-60", 3, "disabled"], [1, "text-sm", "text-center"], ["routerLink", "/register", 1, "text-brand-600", "hover:underline"], [1, "text-green-600", "text-sm"], [1, "text-red-600", "text-sm"], [1, "text-xs", "text-red-600", "mt-1"]], template: function (r, i) { 1 & r && (f(0, "form", 0), R("ngSubmit", function () { return i.submit() }), I(1, $V, 2, 1, "div", 1), I(2, zV, 2, 1, "div", 2), f(3, "div")(4, "label", 3), g(5, "Email"), h(), M(6, "input", 4), I(7, GV, 2, 0, "div", 5), h(), f(8, "div")(9, "label", 3), g(10, "Password"), h(), M(11, "input", 6), I(12, qV, 2, 0, "div", 5), h(), f(13, "button", 7), g(14), h(), f(15, "div", 8), g(16, " No account? "), f(17, "a", 9), g(18, "Register"), h()()()), 2 & r && (b("formGroup", i.form), _(1), b("ngIf", i.success), _(1), b("ngIf", i.error), _(5), b("ngIf", i.form.controls.email.touched && i.form.controls.email.invalid), _(5), b("ngIf", i.form.controls.password.touched && i.form.controls.password.invalid), _(1), b("disabled", i.loading), _(1), U(" ", i.loading ? "Signing in..." : "Login", "\n")) }, dependencies: [Dn, Gr, Kn, Hr, $r, qr, ho, In], encapsulation: 2 }) } } return e })(); function ZV(e, n) { if (1 & e && (f(0, "div", 13), g(1), h()), 2 & e) { const t = E(); _(1), te(t.error) } } function KV(e, n) { 1 & e && (f(0, "div", 14), g(1, " Enter a valid email. "), h()) } function YV(e, n) { 1 & e && (f(0, "div", 14), g(1, " Min 6 characters. "), h()) } function QV(e, n) { 1 & e && (f(0, "div", 14), g(1, " Passwords do not match. "), h()) } function XV(e, n) { return t => { const r = t.get(e), i = t.get(n); return r && i && r.value !== i.value ? { mismatch: !0 } : null } } let JV = (() => { class e { constructor(t, r, i, o) { this.fb = t, this.auth = r, this.router = i, this.route = o, this.loading = !1, this.error = "", this.form = this.fb.group({ firstname: [""], lastname: [""], email: ["", [jt.required, jt.email]], password: ["", [jt.required, jt.minLength(6)]], confirmPassword: ["", [jt.required]] }, { validators: XV("password", "confirmPassword") }) } submit() { if (this.form.invalid) return void this.form.markAllAsTouched(); const { firstname: t, lastname: r, email: i, password: o } = this.form.value, s = this.route.snapshot.queryParamMap.get("token") || void 0; this.loading = !0, this.auth.register({ email: i, password: o, firstname: t || void 0, lastname: r || void 0, inviteToken: s }).subscribe({ next: () => { this.loading = !1, this.router.navigate(["/login"], { queryParams: { registered: "1" } }) }, error: a => { this.error = a?.error?.message || a?.message || "Register failed", this.loading = !1 } }) } static { this.\u0275fac = function (r) { return new (r || e)(D(Vc), D(Tn), D(Re), D(ln)) } } static { this.\u0275cmp = rt({ type: e, selectors: [["app-register"]], decls: 32, vars: 7, consts: [[1, "space-y-4", 3, "formGroup", "ngSubmit"], ["class", "text-red-600 text-sm", 4, "ngIf"], [1, "grid", "grid-cols-1", "md:grid-cols-2", "gap-3"], [1, "text-sm", "font-medium"], ["type", "text", "formControlName", "firstname", 1, "mt-1", "w-full"], ["type", "text", "formControlName", "lastname", 1, "mt-1", "w-full"], ["type", "email", "formControlName", "email", 1, "mt-1", "w-full"], ["class", "text-xs text-red-600 mt-1", 4, "ngIf"], ["type", "password", "formControlName", "password", 1, "mt-1", "w-full"], ["type", "password", "formControlName", "confirmPassword", 1, "mt-1", "w-full"], ["type", "submit", 1, "w-full", "py-2", "bg-blue-600", "text-white", "rounded", "hover:bg-blue-500", "disabled:opacity-60", 3, "disabled"], [1, "text-sm", "text-center"], ["routerLink", "/login", 1, "text-brand-600", "hover:underline"], [1, "text-red-600", "text-sm"], [1, "text-xs", "text-red-600", "mt-1"]], template: function (r, i) { 1 & r && (f(0, "form", 0), R("ngSubmit", function () { return i.submit() }), I(1, ZV, 2, 1, "div", 1), f(2, "div", 2)(3, "div")(4, "label", 3), g(5, "First name"), h(), M(6, "input", 4), h(), f(7, "div")(8, "label", 3), g(9, "Last name"), h(), M(10, "input", 5), h()(), f(11, "div")(12, "label", 3), g(13, "Email"), h(), M(14, "input", 6), I(15, KV, 2, 0, "div", 7), h(), f(16, "div")(17, "label", 3), g(18, "Password"), h(), M(19, "input", 8), I(20, YV, 2, 0, "div", 7), h(), f(21, "div")(22, "label", 3), g(23, "Confirm Password"), h(), M(24, "input", 9), I(25, QV, 2, 0, "div", 7), h(), f(26, "button", 10), g(27), h(), f(28, "div", 11), g(29, " Have an account? "), f(30, "a", 12), g(31, "Login"), h()()()), 2 & r && (b("formGroup", i.form), _(1), b("ngIf", i.error), _(14), b("ngIf", i.form.controls.email.touched && i.form.controls.email.invalid), _(5), b("ngIf", i.form.controls.password.touched && i.form.controls.password.invalid), _(5), b("ngIf", i.form.hasError("mismatch") && i.form.controls.confirmPassword.touched), _(1), b("disabled", i.loading), _(1), U(" ", i.loading ? "Creating account..." : "Create account", "\n")) }, dependencies: [Dn, Gr, Kn, Hr, $r, qr, ho, In], encapsulation: 2 }) } } return e })(), e4 = (() => { class e { constructor(t, r) { this.auth = t, this.router = r } canActivate() { return !!this.auth.isLoggedIn() || (this.router.navigate(["/login"]), !1) } static { this.\u0275fac = function (r) { return new (r || e)(k(Tn), k(Re)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(), t4 = (() => { class e { static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275cmp = rt({ type: e, selectors: [["app-not-found"]], decls: 5, vars: 0, consts: [[1, "text-center", "py-24"], [1, "text-6xl", "font-bold", "text-slate-300"], [1, "text-slate-500", "mt-2"]], template: function (r, i) { 1 & r && (f(0, "div", 0)(1, "div", 1), g(2, "404"), h(), f(3, "div", 2), g(4, "Page not found"), h()()) } }) } } return e })(); function n4(e, n) { if (1 & e && (ge(0), g(1), qt(2, "slice"), me()), 2 & e) { const t = n.ngIf; _(1), U(" ", zi(2, 1, t.firstname || t.lastname ? t.firstname || t.lastname : t.email, 0, 1), " ") } } function r4(e, n) { if (1 & e && (ge(0), g(1), me()), 2 & e) { const t = E().ngIf; _(1), vf(" ", t.firstname, " ", t.lastname, " ") } } function i4(e, n) { 1 & e && (f(0, "span", 30), g(1, "Not set"), h()) } function o4(e, n) { if (1 & e && (f(0, "div", 15)(1, "div", 16)(2, "span", 17), Ee(), f(3, "svg", 18), M(4, "circle", 19)(5, "path", 20), h()(), Le(), f(6, "div", 21)(7, "div", 22), g(8, "Full Name"), h(), f(9, "div", 23), I(10, r4, 2, 2, "ng-container", 24), I(11, i4, 2, 0, "ng-template", null, 25, qe), h()()(), f(13, "div", 26)(14, "span", 17), Ee(), f(15, "svg", 18), M(16, "rect", 27)(17, "path", 28), h()(), Le(), f(18, "div", 21)(19, "div", 22), g(20, "Email"), h(), f(21, "div", 29), g(22), h()()()()), 2 & e) { const t = n.ngIf, r = Ve(12); _(10), b("ngIf", t.firstname || t.lastname)("ngIfElse", r), _(12), te(t.email) } } function s4(e, n) { 1 & e && (f(0, "div", 31), g(1, " No user data "), h()) } let A1 = (() => { class e { constructor(t) { this.auth = t, this.user$ = this.auth.currentUser$ } static { this.\u0275fac = function (r) { return new (r || e)(D(Tn)) } } static { this.\u0275cmp = rt({ type: e, selectors: [["app-profile"]], decls: 20, vars: 7, consts: [[1, "relative", "min-h-[70vh]", "grid", "place-items-center"], [1, "absolute", "inset-0", "-z-10", "opacity-60", "pointer-events-none", 2, "background", "radial-gradient(600px circle at 10% 20%, rgba(56,189,248,.12), transparent 40%),\n         radial-gradient(800px circle at 90% 30%, rgba(139,92,246,.12), transparent 40%),\n         radial-gradient(700px circle at 50% 80%, rgba(16,185,129,.12), transparent 40%)"], [1, "w-full", "max-w-lg", "bg-white/90", "backdrop-blur", "border", "border-slate-200", "rounded-3xl", "shadow-2xl", "overflow-hidden"], [1, "relative", "h-24", "bg-gradient-to-r", "from-sky-400", "via-violet-500", "to-emerald-500"], [1, "px-6", "pb-6"], [1, "-mt-10", "flex", "items-center", "gap-4"], [1, "relative"], [1, "w-20", "h-20", "rounded-full", "ring-4", "ring-white", "grid", "place-items-center", "text-slate-800", "font-semibold", "bg-white", "shadow-md", "border", "border-slate-200"], [4, "ngIf"], [1, "absolute", "-bottom-1", "-right-1", "w-5", "h-5", "rounded-full", "border-2", "border-white", "bg-emerald-500"], [1, "min-w-0"], [1, "text-xl", "font-semibold", "text-black", "leading-tight", "drop-shadow"], [1, "text-xs", "text-black-200", "drop-shadow-sm"], ["class", "mt-6", 4, "ngIf", "ngIfElse"], ["empty", ""], [1, "mt-6"], [1, "flex", "items-start", "gap-3", "mb-4"], [1, "mt-0.5", "inline-flex", "items-center", "justify-center", "w-8", "h-8", "rounded-lg", "bg-slate-100", "text-slate-700"], ["viewBox", "0 0 24 24", "fill", "none", "stroke", "currentColor", "stroke-width", "1.8", "stroke-linecap", "round", "stroke-linejoin", "round", "aria-hidden", "true", 1, "w-4.5", "h-4.5"], ["cx", "12", "cy", "8", "r", "3"], ["d", "M4 20a8 8 0 0 1 16 0"], [1, "flex-1", "min-w-0"], [1, "text-xs", "font-medium", "text-slate-500"], [1, "font-medium", "text-slate-800", "mt-0.5"], [4, "ngIf", "ngIfElse"], ["noName", ""], [1, "flex", "items-start", "gap-3"], ["x", "3", "y", "5", "width", "18", "height", "14", "rx", "2"], ["d", "M3 7l9 6 9-6"], [1, "font-medium", "text-slate-800", "mt-0.5", "break-words"], [1, "px-2", "py-0.5", "rounded-full", "border", "text-xs", "bg-slate-50", "text-slate-600"], [1, "mt-6", "rounded-xl", "border", "border-dashed", "border-slate-300", "p-6", "text-center", "text-slate-500", "bg-slate-50/60"]], template: function (r, i) { if (1 & r && (f(0, "div", 0), M(1, "div", 1), f(2, "div", 2), M(3, "div", 3), f(4, "div", 4)(5, "div", 5)(6, "div", 6)(7, "div", 7), I(8, n4, 3, 5, "ng-container", 8), qt(9, "async"), h(), M(10, "div", 9), h(), f(11, "div", 10)(12, "div", 11), g(13, "Profile"), h(), f(14, "div", 12), g(15, "Your account details"), h()()(), I(16, o4, 23, 3, "div", 13), qt(17, "async"), I(18, s4, 2, 0, "ng-template", null, 14, qe), h()()()), 2 & r) { const o = Ve(19); _(8), b("ngIf", gs(9, 3, i.user$)), _(8), b("ngIf", gs(17, 5, i.user$))("ngIfElse", o) } }, dependencies: [Dn, vh, tc] }) } } return e })(); function a4(e, n) { 1 & e && M(0, "span", 28) } function l4(e, n) { if (1 & e && (ge(0), g(1), me()), 2 & e) { const t = E(); _(1), U(" ", (null == t.projects ? null : t.projects.length) || 0, " total ") } } function c4(e, n) { 1 & e && M(0, "span", 29) } function u4(e, n) { 1 & e && (f(0, "div", 32)(1, "div", 33)(2, "div")(3, "div", 5), M(4, "span", 34)(5, "div", 35), h(), M(6, "div", 36), h(), M(7, "div", 37), h()()) } const d4 = function () { return [1, 2, 3, 4, 5] }; function f4(e, n) { 1 & e && (f(0, "div", 30), I(1, u4, 8, 0, "div", 31), h()), 2 & e && (_(1), b("ngForOf", Gt(1, d4))) } function h4(e, n) { 1 & e && (f(0, "div", 38), g(1, " No projects yet. Create your first project on the left. "), h()) } const p4 = function (e) { return ["/projects", e, "board"] }; function g4(e, n) { if (1 & e && (f(0, "li", 46)(1, "div", 47)(2, "div")(3, "div", 5)(4, "span", 48)(5, "span", 49), g(6, "folder"), h()(), f(7, "div", 50), g(8), h()(), f(9, "div", 51), g(10), h()(), f(11, "div", 5)(12, "a", 52), g(13, " Open board "), h()()()()), 2 & e) { const t = n.$implicit; _(8), te(t.name), _(2), U(" ", t.description || "No description provided.", " "), _(2), b("routerLink", Mf(3, p4, t.id)) } } function m4(e, n) { if (1 & e) { const t = ve(); ge(0), f(1, "button", 53), R("click", function () { const o = V(t).$implicit; return B(E(2).setProjectsPage(o)) }), g(2), h(), me() } if (2 & e) { const t = n.$implicit, r = E(2); _(1), b("ngClass", t === r.projectsPage ? "bg-slate-900 text-white border-slate-900" : "bg-white text-slate-700 border-slate-300 hover:bg-slate-50"), nt("aria-current", t === r.projectsPage ? "page" : null), _(1), U(" ", t, " ") } } function _4(e, n) { if (1 & e) { const t = ve(); ge(0), f(1, "ul", 30), I(2, g4, 14, 5, "li", 39), h(), f(3, "div", 40)(4, "div", 41), g(5), h(), f(6, "div", 42)(7, "button", 43), R("click", function () { return V(t), B(E().prevProjectsPage()) }), g(8, " Prev "), h(), I(9, m4, 3, 3, "ng-container", 44), f(10, "button", 45), R("click", function () { return V(t), B(E().nextProjectsPage()) }), g(11, " Next "), h()()(), me() } if (2 & e) { const t = E(); _(2), b("ngForOf", t.projectsPaged)("ngForTrackBy", t.trackProjectById), _(3), Ui(" Showing ", t.projectsPageStart + 1, "\u2013", t.projectsPageEnd, " of ", t.projects.length, " "), _(2), b("disabled", 1 === t.projectsPage), _(2), b("ngForOf", t.projectsPages), _(1), b("disabled", t.projectsPage === t.projectsTotalPages) } } let k1 = (() => { class e { get projectsTotalPages() { return Math.max(1, Math.ceil(this.projects.length / this.projectsPageSize)) } get projectsPageStart() { return (this.projectsPage - 1) * this.projectsPageSize } get projectsPageEnd() { return Math.min(this.projectsPageStart + this.projectsPageSize, this.projects.length) } get projectsPaged() { return this.projects.slice(this.projectsPageStart, this.projectsPageEnd) } get projectsPages() { return Array.from({ length: this.projectsTotalPages }, (t, r) => r + 1) } setProjectsPage(t) { this.projectsPage = Math.min(Math.max(1, t), this.projectsTotalPages) } prevProjectsPage() { this.setProjectsPage(this.projectsPage - 1) } nextProjectsPage() { this.setProjectsPage(this.projectsPage + 1) } trackProjectById(t, r) { return r.id ?? t } constructor(t, r) { this.api = t, this.fb = r, this.projects = [], this.projectsLoading = !0, this.form = this.fb.group({ name: ["", [jt.required, jt.minLength(2)]], description: [""] }), this.loading = !1, this.projectsPageSize = 5, this.projectsPage = 1 } ngOnInit() { this.loadProjects(), this.load() } load() { this.api.getProjects().subscribe(t => { this.projects = t || [], this.projectsPage > this.projectsTotalPages && (this.projectsPage = this.projectsTotalPages) }) } create() { this.form.invalid ? this.form.markAllAsTouched() : (this.loading = !0, this.api.createProject(this.form.value).subscribe({ next: () => { this.form.reset(), this.loading = !1, this.load() }, error: () => this.loading = !1 })) } loadProjects() { this.projectsLoading = !0, this.api.getProjects().pipe(Yt(() => this.projectsLoading = !1)).subscribe({ next: t => { this.projects = t || [], this.projectsPage > this.projectsTotalPages && (this.projectsPage = this.projectsTotalPages) }, error: () => { this.projects = [], this.projectsPage = 1 } }) } static { this.\u0275fac = function (r) { return new (r || e)(D(gr), D(Vc)) } } static { this.\u0275cmp = rt({ type: e, selectors: [["app-projects"]], decls: 50, vars: 9, consts: [[1, "grid", "lg:grid-cols-2", "gap-6"], [1, "relative", "overflow-hidden", "rounded-2xl", "border", "border-slate-200", "bg-white"], [1, "h-1", "w-full", "bg-gradient-to-r", "from-sky-400", "via-violet-500", "to-emerald-500"], [1, "p-5"], [1, "flex", "items-center", "justify-between", "mb-4"], [1, "flex", "items-center", "gap-2"], ["aria-hidden", "true", 1, "material-symbols-outlined", "text-xl", "text-slate-700"], [1, "font-semibold", "text-lg"], [1, "text-xs", "px-2", "py-1", "rounded-full", "border", "bg-slate-50", "text-slate-600"], [1, "space-y-4", 3, "formGroup", "ngSubmit"], [1, "text-sm", "font-medium", "text-slate-700"], [1, "mt-1", "relative"], ["aria-hidden", "true", 1, "material-symbols-outlined", "absolute", "left-3", "top-1/2", "-translate-y-1/2", "text-slate-400"], ["formControlName", "name", 1, "w-full", "pl-9", "pr-3", "py-2", "rounded-lg", "border", "border-slate-300", "focus:outline-none", "focus:ring-2", "focus:ring-sky-300"], ["aria-hidden", "true", 1, "material-symbols-outlined", "absolute", "left-3", "top-3", "text-slate-400"], ["rows", "3", "formControlName", "description", 1, "w-full", "pl-9", "pr-3", "py-2", "rounded-lg", "border", "border-slate-300", "focus:outline-none", "focus:ring-2", "focus:ring-sky-300"], [1, "flex", "items-center", "gap-3"], [1, "px-4", "py-2", "rounded-lg", "text-white", "bg-gradient-to-r", "from-slate-900", "to-slate-700", "hover:from-slate-800", "hover:to-slate-700", "disabled:opacity-60", 3, "disabled"], [1, "inline-flex", "items-center", "gap-2"], ["class", "inline-block w-3.5 h-3.5 border-2 border-white/60 border-t-transparent rounded-full animate-spin", 4, "ngIf"], [1, "text-xs", "text-slate-500"], [1, "h-1", "w-full", "bg-gradient-to-r", "from-emerald-400", "via-sky-400", "to-violet-500"], [1, "flex", "items-center", "justify-between", "mb-3"], [4, "ngIf", "ngIfElse"], ["totalSkeleton", ""], ["class", "space-y-3", 4, "ngIf"], ["class", "border border-dashed rounded-xl p-6 text-center text-slate-500 bg-slate-50/60", 4, "ngIf"], [4, "ngIf"], [1, "inline-block", "w-3.5", "h-3.5", "border-2", "border-white/60", "border-t-transparent", "rounded-full", "animate-spin"], [1, "inline-block", "h-4", "w-16", "rounded", "bg-slate-200", "animate-pulse"], [1, "space-y-3"], ["class", "p-4 rounded-xl border border-slate-200 bg-white", 4, "ngFor", "ngForOf"], [1, "p-4", "rounded-xl", "border", "border-slate-200", "bg-white"], [1, "grid", "grid-cols-[1fr_auto]", "gap-3", "items-start", "animate-pulse"], [1, "inline-flex", "w-6", "h-6", "rounded-md", "bg-slate-200"], [1, "h-4", "w-40", "bg-slate-200", "rounded"], [1, "h-3", "w-3/4", "bg-slate-100", "rounded", "mt-2"], [1, "h-8", "w-24", "rounded-lg", "bg-slate-100"], [1, "border", "border-dashed", "rounded-xl", "p-6", "text-center", "text-slate-500", "bg-slate-50/60"], ["class", "group p-4 rounded-xl border border-slate-200 bg-white hover:shadow-sm transition", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "flex", "items-center", "justify-between", "mt-3"], [1, "text-sm", "text-slate-600"], [1, "flex", "items-center", "gap-1"], ["aria-label", "Previous page", 1, "px-3", "py-1.5", "rounded-md", "border", "border-slate-300", "bg-white", "text-slate-700", "hover:bg-slate-50", "disabled:opacity-50", 3, "disabled", "click"], [4, "ngFor", "ngForOf"], ["aria-label", "Next page", 1, "px-3", "py-1.5", "rounded-md", "border", "border-slate-300", "bg-white", "text-slate-700", "hover:bg-slate-50", "disabled:opacity-50", 3, "disabled", "click"], [1, "group", "p-4", "rounded-xl", "border", "border-slate-200", "bg-white", "hover:shadow-sm", "transition"], [1, "grid", "grid-cols-[1fr_auto]", "gap-3", "items-start"], [1, "inline-flex", "items-center", "justify-center", "w-6", "h-6", "rounded-md", "bg-slate-100", "border", "border-slate-200"], ["aria-hidden", "true", 1, "material-symbols-outlined", "text-[18px]", "text-slate-700"], [1, "font-semibold", "text-slate-800", "leading-tight"], [1, "text-sm", "text-slate-600", "mt-1", "line-clamp-2"], [1, "px-3", "py-1.5", "text-sm", "rounded-lg", "border", "border-slate-300", "hover:bg-slate-50", 3, "routerLink"], [1, "px-3", "py-1.5", "rounded-md", "border", 3, "ngClass", "click"]], template: function (r, i) { if (1 & r && (f(0, "div", 0)(1, "div", 1), M(2, "div", 2), f(3, "div", 3)(4, "div", 4)(5, "div", 5)(6, "span", 6), g(7, "rocket_launch"), h(), f(8, "div", 7), g(9, "Create Project"), h()(), f(10, "span", 8), g(11, "New"), h()(), f(12, "form", 9), R("ngSubmit", function () { return i.create() }), f(13, "div")(14, "label", 10), g(15, "Name"), h(), f(16, "div", 11)(17, "span", 12), g(18, "label"), h(), M(19, "input", 13), h()(), f(20, "div")(21, "label", 10), g(22, "Description"), h(), f(23, "div", 11)(24, "span", 14), g(25, "description"), h(), M(26, "textarea", 15), h()(), f(27, "div", 16)(28, "button", 17)(29, "span", 18), I(30, a4, 1, 0, "span", 19), g(31), h()(), f(32, "span", 20), g(33, "Tip: Keep names short and meaningful"), h()()()()(), f(34, "div", 1), M(35, "div", 21), f(36, "div", 3)(37, "div", 22)(38, "div", 5)(39, "span", 6), g(40, "folder_open"), h(), f(41, "div", 7), g(42, "Projects"), h()(), f(43, "div", 20), I(44, l4, 2, 1, "ng-container", 23), I(45, c4, 1, 0, "ng-template", null, 24, qe), h()(), I(47, f4, 2, 2, "div", 25), I(48, h4, 2, 0, "div", 26), I(49, _4, 12, 8, "ng-container", 27), h()()()), 2 & r) { const o = Ve(46); _(12), b("formGroup", i.form), _(16), b("disabled", i.loading), _(2), b("ngIf", i.loading), _(1), U(" ", i.loading ? "Creating..." : "Create", " "), _(13), b("ngIf", !i.projectsLoading)("ngIfElse", o), _(3), b("ngIf", i.projectsLoading), _(1), b("ngIf", !(i.projectsLoading || null != i.projects && i.projects.length)), _(1), b("ngIf", !i.projectsLoading && (null == i.projects ? null : i.projects.length)) } }, dependencies: [Xi, Fr, Dn, Gr, Kn, Hr, $r, qr, ho, In] }) } } return e })(); function v4(e, n) { if (1 & e && (f(0, "option", 55), g(1), h()), 2 & e) { const t = n.$implicit; b("ngValue", t.id), _(1), te(t.name || t.email) } } function y4(e, n) { if (1 & e) { const t = ve(); f(0, "div", 24)(1, "select", 54), R("ngModelChange", function (i) { return V(t), B(E(2).assignTo(i)) }), f(2, "option", 55), g(3, "Unassigned"), h(), I(4, v4, 2, 2, "option", 56), h(), f(5, "button", 57), R("click", function () { return V(t), B(E(2).assignToMe()) }), g(6, " Assign to me "), h()() } if (2 & e) { const t = E(2); _(1), Un("pointer-events", t.isEditing ? "auto" : "none"), zt("opacity-60", !t.isEditing), b("ngModel", t.selectedAssigneeId), _(1), b("ngValue", void 0), _(2), b("ngForOf", t.members), _(1), b("disabled", !t.meUserId || !t.isEditing) } } function b4(e, n) { if (1 & e && (f(0, "div", 58)(1, "span", 59), g(2), qt(3, "slice"), h(), f(4, "span", 60), g(5), h()()), 2 & e) { const t = E(2); _(2), U(" ", zi(3, 2, t.assigneeName || "U", 0, 1), " "), _(3), te(t.assigneeName || "Unassigned") } } function D4(e, n) { if (1 & e) { const t = ve(); ge(0), f(1, "button", 61), R("click", function () { return V(t), B(E(2).save()) }), Ee(), f(2, "svg", 62), M(3, "path", 63), h(), g(4), h(), Le(), f(5, "button", 64), R("click", function () { return V(t), B(E(2).cancelEdit()) }), g(6, " Cancel "), h(), me() } if (2 & e) { const t = E(2); _(1), b("disabled", t.loading), _(3), U(" ", t.loading ? "Saving\u2026" : "Save", " ") } } function C4(e, n) { if (1 & e) { const t = ve(); f(0, "button", 65), R("click", function () { return V(t), B(E(2).toggleEdit()) }), Ee(), f(1, "svg", 16), M(2, "path", 17)(3, "path", 18), h(), g(4, " Edit "), h() } } function w4(e, n) { if (1 & e) { const t = ve(); f(0, "div", 2)(1, "div", 3), R("click", function () { return V(t), B(E().close()) }), h(), f(2, "div", 4)(3, "div", 5)(4, "form", 6), M(5, "div", 7), f(6, "div", 8)(7, "div", 9)(8, "div", 10)(9, "button", 11), g(10, " Add epic "), h(), f(11, "span", 12), g(12, "/"), h(), f(13, "span", 13), g(14), h()(), f(15, "div", 14)(16, "button", 15), R("click", function () { return V(t), B(E().toggleEdit()) }), Ee(), f(17, "svg", 16), M(18, "path", 17)(19, "path", 18), h()(), Le(), f(20, "button", 19), R("click", function () { return V(t), B(E().close()) }), g(21, "\u2715"), h()()()(), f(22, "div", 20)(23, "div", 21)(24, "div", 22), M(25, "input", 23), h(), f(26, "div", 24)(27, "div", 25)(28, "select", 26)(29, "option", 27), g(30, "To Do"), h(), f(31, "option", 28), g(32, "In Progress"), h(), f(33, "option", 29), g(34, "Done"), h()(), f(35, "div", 30), g(36, "\u25be"), h()()()()(), f(37, "div", 31)(38, "div", 32)(39, "div", 33)(40, "div", 34)(41, "div", 35), g(42, "Description"), h(), f(43, "button", 36), g(44, "\u22ef"), h()(), f(45, "div", 37), M(46, "textarea", 38), f(47, "div", 39), g(48, "Markdown supported"), h()()()(), f(49, "div", 40)(50, "div", 9)(51, "div", 41), g(52, "Details"), h(), f(53, "button", 36), g(54, "\u2699\ufe0f"), h()(), f(55, "div", 42)(56, "div", 43), g(57, "Assignee"), h(), I(58, y4, 7, 8, "div", 44), I(59, b4, 6, 6, "ng-template", null, 45, qe), h(), f(61, "div", 46)(62, "div", 43), g(63, "Due date"), h(), M(64, "input", 47), h(), f(65, "div", 48)(66, "span"), g(67, "Created \u2022 Updated"), h(), f(68, "button", 49), g(69, "Configure"), h()()()(), f(70, "div", 50), I(71, D4, 7, 2, "ng-container", 51), I(72, C4, 5, 0, "ng-template", null, 52, qe), f(74, "button", 53), R("click", function () { return V(t), B(E().delete()) }), g(75, " Delete "), h()()()()()() } if (2 & e) { const t = Ve(60), r = Ve(73), i = E(); _(4), b("formGroup", i.form), _(10), U(" ", i.issueKey, " "), _(2), b("title", i.isEditing ? "Cancel editing" : "Edit"), _(9), b("readonly", !i.isEditing), _(3), Un("pointer-events", i.isEditing ? "auto" : "none"), zt("opacity-60", !i.isEditing), b("ngClass", i.statusChipClass(i.form.value.status)), _(18), b("readonly", !i.isEditing), _(12), b("ngIf", i.isAdmin)("ngIfElse", t), _(6), Un("pointer-events", i.isEditing ? "auto" : "none"), zt("opacity-60", !i.isEditing), _(7), b("ngIf", i.isEditing)("ngIfElse", r) } } function E4(e, n) { if (1 & e && (f(0, "option", 55), g(1), h()), 2 & e) { const t = n.$implicit; b("ngValue", t.id), _(1), te(t.name || t.email) } } function I4(e, n) { if (1 & e) { const t = ve(); f(0, "div", 24)(1, "select", 54), R("ngModelChange", function (i) { return V(t), B(E(2).assignTo(i)) }), f(2, "option", 55), g(3, "Unassigned"), h(), I(4, E4, 2, 2, "option", 56), h(), f(5, "button", 57), R("click", function () { return V(t), B(E(2).assignToMe()) }), g(6, " Assign to me "), h()() } if (2 & e) { const t = E(2); _(1), Un("pointer-events", t.isEditing ? "auto" : "none"), zt("opacity-60", !t.isEditing), b("ngModel", t.selectedAssigneeId), _(1), b("ngValue", void 0), _(2), b("ngForOf", t.members), _(1), b("disabled", !t.meUserId || !t.isEditing) } } function S4(e, n) { if (1 & e && (f(0, "div", 58)(1, "span", 59), g(2), qt(3, "slice"), h(), f(4, "span", 60), g(5), h()()), 2 & e) { const t = E(2); _(2), U(" ", zi(3, 2, t.assigneeName || "U", 0, 1), " "), _(3), te(t.assigneeName || "Unassigned") } } function T4(e, n) { if (1 & e) { const t = ve(); ge(0), f(1, "button", 61), R("click", function () { return V(t), B(E(2).save()) }), Ee(), f(2, "svg", 62), M(3, "path", 63), h(), g(4), h(), Le(), f(5, "button", 64), R("click", function () { return V(t), B(E(2).cancelEdit()) }), g(6, " Cancel "), h(), me() } if (2 & e) { const t = E(2); _(1), b("disabled", t.loading), _(3), U(" ", t.loading ? "Saving\u2026" : "Save", " ") } } function x4(e, n) { if (1 & e) { const t = ve(); f(0, "button", 65), R("click", function () { return V(t), B(E(2).toggleEdit()) }), Ee(), f(1, "svg", 16), M(2, "path", 17)(3, "path", 18), h(), g(4, " Edit "), h() } } function M4(e, n) { if (1 & e) { const t = ve(); f(0, "div", 66)(1, "form", 67), M(2, "div", 7), f(3, "div", 68)(4, "div", 69), g(5, "Task"), h(), f(6, "div", 24)(7, "span", 70), g(8), h(), f(9, "button", 71), R("click", function () { return V(t), B(E().toggleEdit()) }), Ee(), f(10, "svg", 16), M(11, "path", 17)(12, "path", 18), h()()()(), Le(), f(13, "div", 72)(14, "div", 73), M(15, "input", 74)(16, "textarea", 38), h(), f(17, "div", 40)(18, "div", 41), g(19, "Details"), h(), f(20, "div", 75)(21, "div", 76), g(22, "Status"), h(), f(23, "select", 77)(24, "option", 27), g(25, "To Do"), h(), f(26, "option", 28), g(27, "In Progress"), h(), f(28, "option", 29), g(29, "Done"), h()()(), f(30, "div", 78)(31, "div", 43), g(32, "Assignee"), h(), I(33, I4, 7, 8, "div", 44), I(34, S4, 6, 6, "ng-template", null, 79, qe), h(), f(36, "div", 80)(37, "div", 43), g(38, "Due date"), h(), M(39, "input", 47), h()()(), f(40, "div", 81), I(41, T4, 7, 2, "ng-container", 51), I(42, x4, 5, 0, "ng-template", null, 82, qe), f(44, "button", 53), R("click", function () { return V(t), B(E().delete()) }), g(45, " Delete "), h()()()() } if (2 & e) { const t = Ve(35), r = Ve(43), i = E(); _(1), b("formGroup", i.form), _(7), te(i.issueKey), _(1), b("title", i.isEditing ? "Cancel editing" : "Edit"), _(6), b("readonly", !i.isEditing), _(1), b("readonly", !i.isEditing), _(7), Un("pointer-events", i.isEditing ? "auto" : "none"), zt("opacity-60", !i.isEditing), b("ngClass", i.statusChipClass(i.form.value.status)), _(10), b("ngIf", i.isAdmin)("ngIfElse", t), _(6), Un("pointer-events", i.isEditing ? "auto" : "none"), zt("opacity-60", !i.isEditing), _(2), b("ngIf", i.isEditing)("ngIfElse", r) } } let Sp = (() => { class e { constructor(t, r, i, o, s) { this.route = t, this.api = r, this.fb = i, this.router = o, this.location = s, this.loading = !1, this.isModal = !1, this.isEditing = !1, this.members = [], this.isAdmin = !1, this.activeActivityTab = "comments", this.form = this.fb.group({ title: ["", [jt.required]], description: [""], status: ["OPEN", [jt.required]], dueDate: [""] }) } ngOnInit() { this.isModal = "modal" === this.route.outlet, this.id = +(this.route.snapshot.paramMap.get("id") || 0), this.id && this.api.getTask(this.id).subscribe(t => { this.task = t, this.form.patchValue({ title: t?.title ?? "", description: t?.description ?? "", status: t?.status ?? "OPEN", dueDate: t?.dueDate ? this.toInputDateTime(t.dueDate) : "" }), this.assigneeName = t?.assigneeName || t?.assignee?.name, this.selectedAssigneeId = t?.assigneeId ?? t?.assignee?.id; const r = t?.projectId || t?.project?.id; r && this.loadMembersAndRole(r) }) } toggleEdit() { this.isEditing ? (this.resetFormFromTask(), this.isEditing = !1) : this.isEditing = !0 } cancelEdit() { this.resetFormFromTask(), this.isEditing = !1 } resetFormFromTask() { const t = this.task || {}; this.form.patchValue({ title: t?.title ?? "", description: t?.description ?? "", status: t?.status ?? "OPEN", dueDate: t?.dueDate ? this.toInputDateTime(t.dueDate) : "" }), this.selectedAssigneeId = t?.assigneeId ?? t?.assignee?.id, this.assigneeName = t?.assigneeName || t?.assignee?.name || "Unassigned" } loadMembersAndRole(t) { this.api.getProjectMembers(t).subscribe(r => { this.members = (r || []).map(i => i.user) }), this.api.getMyMembership(t).subscribe({ next: r => { this.isAdmin = "OWNER" === r?.role || "ADMIN" === r?.role, this.meUserId = r?.user?.id }, error: () => { this.isAdmin = !1, this.meUserId = void 0 } }) } assignTo(t) { if (!t) return this.selectedAssigneeId = void 0, void (this.assigneeName = "Unassigned"); this.selectedAssigneeId = t, this.assigneeName = this.members.find(r => r.id === t)?.name || this.assigneeName || "Assigned" } assignToMe() { !this.isAdmin || !this.meUserId || this.assignTo(this.meUserId) } onEsc() { this.isModal && this.close() } close() { this.isModal ? this.router.navigate([{ outlets: { modal: null } }]) : this.location.back() } save() { if (this.form.invalid) return void this.form.markAllAsTouched(); this.loading = !0; const t = this.form.getRawValue(), r = { title: t.title ?? this.task?.title ?? "", description: t.description ?? this.task?.description ?? "", status: t.status ?? this.task?.status ?? "OPEN", dueDate: t.dueDate ? this.toBackendDateTime(t.dueDate) : null, assigneeId: this.selectedAssigneeId ?? null, reporterId: this.task?.reporterId ?? this.task?.reporter?.id ?? null, projectId: this.task?.projectId ?? this.task?.project?.id ?? null }; this.api.updateTask(this.id, r).subscribe({ next: () => { this.isEditing = !1, this.isModal ? this.close() : this.router.navigate(["/tasks"]) }, error: () => this.loading = !1 }) } delete() { this.api.deleteTask(this.id).subscribe(() => { this.isModal ? this.close() : this.router.navigate(["/tasks"]) }) } statusLabel(t) { switch (t) { case "IN_PROGRESS": return "In Progress"; case "DONE": return "Done"; default: return "To Do" } } statusChipClass(t) { switch (t) { case "IN_PROGRESS": return "bg-sky-100 text-sky-700 border border-sky-200"; case "DONE": return "bg-emerald-100 text-emerald-700 border border-emerald-200"; default: return "bg-slate-100 text-slate-700 border border-slate-200" } } selectTab(t) { this.activeActivityTab = t } get issueKey() { return this.task?.key || `TASK-${this.id}` } toInputDateTime(t) { const r = new Date(t), i = o => String(o).padStart(2, "0"); return `${r.getFullYear()}-${i(r.getMonth() + 1)}-${i(r.getDate())}T${i(r.getHours())}:${i(r.getMinutes())}` } toBackendDateTime(t) { const r = new Date(t), i = o => String(o).padStart(2, "0"); return `${r.getFullYear()}-${i(r.getMonth() + 1)}-${i(r.getDate())}T${i(r.getHours())}:${i(r.getMinutes())}:00` } static { this.\u0275fac = function (r) { return new (r || e)(D(ln), D(gr), D(Vc), D(Re), D(zl)) } } static { this.\u0275cmp = rt({ type: e, selectors: [["app-task-detail"]], hostBindings: function (r, i) { 1 & r && R("keydown.escape", function () { return i.onEsc() }, 0, hl) }, decls: 3, vars: 2, consts: [["class", "fixed inset-0 z-50", 4, "ngIf", "ngIfElse"], ["fullPage", ""], [1, "fixed", "inset-0", "z-50"], [1, "absolute", "inset-0", "bg-black/40", 3, "click"], [1, "relative", "z-10", "h-full", "flex", "items-center", "justify-center", "p-4", "md:p-6"], [1, "w-full", "max-w-5xl", "max-h-[90vh]", "overflow-y-auto"], [1, "bg-white", "border", "border-slate-200", "rounded-2xl", "shadow-2xl", "overflow-hidden", 3, "formGroup"], [1, "h-1", "w-full", "bg-gradient-to-r", "from-sky-400", "via-violet-500", "to-emerald-500"], [1, "px-6", "py-4", "border-b", "border-slate-200", "bg-gradient-to-r", "from-white", "to-slate-50/60"], [1, "flex", "items-center", "justify-between"], [1, "flex", "items-center", "gap-3", "text-slate-600"], ["type", "button", 1, "px-2", "py-1", "text-sm", "rounded", "border", "border-slate-200", "bg-white", "hover:bg-slate-50"], [1, "text-slate-300"], [1, "text-xs", "md:text-sm", "px-2", "py-0.5", "rounded-full", "bg-slate-100", "border", "border-slate-200", "text-slate-700"], [1, "flex", "items-center", "gap-2", "text-slate-500"], ["type", "button", 1, "p-2", "rounded", "hover:bg-slate-100", 3, "title", "click"], ["xmlns", "http://www.w3.org/2000/svg", "fill", "none", "viewBox", "0 0 24 24", "stroke", "currentColor", "stroke-width", "1.5", 1, "h-5", "w-5"], ["stroke-linecap", "round", "stroke-linejoin", "round", "d", "M16.862 3.487a2.25 2.25 0 013.182 3.182l-9.193 9.193-3.49.308.308-3.49 9.193-9.193z"], ["stroke-linecap", "round", "stroke-linejoin", "round", "d", "M19.5 10.5L13.5 4.5"], ["type", "button", "title", "Close", 1, "p-2", "rounded", "hover:bg-slate-100", 3, "click"], [1, "px-6", "py-5", "border-b", "border-slate-100", "bg-white"], [1, "flex", "items-start", "justify-between", "gap-4"], [1, "flex-1"], ["formControlName", "title", "placeholder", "Issue title", 1, "w-full", "text-3xl", "font-semibold", "leading-tight", "bg-slate-50", "rounded-xl", "px-3", "py-2", "border", "border-transparent", "focus:outline-none", "focus:bg-white", "focus:border-slate-300", "placeholder:text-slate-400", 3, "readonly"], [1, "flex", "items-center", "gap-2"], [1, "relative"], ["formControlName", "status", 1, "appearance-none", "pr-8", "pl-3", "py-2", "rounded-lg", "text-sm", "font-medium", "border", "shadow-sm", "bg-white", "focus:outline-none", "focus:ring-2", "focus:ring-sky-300", 3, "ngClass"], ["value", "OPEN"], ["value", "IN_PROGRESS"], ["value", "DONE"], [1, "pointer-events-none", "absolute", "right-2", "top-1/2", "-translate-y-1/2", "text-slate-500"], [1, "grid", "md:grid-cols-3", "gap-6", "px-6", "py-6", "bg-white"], [1, "md:col-span-2", "space-y-6"], [1, "rounded-xl", "border", "border-slate-200", "bg-white"], [1, "flex", "items-center", "justify-between", "px-4", "py-3", "border-b", "border-slate-100"], [1, "text-sm", "font-semibold", "text-slate-700"], ["type", "button", 1, "p-1.5", "rounded", "hover:bg-slate-100", "text-slate-500"], [1, "p-4"], ["formControlName", "description", "rows", "6", "placeholder", "Add a description...", 1, "w-full", "rounded-lg", "border", "border-slate-300", "px-3", "py-2", "focus:outline-none", "focus:ring-2", "focus:ring-brand-500", 3, "readonly"], [1, "mt-2", "text-xs", "text-slate-400"], [1, "space-y-4"], [1, "text-sm", "font-semibold"], [1, "rounded-xl", "border", "border-slate-200", "bg-white", "p-4", "space-y-3"], [1, "text-xs", "font-medium", "text-slate-500"], ["class", "flex items-center gap-2", 4, "ngIf", "ngIfElse"], ["readonlyAssignee", ""], [1, "rounded-xl", "border", "border-slate-200", "bg-white", "p-4", "space-y-2"], ["type", "datetime-local", "formControlName", "dueDate", 1, "w-full", "border", "rounded-lg", "px-2", "py-1.5", "bg-white", "focus:outline-none", "focus:ring-2", "focus:ring-sky-300"], [1, "rounded-xl", "border", "border-slate-200", "bg-white", "px-4", "py-3", "text-xs", "text-slate-500", "flex", "items-center", "justify-between"], ["type", "button", 1, "text-slate-500", "hover:underline"], [1, "sticky", "bottom-0", "bg-white/95", "backdrop-blur", "border-t", "border-slate-200", "px-6", "py-3", "flex", "gap-2"], [4, "ngIf", "ngIfElse"], ["viewFooterModal", ""], [1, "px-4", "py-2", "rounded-lg", "bg-red-600", "text-white", "hover:bg-red-500", "ml-auto", 3, "click"], [1, "border", "rounded-lg", "px-2", "py-1.5", "bg-white", "focus:outline-none", "focus:ring-2", "focus:ring-sky-300", 3, "ngModel", "ngModelChange"], [3, "ngValue"], [3, "ngValue", 4, "ngFor", "ngForOf"], ["type", "button", 1, "text-sky-600", "hover:underline", 3, "disabled", "click"], [1, "inline-flex", "items-center", "gap-2"], [1, "inline-flex", "items-center", "justify-center", "w-7", "h-7", "rounded-full", "border", "border-slate-200", "bg-slate-50", "text-xs", "font-medium"], [1, "text-sm"], [1, "px-4", "py-2", "rounded-lg", "text-white", "bg-gradient-to-r", "from-slate-900", "to-slate-700", "hover:from-slate-800", "hover:to-slate-700", "disabled:opacity-50", "inline-flex", "items-center", "gap-2", 3, "disabled", "click"], ["xmlns", "http://www.w3.org/2000/svg", "viewBox", "0 0 20 20", "fill", "currentColor", 1, "h-5", "w-5"], ["fill-rule", "evenodd", "d", "M16.707 5.293a1 1 0 010 1.414l-7.364 7.364a1 1 0 01-1.414 0L3.293 9.435a1 1 0 011.414-1.414l3.222 3.222 6.657-6.657a1 1 0 011.414 0z", "clip-rule", "evenodd"], ["type", "button", 1, "px-4", "py-2", "rounded-lg", "border", "border-slate-300", "text-slate-700", "hover:bg-slate-50", 3, "click"], ["type", "button", "title", "Edit", 1, "px-4", "py-2", "rounded-lg", "border", "border-slate-300", "text-slate-700", "hover:bg-slate-50", "inline-flex", "items-center", "gap-2", 3, "click"], [1, "max-w-5xl", "mx-auto", "p-6"], [1, "bg-white", "border", "border-slate-200", "rounded-2xl", "shadow-sm", "overflow-hidden", 3, "formGroup"], [1, "px-6", "py-4", "border-b", "border-slate-200", "flex", "items-center", "justify-between"], [1, "text-lg", "font-semibold"], [1, "text-xs", "px-2", "py-0.5", "rounded-full", "bg-slate-100", "border", "border-slate-200"], ["type", "button", 1, "p-2", "rounded", "hover:bg-slate-100", "text-slate-600", 3, "title", "click"], [1, "grid", "md:grid-cols-3", "gap-6", "p-6"], [1, "md:col-span-2", "space-y-4"], ["formControlName", "title", "placeholder", "Issue title", 1, "w-full", "text-2xl", "font-semibold", "bg-slate-50", "rounded-lg", "px-3", "py-2", "border", "border-transparent", "focus:outline-none", "focus:bg-white", "focus:border-slate-300", 3, "readonly"], [1, "rounded-xl", "border", "border-slate-200", "p-4", "space-y-3"], [1, "text-xs", "text-slate-500"], ["formControlName", "status", 1, "w-full", "border", "rounded-lg", "px-2", "py-1.5", "bg-white", "focus:outline-none", "focus:ring-2", "focus:ring-sky-300", 3, "ngClass"], [1, "rounded-xl", "border", "border-slate-200", "p-4", "space-y-3", "bg-white"], ["readonlyAssigneeFull", ""], [1, "rounded-xl", "border", "border-slate-200", "p-4", "space-y-2", "bg-white"], [1, "px-6", "py-3", "border-t", "flex", "gap-2"], ["viewFooterFull", ""]], template: function (r, i) { if (1 & r && (I(0, w4, 76, 18, "div", 0), I(1, M4, 46, 18, "ng-template", null, 1, qe)), 2 & r) { const o = Ve(2); b("ngIf", i.isModal)("ngIfElse", o) } }, dependencies: [Xi, Fr, Dn, Gr, wp, Ip, Kn, ea, Hr, $r, qr, ho, Js, tc], encapsulation: 2 }) } } return e })(); function A4(e, n) { if (1 & e && (f(0, "div", 18), g(1), h()), 2 & e) { const t = E(); _(1), U(" ", t.error, " ") } } function k4(e, n) { 1 & e && (f(0, "div", 20)(1, "div", 21), M(2, "div", 22), f(3, "div", 23), M(4, "div", 24)(5, "div", 25), h()()()) } const R4 = function () { return [1, 2, 3, 4] }; function P4(e, n) { 1 & e && (ge(0), I(1, k4, 6, 0, "div", 19), me()), 2 & e && (_(1), b("ngForOf", Gt(1, R4))) } function N4(e, n) { if (1 & e && (ge(0), f(1, "div", 20)(2, "div", 26)(3, "span", 27), Ee(), f(4, "svg", 28), M(5, "path", 29), h()(), Le(), f(6, "div")(7, "div", 30), g(8, "completed"), h(), f(9, "div", 2), g(10), h(), f(11, "div", 31), g(12, "overall"), h()()()(), f(13, "div", 20)(14, "div", 26)(15, "span", 32), Ee(), f(16, "svg", 28), M(17, "path", 33), h()(), Le(), f(18, "div")(19, "div", 30), g(20, "updated"), h(), f(21, "div", 2), g(22), h(), f(23, "div", 31), g(24, "in the last 7 days"), h()()()(), f(25, "div", 20)(26, "div", 26)(27, "span", 34), Ee(), f(28, "svg", 28), M(29, "path", 35), h()(), Le(), f(30, "div")(31, "div", 30), g(32, "created"), h(), f(33, "div", 2), g(34), h(), f(35, "div", 31), g(36, "in the last 7 days"), h()()()(), f(37, "div", 20)(38, "div", 26)(39, "span", 36), Ee(), f(40, "svg", 28), M(41, "path", 37), h()(), Le(), f(42, "div")(43, "div", 30), g(44, "due soon"), h(), f(45, "div", 2), g(46), h(), f(47, "div", 31), g(48, "in the next 7 days"), h()()()(), me()), 2 & e) { const t = E(); _(10), te(t.summary.completedTasks), _(12), te(t.summary.updatedLast7Days), _(12), te(t.summary.createdLast7Days), _(12), te(t.summary.dueSoonCount) } } function O4(e, n) { 1 & e && (f(0, "div", 38)(1, "div", 39), M(2, "div", 40), f(3, "div", 41), M(4, "div", 42)(5, "div", 43)(6, "div", 44), h()()()) } function F4(e, n) { if (1 & e && (Ee(), ge(0), M(1, "circle", 60), me()), 2 & e) { const t = n.$implicit, r = E(2); _(1), nt("r", r.R)("stroke", t.color)("stroke-width", r.W)("stroke-dasharray", t.dash + " " + r.C)("stroke-dashoffset", t.offset) } } function L4(e, n) { if (1 & e && (f(0, "div", 38)(1, "div", 39)(2, "div", 45), Ee(), f(3, "svg", 46), M(4, "circle", 47), I(5, F4, 2, 5, "ng-container", 48), h(), Le(), f(6, "div", 49)(7, "div", 50)(8, "div", 51), g(9), h(), f(10, "div", 52), g(11, "Total work items"), h()()()(), f(12, "div", 53)(13, "div", 54), M(14, "span", 55), f(15, "span", 56), g(16, "In Progress"), h(), f(17, "span", 57), g(18), h()(), f(19, "div", 54), M(20, "span", 58), f(21, "span", 56), g(22, "To Do"), h(), f(23, "span", 57), g(24), h()(), f(25, "div", 54), M(26, "span", 59), f(27, "span", 56), g(28, "Done"), h(), f(29, "span", 57), g(30), h()()()()()), 2 & e) { const t = E(); _(3), nt("width", 160)("height", 160), _(1), nt("r", t.R)("stroke-width", t.W), _(1), b("ngForOf", t.segments), _(4), te(t.summary.totalTasks), _(9), te(t.countOf("IN_PROGRESS")), _(6), te(t.countOf("OPEN")), _(6), te(t.countOf("DONE")) } } function j4(e, n) { 1 & e && (f(0, "div", 63), M(1, "div", 64), f(2, "div", 23), M(3, "div", 65)(4, "div", 66), h()()) } const V4 = function () { return [1, 2, 3] }; function B4(e, n) { 1 & e && (f(0, "div", 61), I(1, j4, 5, 0, "div", 62), h()), 2 & e && (_(1), b("ngForOf", Gt(1, V4))) } function U4(e, n) { 1 & e && (f(0, "div", 70), g(1, " No recent activity. "), h()) } function H4(e, n) { if (1 & e && (f(0, "span", 79), g(1), h()), 2 & e) { const t = E().$implicit; _(1), U(" ", null == t ? null : t.status, " ") } } function $4(e, n) { if (1 & e && (f(0, "div", 71)(1, "div", 72), g(2), h(), f(3, "div", 73)(4, "div", 74)(5, "span", 75), g(6), h(), f(7, "span", 76), g(8), h(), f(9, "span", 56), g(10), h(), I(11, H4, 2, 1, "span", 77), h(), f(12, "div", 78), g(13), h()()()), 2 & e) { const t = n.$implicit, r = E(2); _(2), U(" ", r.initials(null == t ? null : t.actorName), " "), _(4), te((null == t ? null : t.actorName) || "Someone"), _(2), U(" ", (null == t ? null : t.action) || "updated", " "), _(2), te((null == t ? null : t.taskTitle) || "Task"), _(1), b("ngIf", null == t ? null : t.status), _(2), U(" ", r.timeAgo(null == t ? null : t.timestamp), " ") } } function z4(e, n) { if (1 & e && (f(0, "div", 67), I(1, U4, 2, 0, "div", 68), I(2, $4, 14, 6, "div", 69), h()), 2 & e) { const t = E(); _(1), b("ngIf", !(null != t.summary.recentActivity && t.summary.recentActivity.length)), _(1), b("ngForOf", t.summary.recentActivity) } } let Bc = (() => { class e { constructor(t, r) { this.api = t, this.router = r, this.loading = !1, this.error = "", this.R = 48, this.W = 12, this.C = 2 * Math.PI * this.R, this.segments = [] } ngOnInit() { this.loadSummary() } loadSummary() { this.loading = !0, this.error = "", this.api.getProjectSummary().pipe(re(t => this.adaptSummary(t)), Yt(() => this.loading = !1)).subscribe({ next: t => { this.summary = t, this.buildSegments() }, error: t => { this.error = t?.error?.message || t?.message || "Failed to load project summary" } }) } adaptSummary(t) { return { totalTasks: t.totalTasks ?? 0, completedTasks: t.completedTasks ?? 0, createdLast7Days: t.createdLast7 ?? 0, updatedLast7Days: t.updatedLast7 ?? 0, dueSoonCount: t.dueSoon ?? 0, statusCount: t.statusCount ?? {}, recentActivity: (t.recent ?? []).map(r => ({ actorName: r.userName, action: r.action, taskTitle: r.taskTitle, status: r.taskStatus, timestamp: r.timestamp })) } } buildSegments() { if (!this.summary) return void (this.segments = []); const t = this.summary.statusCount?.OPEN ?? 0, r = this.summary.statusCount?.IN_PROGRESS ?? 0, i = this.summary.statusCount?.DONE ?? 0, o = Math.max(0, t + r + i); if (!o) return void (this.segments = []); let a = 0; this.segments = [{ label: "In Progress", key: "IN_PROGRESS", value: r, color: "#0ea5e9" }, { label: "To Do", key: "OPEN", value: t, color: "#10b981" }, { label: "Done", key: "DONE", value: i, color: "#22c55e" }].filter(l => l.value > 0).map(l => { const c = l.value / o * this.C, u = { ...l, dash: c, offset: a }; return a += c, u }) } countOf(t) { return this.summary?.statusCount?.[t] ?? 0 } initials(t) { const r = (t || "").trim(); if (!r) return "U"; const o = (r.includes("@") ? r.split("@")[0] : r).split(/[.\s_-]+/).filter(Boolean); return ((o[0]?.[0] || r[0] || "U") + (o[1]?.[0] || "")).toUpperCase() } timeAgo(t) { if (!t) return ""; let r = new Date(t); isNaN(r.getTime()) && (r = new Date(t.replace(/(\.\d{3})\d+/, "$1"))); const i = Date.now() - r.getTime(); if (isNaN(i)) return ""; const o = Math.floor(i / 1e3), s = Math.floor(o / 60), a = Math.floor(s / 60), l = Math.floor(a / 24); return l > 0 ? `${l} day${l > 1 ? "s" : ""} ago` : a > 0 ? `${a} hour${a > 1 ? "s" : ""} ago` : s > 0 ? `${s} min ago` : "just now" } openBoard() { this.router.navigate(["/board"]) } static { this.\u0275fac = function (r) { return new (r || e)(D(gr), D(Re)) } } static { this.\u0275cmp = rt({ type: e, selectors: [["app-tasks"]], decls: 31, vars: 7, consts: [[1, "space-y-6"], [1, "flex", "items-center", "justify-between"], [1, "text-xl", "font-semibold"], [1, "flex", "items-center", "gap-2"], [1, "px-3", "py-1.5", "rounded-lg", "border", "border-slate-300", "bg-white", "hover:bg-slate-50", 3, "click"], ["class", "p-4 rounded-xl border border-rose-200 bg-rose-50 text-rose-700 text-sm", 4, "ngIf"], [1, "grid", "sm:grid-cols-2", "lg:grid-cols-4", "gap-4"], [4, "ngIf"], [1, "grid", "lg:grid-cols-3", "gap-6"], [1, "lg:col-span-2", "relative", "overflow-hidden", "rounded-2xl", "border", "border-slate-200", "bg-white"], [1, "px-5", "py-4", "border-b", "border-slate-100"], [1, "font-semibold"], [1, "text-sm", "text-sky-600", "hover:underline", 3, "click"], [1, "text-xs", "text-slate-500", "mt-0.5"], ["class", "p-6", 4, "ngIf"], [1, "relative", "overflow-hidden", "rounded-2xl", "border", "border-slate-200", "bg-white"], ["class", "p-5 space-y-4", 4, "ngIf"], ["class", "p-5", 4, "ngIf"], [1, "p-4", "rounded-xl", "border", "border-rose-200", "bg-rose-50", "text-rose-700", "text-sm"], ["class", "rounded-xl border border-slate-200 bg-white p-4", 4, "ngFor", "ngForOf"], [1, "rounded-xl", "border", "border-slate-200", "bg-white", "p-4"], [1, "flex", "items-center", "gap-3", "animate-pulse"], [1, "w-9", "h-9", "rounded-lg", "bg-slate-200"], [1, "flex-1"], [1, "h-4", "w-1/3", "bg-slate-200", "rounded", "mb-1"], [1, "h-6", "w-1/4", "bg-slate-100", "rounded"], [1, "flex", "items-center", "gap-3"], [1, "inline-flex", "items-center", "justify-center", "w-9", "h-9", "rounded-lg", "bg-emerald-50", "text-emerald-600", "border", "border-emerald-100"], ["xmlns", "http://www.w3.org/2000/svg", "fill", "none", "viewBox", "0 0 24 24", "stroke", "currentColor", "stroke-width", "1.5", 1, "h-5", "w-5"], ["stroke-linecap", "round", "stroke-linejoin", "round", "d", "M9 12l2 2 4-4m5 2a9 9 0 11-18 0 9 9 0 0118 0z"], [1, "text-slate-500", "text-sm"], [1, "text-[11px]", "text-slate-400", "-mt-0.5"], [1, "inline-flex", "items-center", "justify-center", "w-9", "h-9", "rounded-lg", "bg-sky-50", "text-sky-600", "border", "border-sky-100"], ["stroke-linecap", "round", "stroke-linejoin", "round", "d", "M16.862 3.487a2.25 2.25 0 013.182 3.182L7.5 19.313 3 20.25l.937-4.5L16.862 3.487z"], [1, "inline-flex", "items-center", "justify-center", "w-9", "h-9", "rounded-lg", "bg-indigo-50", "text-indigo-600", "border", "border-indigo-100"], ["stroke-linecap", "round", "stroke-linejoin", "round", "d", "M12 6v12m6-6H6"], [1, "inline-flex", "items-center", "justify-center", "w-9", "h-9", "rounded-lg", "bg-amber-50", "text-amber-600", "border", "border-amber-100"], ["stroke-linecap", "round", "stroke-linejoin", "round", "d", "M12 6v6l4 2m6-2a10 10 0 11-20 0 10 10 0 0120 0z"], [1, "p-6"], [1, "flex", "items-center", "gap-8"], [1, "h-40", "w-40", "rounded-full", "bg-slate-100", "animate-pulse"], [1, "flex-1", "space-y-3"], [1, "h-4", "w-40", "bg-slate-200", "rounded"], [1, "h-4", "w-32", "bg-slate-100", "rounded"], [1, "h-4", "w-28", "bg-slate-100", "rounded"], [1, "relative"], ["viewBox", "0 0 120 120"], ["cx", "60", "cy", "60", "stroke", "#e5e7eb", "fill", "none"], [4, "ngFor", "ngForOf"], [1, "absolute", "inset-0", "grid", "place-items-center"], [1, "text-center"], [1, "text-2xl", "font-semibold"], [1, "text-[11px]", "text-slate-500"], [1, "flex-1", "space-y-2"], [1, "flex", "items-center", "gap-2", "text-sm"], [1, "inline-block", "w-3", "h-3", "rounded-sm", 2, "background", "#0ea5e9"], [1, "text-slate-700"], [1, "ml-auto", "text-slate-500"], [1, "inline-block", "w-3", "h-3", "rounded-sm", 2, "background", "#10b981"], [1, "inline-block", "w-3", "h-3", "rounded-sm", 2, "background", "#22c55e"], ["cx", "60", "cy", "60", "fill", "none", "transform", "rotate(-90 60 60)", "stroke-linecap", "round"], [1, "p-5", "space-y-4"], ["class", "flex items-start gap-3 animate-pulse", 4, "ngFor", "ngForOf"], [1, "flex", "items-start", "gap-3", "animate-pulse"], [1, "w-8", "h-8", "rounded-full", "bg-slate-200"], [1, "h-4", "w-2/3", "bg-slate-200", "rounded", "mb-2"], [1, "h-3", "w-24", "bg-slate-100", "rounded"], [1, "p-5"], ["class", "text-sm text-slate-500", 4, "ngIf"], ["class", "flex items-start gap-3 py-3 border-b last:border-b-0 border-slate-100", 4, "ngFor", "ngForOf"], [1, "text-sm", "text-slate-500"], [1, "flex", "items-start", "gap-3", "py-3", "border-b", "last:border-b-0", "border-slate-100"], [1, "w-8", "h-8", "rounded-full", "border", "border-slate-200", "bg-slate-50", "grid", "place-items-center", "text-[11px]", "font-semibold", "text-slate-700"], [1, "min-w-0", "flex-1"], [1, "text-sm", "text-slate-700"], [1, "font-medium"], [1, "text-slate-500"], ["class", "ml-2 px-1.5 py-0.5 text-[10px] rounded border bg-slate-50 text-slate-700", 4, "ngIf"], [1, "text-[11px]", "text-slate-500", "mt-0.5"], [1, "ml-2", "px-1.5", "py-0.5", "text-[10px]", "rounded", "border", "bg-slate-50", "text-slate-700"]], template: function (r, i) { 1 & r && (f(0, "div", 0)(1, "div", 1)(2, "div", 2), g(3, "Summary"), h(), f(4, "div", 3)(5, "button", 4), R("click", function () { return i.openBoard() }), g(6, " View all work items "), h()()(), I(7, A4, 2, 1, "div", 5), f(8, "div", 6), I(9, P4, 2, 2, "ng-container", 7), I(10, N4, 49, 4, "ng-container", 7), h(), f(11, "div", 8)(12, "div", 9)(13, "div", 10)(14, "div", 1)(15, "div", 11), g(16, "Status overview"), h(), f(17, "button", 12), R("click", function () { return i.openBoard() }), g(18, "View all work items"), h()(), f(19, "div", 13), g(20, "Get a snapshot of the status of your work items."), h()(), I(21, O4, 7, 0, "div", 14), I(22, L4, 31, 9, "div", 14), h(), f(23, "div", 15)(24, "div", 10)(25, "div", 11), g(26, "Recent activity"), h(), f(27, "div", 13), g(28, "Stay up to date with what's happening across the space."), h()(), I(29, B4, 2, 2, "div", 16), I(30, z4, 3, 2, "div", 17), h()()()), 2 & r && (_(7), b("ngIf", i.error), _(2), b("ngIf", i.loading), _(1), b("ngIf", !i.loading && i.summary), _(11), b("ngIf", i.loading), _(1), b("ngIf", !i.loading && i.summary), _(7), b("ngIf", i.loading), _(1), b("ngIf", !i.loading && i.summary)) }, dependencies: [Fr, Dn], encapsulation: 2 }) } } return e })(), G4 = (() => { class e { constructor(t, r) { this.auth = t, this.router = r } canActivate() { return !this.auth.isLoggedIn() || (this.router.navigate(["/"]), !1) } static { this.\u0275fac = function (r) { return new (r || e)(k(Tn), k(Re)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(), Tp = (() => { class e { constructor(t, r, i, o) { this.route = t, this.api = r, this.router = i, this.auth = o } ngOnInit() { const t = this.route.snapshot.queryParamMap.get("token") || ""; this.api.verifyInvite(t).subscribe({ next: r => { const i = r.email; this.api.checkUserExists(i).subscribe({ next: o => { if (this.auth.isLoggedIn()) { const s = this.getCurrentUserEmail(); s && s.toLowerCase() === i.toLowerCase() ? this.api.acceptInvite(t).subscribe({ next: a => this.goToProjectOrLogin(a), error: () => this.router.navigate(["/login"], { queryParams: { inviteError: "true" } }) }) : (this.auth.logout(), o ? this.router.navigate(["/login"], { queryParams: { token: t, switchAccount: "true" } }) : this.router.navigate(["/register"], { queryParams: { token: t } })) } else this.router.navigate(o ? ["/login"] : ["/register"], { queryParams: { token: t } }) }, error: () => this.router.navigate(["/login"], { queryParams: { inviteError: "true" } }) }) }, error: () => this.router.navigate(["/login"], { queryParams: { inviteError: "true" } }) }) } getCurrentUserEmail() { try { const t = localStorage.getItem("user"); return t ? JSON.parse(t).email : null } catch { return null } } goToProjectOrLogin(t) { const r = t?.project?.id; r ? this.router.navigate([`/projects/${r}`]) : this.router.navigate(["/login"], { queryParams: { inviteAccepted: "true" } }) } static { this.\u0275fac = function (r) { return new (r || e)(D(ln), D(gr), D(Re), D(Tn)) } } static { this.\u0275cmp = rt({ type: e, selectors: [["ng-component"]], decls: 2, vars: 0, consts: [[1, "p-8", "text-center"]], template: function (r, i) { 1 & r && (f(0, "div", 0), g(1, "Joining project\u2026"), h()) }, encapsulation: 2 }) } } return e })(); function yr(e) { return null != e && "false" != `${e}` } function R1(e, n = 0) { return function q4(e) { return !isNaN(parseFloat(e)) && !isNaN(Number(e)) }(e) ? Number(e) : n } function Tt(e) { return e instanceof tt ? e.nativeElement : e } const Z4 = ["addListener", "removeListener"], K4 = ["addEventListener", "removeEventListener"], Y4 = ["on", "off"]; function xp(e, n, t, r) { if (ne(t) && (r = t, t = void 0), r) return xp(e, n, t).pipe(Rh(r)); const [i, o] = function J4(e) { return ne(e.addEventListener) && ne(e.removeEventListener) }(e) ? K4.map(s => a => e[s](n, a, t)) : function Q4(e) { return ne(e.addListener) && ne(e.removeListener) }(e) ? Z4.map(P1(e, n)) : function X4(e) { return ne(e.on) && ne(e.off) }(e) ? Y4.map(P1(e, n)) : []; if (!i && uu(e)) return Ze(s => xp(s, n, t))(lt(e)); if (!i) throw new TypeError("Invalid event target"); return new be(s => { const a = (...l) => s.next(1 < l.length ? l : l[0]); return i(a), () => o(a) }) } function P1(e, n) { return t => r => e[t](n, r) } class eB extends Pe { constructor(n, t) { super() } schedule(n, t = 0) { return this } } const Uc = { setInterval(e, n, ...t) { const { delegate: r } = Uc; return r?.setInterval ? r.setInterval(e, n, ...t) : setInterval(e, n, ...t) }, clearInterval(e) { const { delegate: n } = Uc; return (n?.clearInterval || clearInterval)(e) }, delegate: void 0 }; class Mp extends eB { constructor(n, t) { super(n, t), this.scheduler = n, this.work = t, this.pending = !1 } schedule(n, t = 0) { var r; if (this.closed) return this; this.state = n; const i = this.id, o = this.scheduler; return null != i && (this.id = this.recycleAsyncId(o, i, t)), this.pending = !0, this.delay = t, this.id = null !== (r = this.id) && void 0 !== r ? r : this.requestAsyncId(o, this.id, t), this } requestAsyncId(n, t, r = 0) { return Uc.setInterval(n.flush.bind(n, this), r) } recycleAsyncId(n, t, r = 0) { if (null != r && this.delay === r && !1 === this.pending) return t; null != t && Uc.clearInterval(t) } execute(n, t) { if (this.closed) return new Error("executing a cancelled action"); this.pending = !1; const r = this._execute(n, t); if (r) return r; !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) } _execute(n, t) { let i, r = !1; try { this.work(n) } catch (o) { r = !0, i = o || new Error("Scheduled action threw falsy error") } if (r) return this.unsubscribe(), i } unsubscribe() { if (!this.closed) { const { id: n, scheduler: t } = this, { actions: r } = t; this.work = this.state = this.scheduler = null, this.pending = !1, Yr(r, this), null != n && (this.id = this.recycleAsyncId(t, n, null)), this.delay = null, super.unsubscribe() } } } const ta = { schedule(e) { let n = requestAnimationFrame, t = cancelAnimationFrame; const { delegate: r } = ta; r && (n = r.requestAnimationFrame, t = r.cancelAnimationFrame); const i = n(o => { t = void 0, e(o) }); return new Pe(() => t?.(i)) }, requestAnimationFrame(...e) { const { delegate: n } = ta; return (n?.requestAnimationFrame || requestAnimationFrame)(...e) }, cancelAnimationFrame(...e) { const { delegate: n } = ta; return (n?.cancelAnimationFrame || cancelAnimationFrame)(...e) }, delegate: void 0 }, N1 = { now: () => (N1.delegate || Date).now(), delegate: void 0 }; class na { constructor(n, t = na.now) { this.schedulerActionCtor = n, this.now = t } schedule(n, t = 0, r) { return new this.schedulerActionCtor(this, n).schedule(r, t) } } na.now = N1.now; class Ap extends na { constructor(n, t = na.now) { super(n, t), this.actions = [], this._active = !1 } flush(n) { const { actions: t } = this; if (this._active) return void t.push(n); let r; this._active = !0; do { if (r = n.execute(n.state, n.delay)) break } while (n = t.shift()); if (this._active = !1, r) { for (; n = t.shift();)n.unsubscribe(); throw r } } } const O1 = new class nB extends Ap { flush(n) { let t; this._active = !0, n ? t = n.id : (t = this._scheduled, this._scheduled = void 0); const { actions: r } = this; let i; n = n || r.shift(); do { if (i = n.execute(n.state, n.delay)) break } while ((n = r[0]) && n.id === t && r.shift()); if (this._active = !1, i) { for (; (n = r[0]) && n.id === t && r.shift();)n.unsubscribe(); throw i } } }(class tB extends Mp { constructor(n, t) { super(n, t), this.scheduler = n, this.work = t } requestAsyncId(n, t, r = 0) { return null !== r && r > 0 ? super.requestAsyncId(n, t, r) : (n.actions.push(this), n._scheduled || (n._scheduled = ta.requestAnimationFrame(() => n.flush(void 0)))) } recycleAsyncId(n, t, r = 0) { var i; if (null != r ? r > 0 : this.delay > 0) return super.recycleAsyncId(n, t, r); const { actions: o } = n; null != t && t === n._scheduled && (null === (i = o[o.length - 1]) || void 0 === i ? void 0 : i.id) !== t && (ta.cancelAnimationFrame(t), n._scheduled = void 0) } }); let kp, rB = 1; const Hc = {}; function F1(e) { return e in Hc && (delete Hc[e], !0) } const iB = { setImmediate(e) { const n = rB++; return Hc[n] = !0, kp || (kp = Promise.resolve()), kp.then(() => F1(n) && e()), n }, clearImmediate(e) { F1(e) } }, { setImmediate: oB, clearImmediate: sB } = iB, $c = { setImmediate(...e) { const { delegate: n } = $c; return (n?.setImmediate || oB)(...e) }, clearImmediate(e) { const { delegate: n } = $c; return (n?.clearImmediate || sB)(e) }, delegate: void 0 }, zc = (new class lB extends Ap { flush(n) { this._active = !0; const t = this._scheduled; this._scheduled = void 0; const { actions: r } = this; let i; n = n || r.shift(); do { if (i = n.execute(n.state, n.delay)) break } while ((n = r[0]) && n.id === t && r.shift()); if (this._active = !1, i) { for (; (n = r[0]) && n.id === t && r.shift();)n.unsubscribe(); throw i } } }(class aB extends Mp { constructor(n, t) { super(n, t), this.scheduler = n, this.work = t } requestAsyncId(n, t, r = 0) { return null !== r && r > 0 ? super.requestAsyncId(n, t, r) : (n.actions.push(this), n._scheduled || (n._scheduled = $c.setImmediate(n.flush.bind(n, void 0)))) } recycleAsyncId(n, t, r = 0) { var i; if (null != r ? r > 0 : this.delay > 0) return super.recycleAsyncId(n, t, r); const { actions: o } = n; null != t && (null === (i = o[o.length - 1]) || void 0 === i ? void 0 : i.id) !== t && ($c.clearImmediate(t), n._scheduled === t && (n._scheduled = void 0)) } }), new Ap(Mp)), uB = zc; function L1(e = 0, n, t = uB) { let r = -1; return null != n && (hg(n) ? t = n : r = n), new be(i => { let o = function fB(e) { return e instanceof Date && !isNaN(e) }(e) ? +e - t.now() : e; o < 0 && (o = 0); let s = 0; return t.schedule(function () { i.closed || (i.next(s++), 0 <= r ? this.schedule(void 0, r) : i.complete()) }, o) }) } function j1(e, n = zc) { return function dB(e) { return Ne((n, t) => { let r = !1, i = null, o = null, s = !1; const a = () => { if (o?.unsubscribe(), o = null, r) { r = !1; const c = i; i = null, t.next(c) } s && t.complete() }, l = () => { o = null, s && t.complete() }; n.subscribe(xe(t, c => { r = !0, i = c, o || lt(e(c)).subscribe(o = xe(t, a, l)) }, () => { s = !0, (!r || !o || o.closed) && t.complete() })) }) }(() => L1(e, n)) } let Rp; try { Rp = typeof Intl < "u" && Intl.v8BreakIterator } catch { Rp = !1 } let ra, Pp, V1 = (() => { class e { constructor(t) { this._platformId = t, this.isBrowser = this._platformId ? function R2(e) { return e === xD }(this._platformId) : "object" == typeof document && !!document, this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), this.BLINK = this.isBrowser && !(!window.chrome && !Rp) && typeof CSS < "u" && !this.EDGE && !this.TRIDENT, this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT } static { this.\u0275fac = function (r) { return new (r || e)(k(sr)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); function ia(e) { return function hB() { if (null == ra && typeof window < "u") try { window.addEventListener("test", null, Object.defineProperty({}, "passive", { get: () => ra = !0 })) } finally { ra = ra || !1 } return ra }() ? e : !!e.capture } function U1(e) { if (function pB() { if (null == Pp) { const e = typeof document < "u" ? document.head : null; Pp = !(!e || !e.createShadowRoot && !e.attachShadow) } return Pp }()) { const n = e.getRootNode ? e.getRootNode() : null; if (typeof ShadowRoot < "u" && ShadowRoot && n instanceof ShadowRoot) return n } return null } function qc(e) { return e.composedPath ? e.composedPath()[0] : e.target } let mB = (() => { class e { constructor(t, r, i) { this._ngZone = t, this._platform = r, this._scrolled = new X, this._globalSubscription = null, this._scrolledCount = 0, this.scrollContainers = new Map, this._document = i } register(t) { this.scrollContainers.has(t) || this.scrollContainers.set(t, t.elementScrolled().subscribe(() => this._scrolled.next(t))) } deregister(t) { const r = this.scrollContainers.get(t); r && (r.unsubscribe(), this.scrollContainers.delete(t)) } scrolled(t = 20) { return this._platform.isBrowser ? new be(r => { this._globalSubscription || this._addGlobalListener(); const i = t > 0 ? this._scrolled.pipe(j1(t)).subscribe(r) : this._scrolled.subscribe(r); return this._scrolledCount++, () => { i.unsubscribe(), this._scrolledCount--, this._scrolledCount || this._removeGlobalListener() } }) : H() } ngOnDestroy() { this._removeGlobalListener(), this.scrollContainers.forEach((t, r) => this.deregister(r)), this._scrolled.complete() } ancestorScrolled(t, r) { const i = this.getAncestorScrollContainers(t); return this.scrolled(r).pipe(an(o => !o || i.indexOf(o) > -1)) } getAncestorScrollContainers(t) { const r = []; return this.scrollContainers.forEach((i, o) => { this._scrollableContainsElement(o, t) && r.push(o) }), r } _getWindow() { return this._document.defaultView || window } _scrollableContainsElement(t, r) { let i = Tt(r), o = t.getElementRef().nativeElement; do { if (i == o) return !0 } while (i = i.parentElement); return !1 } _addGlobalListener() { this._globalSubscription = this._ngZone.runOutsideAngular(() => xp(this._getWindow().document, "scroll").subscribe(() => this._scrolled.next())) } _removeGlobalListener() { this._globalSubscription && (this._globalSubscription.unsubscribe(), this._globalSubscription = null) } static { this.\u0275fac = function (r) { return new (r || e)(k(le), k(V1), k(We, 8)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(), vB = (() => { class e { constructor(t, r, i) { this._platform = t, this._change = new X, this._changeListener = o => { this._change.next(o) }, this._document = i, r.runOutsideAngular(() => { if (t.isBrowser) { const o = this._getWindow(); o.addEventListener("resize", this._changeListener), o.addEventListener("orientationchange", this._changeListener) } this.change().subscribe(() => this._viewportSize = null) }) } ngOnDestroy() { if (this._platform.isBrowser) { const t = this._getWindow(); t.removeEventListener("resize", this._changeListener), t.removeEventListener("orientationchange", this._changeListener) } this._change.complete() } getViewportSize() { this._viewportSize || this._updateViewportSize(); const t = { width: this._viewportSize.width, height: this._viewportSize.height }; return this._platform.isBrowser || (this._viewportSize = null), t } getViewportRect() { const t = this.getViewportScrollPosition(), { width: r, height: i } = this.getViewportSize(); return { top: t.top, left: t.left, bottom: t.top + i, right: t.left + r, height: i, width: r } } getViewportScrollPosition() { if (!this._platform.isBrowser) return { top: 0, left: 0 }; const t = this._document, r = this._getWindow(), i = t.documentElement, o = i.getBoundingClientRect(); return { top: -o.top || t.body.scrollTop || r.scrollY || i.scrollTop || 0, left: -o.left || t.body.scrollLeft || r.scrollX || i.scrollLeft || 0 } } change(t = 20) { return t > 0 ? this._change.pipe(j1(t)) : this._change } _getWindow() { return this._document.defaultView || window } _updateViewportSize() { const t = this._getWindow(); this._viewportSize = this._platform.isBrowser ? { width: t.innerWidth, height: t.innerHeight } : { width: 0, height: 0 } } static { this.\u0275fac = function (r) { return new (r || e)(k(V1), k(le), k(We, 8)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(), yB = (() => { class e { static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275mod = bt({ type: e }) } static { this.\u0275inj = ct({}) } } return e })(); const JB = new A("cdk-dir-doc", { providedIn: "root", factory: function e5() { return O(We) } }), t5 = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i; let G1 = (() => { class e { constructor(t) { this.value = "ltr", this.change = new se, t && (this.value = function n5(e) { const n = e?.toLowerCase() || ""; return "auto" === n && typeof navigator < "u" && navigator?.language ? t5.test(navigator.language) ? "rtl" : "ltr" : "rtl" === n ? "rtl" : "ltr" }((t.body ? t.body.dir : null) || (t.documentElement ? t.documentElement.dir : null) || "ltr")) } ngOnDestroy() { this.change.complete() } static { this.\u0275fac = function (r) { return new (r || e)(k(JB, 8)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); function Np(e, n, t) { for (let r in n) if (n.hasOwnProperty(r)) { const i = n[r]; i ? e.setProperty(r, i, t?.has(r) ? "important" : "") : e.removeProperty(r) } return e } function go(e, n) { const t = n ? "" : "none"; Np(e.style, { "touch-action": n ? "" : "none", "-webkit-user-drag": n ? "" : "none", "-webkit-tap-highlight-color": n ? "" : "transparent", "user-select": t, "-ms-user-select": t, "-webkit-user-select": t, "-moz-user-select": t }) } function q1(e, n, t) { Np(e.style, { position: n ? "" : "fixed", top: n ? "" : "0", opacity: n ? "" : "0", left: n ? "" : "-999em" }, t) } function Wc(e, n) { return n && "none" != n ? e + " " + n : e } function W1(e) { const n = e.toLowerCase().indexOf("ms") > -1 ? 1 : 1e3; return parseFloat(e) * n } function Op(e, n) { return e.getPropertyValue(n).split(",").map(r => r.trim()) } function Fp(e) { const n = e.getBoundingClientRect(); return { top: n.top, right: n.right, bottom: n.bottom, left: n.left, width: n.width, height: n.height, x: n.x, y: n.y } } function Lp(e, n, t) { const { top: r, bottom: i, left: o, right: s } = e; return t >= r && t <= i && n >= o && n <= s } function oa(e, n, t) { e.top += n, e.bottom = e.top + e.height, e.left += t, e.right = e.left + e.width } function Z1(e, n, t, r) { const { top: i, right: o, bottom: s, left: a, width: l, height: c } = e, u = l * n, d = c * n; return r > i - d && r < s + d && t > a - u && t < o + u } class K1 { constructor(n) { this._document = n, this.positions = new Map } clear() { this.positions.clear() } cache(n) { this.clear(), this.positions.set(this._document, { scrollPosition: this.getViewportScrollPosition() }), n.forEach(t => { this.positions.set(t, { scrollPosition: { top: t.scrollTop, left: t.scrollLeft }, clientRect: Fp(t) }) }) } handleScroll(n) { const t = qc(n), r = this.positions.get(t); if (!r) return null; const i = r.scrollPosition; let o, s; if (t === this._document) { const c = this.getViewportScrollPosition(); o = c.top, s = c.left } else o = t.scrollTop, s = t.scrollLeft; const a = i.top - o, l = i.left - s; return this.positions.forEach((c, u) => { c.clientRect && t !== u && t.contains(u) && oa(c.clientRect, a, l) }), i.top = o, i.left = s, { top: a, left: l } } getViewportScrollPosition() { return { top: window.scrollY, left: window.scrollX } } } function Y1(e) { const n = e.cloneNode(!0), t = n.querySelectorAll("[id]"), r = e.nodeName.toLowerCase(); n.removeAttribute("id"); for (let i = 0; i < t.length; i++)t[i].removeAttribute("id"); return "canvas" === r ? J1(e, n) : ("input" === r || "select" === r || "textarea" === r) && X1(e, n), Q1("canvas", e, n, J1), Q1("input, textarea, select", e, n, X1), n } function Q1(e, n, t, r) { const i = n.querySelectorAll(e); if (i.length) { const o = t.querySelectorAll(e); for (let s = 0; s < i.length; s++)r(i[s], o[s]) } } let i5 = 0; function X1(e, n) { "file" !== n.type && (n.value = e.value), "radio" === n.type && n.name && (n.name = `mat-clone-${n.name}-${i5++}`) } function J1(e, n) { const t = n.getContext("2d"); if (t) try { t.drawImage(e, 0, 0) } catch { } } const eE = ia({ passive: !0 }), Zc = ia({ passive: !1 }), jp = new Set(["position"]); class s5 { get disabled() { return this._disabled || !(!this._dropContainer || !this._dropContainer.disabled) } set disabled(n) { const t = yr(n); t !== this._disabled && (this._disabled = t, this._toggleNativeDragInteractions(), this._handles.forEach(r => go(r, t))) } constructor(n, t, r, i, o, s) { this._config = t, this._document = r, this._ngZone = i, this._viewportRuler = o, this._dragDropRegistry = s, this._passiveTransform = { x: 0, y: 0 }, this._activeTransform = { x: 0, y: 0 }, this._hasStartedDragging = !1, this._moveEvents = new X, this._pointerMoveSubscription = Pe.EMPTY, this._pointerUpSubscription = Pe.EMPTY, this._scrollSubscription = Pe.EMPTY, this._resizeSubscription = Pe.EMPTY, this._boundaryElement = null, this._nativeInteractionsEnabled = !0, this._handles = [], this._disabledHandles = new Set, this._direction = "ltr", this.dragStartDelay = 0, this._disabled = !1, this.beforeStarted = new X, this.started = new X, this.released = new X, this.ended = new X, this.entered = new X, this.exited = new X, this.dropped = new X, this.moved = this._moveEvents, this._pointerDown = a => { if (this.beforeStarted.next(), this._handles.length) { const l = this._getTargetHandle(a); l && !this._disabledHandles.has(l) && !this.disabled && this._initializeDragSequence(l, a) } else this.disabled || this._initializeDragSequence(this._rootElement, a) }, this._pointerMove = a => { const l = this._getPointerPositionOnPage(a); if (!this._hasStartedDragging) { if (Math.abs(l.x - this._pickupPositionOnPage.x) + Math.abs(l.y - this._pickupPositionOnPage.y) >= this._config.dragStartThreshold) { const m = Date.now() >= this._dragStartTime + this._getDragStartDelay(a), v = this._dropContainer; if (!m) return void this._endDragSequence(a); (!v || !v.isDragging() && !v.isReceiving()) && (a.preventDefault(), this._hasStartedDragging = !0, this._ngZone.run(() => this._startDragSequence(a))) } return } a.preventDefault(); const c = this._getConstrainedPointerPosition(l); if (this._hasMoved = !0, this._lastKnownPointerPosition = l, this._updatePointerDirectionDelta(c), this._dropContainer) this._updateActiveDropContainer(c, l); else { const u = this.constrainPosition ? this._initialClientRect : this._pickupPositionOnPage, d = this._activeTransform; d.x = c.x - u.x + this._passiveTransform.x, d.y = c.y - u.y + this._passiveTransform.y, this._applyRootElementTransform(d.x, d.y) } this._moveEvents.observers.length && this._ngZone.run(() => { this._moveEvents.next({ source: this, pointerPosition: c, event: a, distance: this._getDragDistance(c), delta: this._pointerDirectionDelta }) }) }, this._pointerUp = a => { this._endDragSequence(a) }, this._nativeDragStart = a => { if (this._handles.length) { const l = this._getTargetHandle(a); l && !this._disabledHandles.has(l) && !this.disabled && a.preventDefault() } else this.disabled || a.preventDefault() }, this.withRootElement(n).withParent(t.parentDragRef || null), this._parentPositions = new K1(r), s.registerDragItem(this) } getPlaceholderElement() { return this._placeholder } getRootElement() { return this._rootElement } getVisibleElement() { return this.isDragging() ? this.getPlaceholderElement() : this.getRootElement() } withHandles(n) { this._handles = n.map(r => Tt(r)), this._handles.forEach(r => go(r, this.disabled)), this._toggleNativeDragInteractions(); const t = new Set; return this._disabledHandles.forEach(r => { this._handles.indexOf(r) > -1 && t.add(r) }), this._disabledHandles = t, this } withPreviewTemplate(n) { return this._previewTemplate = n, this } withPlaceholderTemplate(n) { return this._placeholderTemplate = n, this } withRootElement(n) { const t = Tt(n); return t !== this._rootElement && (this._rootElement && this._removeRootElementListeners(this._rootElement), this._ngZone.runOutsideAngular(() => { t.addEventListener("mousedown", this._pointerDown, Zc), t.addEventListener("touchstart", this._pointerDown, eE), t.addEventListener("dragstart", this._nativeDragStart, Zc) }), this._initialTransform = void 0, this._rootElement = t), typeof SVGElement < "u" && this._rootElement instanceof SVGElement && (this._ownerSVGElement = this._rootElement.ownerSVGElement), this } withBoundaryElement(n) { return this._boundaryElement = n ? Tt(n) : null, this._resizeSubscription.unsubscribe(), n && (this._resizeSubscription = this._viewportRuler.change(10).subscribe(() => this._containInsideBoundaryOnResize())), this } withParent(n) { return this._parentDragRef = n, this } dispose() { this._removeRootElementListeners(this._rootElement), this.isDragging() && this._rootElement?.remove(), this._anchor?.remove(), this._destroyPreview(), this._destroyPlaceholder(), this._dragDropRegistry.removeDragItem(this), this._removeSubscriptions(), this.beforeStarted.complete(), this.started.complete(), this.released.complete(), this.ended.complete(), this.entered.complete(), this.exited.complete(), this.dropped.complete(), this._moveEvents.complete(), this._handles = [], this._disabledHandles.clear(), this._dropContainer = void 0, this._resizeSubscription.unsubscribe(), this._parentPositions.clear(), this._boundaryElement = this._rootElement = this._ownerSVGElement = this._placeholderTemplate = this._previewTemplate = this._anchor = this._parentDragRef = null } isDragging() { return this._hasStartedDragging && this._dragDropRegistry.isDragging(this) } reset() { this._rootElement.style.transform = this._initialTransform || "", this._activeTransform = { x: 0, y: 0 }, this._passiveTransform = { x: 0, y: 0 } } disableHandle(n) { !this._disabledHandles.has(n) && this._handles.indexOf(n) > -1 && (this._disabledHandles.add(n), go(n, !0)) } enableHandle(n) { this._disabledHandles.has(n) && (this._disabledHandles.delete(n), go(n, this.disabled)) } withDirection(n) { return this._direction = n, this } _withDropContainer(n) { this._dropContainer = n } getFreeDragPosition() { const n = this.isDragging() ? this._activeTransform : this._passiveTransform; return { x: n.x, y: n.y } } setFreeDragPosition(n) { return this._activeTransform = { x: 0, y: 0 }, this._passiveTransform.x = n.x, this._passiveTransform.y = n.y, this._dropContainer || this._applyRootElementTransform(n.x, n.y), this } withPreviewContainer(n) { return this._previewContainer = n, this } _sortFromLastPointerPosition() { const n = this._lastKnownPointerPosition; n && this._dropContainer && this._updateActiveDropContainer(this._getConstrainedPointerPosition(n), n) } _removeSubscriptions() { this._pointerMoveSubscription.unsubscribe(), this._pointerUpSubscription.unsubscribe(), this._scrollSubscription.unsubscribe() } _destroyPreview() { this._preview?.remove(), this._previewRef?.destroy(), this._preview = this._previewRef = null } _destroyPlaceholder() { this._placeholder?.remove(), this._placeholderRef?.destroy(), this._placeholder = this._placeholderRef = null } _endDragSequence(n) { if (this._dragDropRegistry.isDragging(this) && (this._removeSubscriptions(), this._dragDropRegistry.stopDragging(this), this._toggleNativeDragInteractions(), this._handles && (this._rootElement.style.webkitTapHighlightColor = this._rootElementTapHighlight), this._hasStartedDragging)) if (this.released.next({ source: this, event: n }), this._dropContainer) this._dropContainer._stopScrolling(), this._animatePreviewToPlaceholder().then(() => { this._cleanupDragArtifacts(n), this._cleanupCachedDimensions(), this._dragDropRegistry.stopDragging(this) }); else { this._passiveTransform.x = this._activeTransform.x; const t = this._getPointerPositionOnPage(n); this._passiveTransform.y = this._activeTransform.y, this._ngZone.run(() => { this.ended.next({ source: this, distance: this._getDragDistance(t), dropPoint: t, event: n }) }), this._cleanupCachedDimensions(), this._dragDropRegistry.stopDragging(this) } } _startDragSequence(n) { sa(n) && (this._lastTouchEventTime = Date.now()), this._toggleNativeDragInteractions(); const t = this._dropContainer; if (t) { const r = this._rootElement, i = r.parentNode, o = this._placeholder = this._createPlaceholderElement(), s = this._anchor = this._anchor || this._document.createComment(""), a = this._getShadowRoot(); i.insertBefore(s, r), this._initialTransform = r.style.transform || "", this._preview = this._createPreviewElement(), q1(r, !1, jp), this._document.body.appendChild(i.replaceChild(o, r)), this._getPreviewInsertionPoint(i, a).appendChild(this._preview), this.started.next({ source: this, event: n }), t.start(), this._initialContainer = t, this._initialIndex = t.getItemIndex(this) } else this.started.next({ source: this, event: n }), this._initialContainer = this._initialIndex = void 0; this._parentPositions.cache(t ? t.getScrollableParents() : []) } _initializeDragSequence(n, t) { this._parentDragRef && t.stopPropagation(); const r = this.isDragging(), i = sa(t), o = !i && 0 !== t.button, s = this._rootElement, a = qc(t), l = !i && this._lastTouchEventTime && this._lastTouchEventTime + 800 > Date.now(), c = i ? function YB(e) { const n = e.touches && e.touches[0] || e.changedTouches && e.changedTouches[0]; return !(!n || -1 !== n.identifier || null != n.radiusX && 1 !== n.radiusX || null != n.radiusY && 1 !== n.radiusY) }(t) : function KB(e) { return 0 === e.buttons || 0 === e.detail }(t); if (a && a.draggable && "mousedown" === t.type && t.preventDefault(), r || o || l || c) return; if (this._handles.length) { const p = s.style; this._rootElementTapHighlight = p.webkitTapHighlightColor || "", p.webkitTapHighlightColor = "transparent" } this._hasStartedDragging = this._hasMoved = !1, this._removeSubscriptions(), this._initialClientRect = this._rootElement.getBoundingClientRect(), this._pointerMoveSubscription = this._dragDropRegistry.pointerMove.subscribe(this._pointerMove), this._pointerUpSubscription = this._dragDropRegistry.pointerUp.subscribe(this._pointerUp), this._scrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe(p => this._updateOnScroll(p)), this._boundaryElement && (this._boundaryRect = Fp(this._boundaryElement)); const u = this._previewTemplate; this._pickupPositionInElement = u && u.template && !u.matchSize ? { x: 0, y: 0 } : this._getPointerPositionInElement(this._initialClientRect, n, t); const d = this._pickupPositionOnPage = this._lastKnownPointerPosition = this._getPointerPositionOnPage(t); this._pointerDirectionDelta = { x: 0, y: 0 }, this._pointerPositionAtLastDirectionChange = { x: d.x, y: d.y }, this._dragStartTime = Date.now(), this._dragDropRegistry.startDragging(this, t) } _cleanupDragArtifacts(n) { q1(this._rootElement, !0, jp), this._anchor.parentNode.replaceChild(this._rootElement, this._anchor), this._destroyPreview(), this._destroyPlaceholder(), this._initialClientRect = this._boundaryRect = this._previewRect = this._initialTransform = void 0, this._ngZone.run(() => { const t = this._dropContainer, r = t.getItemIndex(this), i = this._getPointerPositionOnPage(n), o = this._getDragDistance(i), s = t._isOverContainer(i.x, i.y); this.ended.next({ source: this, distance: o, dropPoint: i, event: n }), this.dropped.next({ item: this, currentIndex: r, previousIndex: this._initialIndex, container: t, previousContainer: this._initialContainer, isPointerOverContainer: s, distance: o, dropPoint: i, event: n }), t.drop(this, r, this._initialIndex, this._initialContainer, s, o, i, n), this._dropContainer = this._initialContainer }) } _updateActiveDropContainer({ x: n, y: t }, { x: r, y: i }) { let o = this._initialContainer._getSiblingContainerFromPosition(this, n, t); !o && this._dropContainer !== this._initialContainer && this._initialContainer._isOverContainer(n, t) && (o = this._initialContainer), o && o !== this._dropContainer && this._ngZone.run(() => { this.exited.next({ item: this, container: this._dropContainer }), this._dropContainer.exit(this), this._dropContainer = o, this._dropContainer.enter(this, n, t, o === this._initialContainer && o.sortingDisabled ? this._initialIndex : void 0), this.entered.next({ item: this, container: o, currentIndex: o.getItemIndex(this) }) }), this.isDragging() && (this._dropContainer._startScrollingIfNecessary(r, i), this._dropContainer._sortItem(this, n, t, this._pointerDirectionDelta), this.constrainPosition ? this._applyPreviewTransform(n, t) : this._applyPreviewTransform(n - this._pickupPositionInElement.x, t - this._pickupPositionInElement.y)) } _createPreviewElement() { const n = this._previewTemplate, t = this.previewClass, r = n ? n.template : null; let i; if (r && n) { const o = n.matchSize ? this._initialClientRect : null, s = n.viewContainer.createEmbeddedView(r, n.context); s.detectChanges(), i = nE(s, this._document), this._previewRef = s, n.matchSize ? rE(i, o) : i.style.transform = Kc(this._pickupPositionOnPage.x, this._pickupPositionOnPage.y) } else i = Y1(this._rootElement), rE(i, this._initialClientRect), this._initialTransform && (i.style.transform = this._initialTransform); return Np(i.style, { "pointer-events": "none", margin: "0", position: "fixed", top: "0", left: "0", "z-index": `${this._config.zIndex || 1e3}` }, jp), go(i, !1), i.classList.add("cdk-drag-preview"), i.setAttribute("dir", this._direction), t && (Array.isArray(t) ? t.forEach(o => i.classList.add(o)) : i.classList.add(t)), i } _animatePreviewToPlaceholder() { if (!this._hasMoved) return Promise.resolve(); const n = this._placeholder.getBoundingClientRect(); this._preview.classList.add("cdk-drag-animating"), this._applyPreviewTransform(n.left, n.top); const t = function r5(e) { const n = getComputedStyle(e), t = Op(n, "transition-property"), r = t.find(a => "transform" === a || "all" === a); if (!r) return 0; const i = t.indexOf(r), o = Op(n, "transition-duration"), s = Op(n, "transition-delay"); return W1(o[i]) + W1(s[i]) }(this._preview); return 0 === t ? Promise.resolve() : this._ngZone.runOutsideAngular(() => new Promise(r => { const i = s => { (!s || qc(s) === this._preview && "transform" === s.propertyName) && (this._preview?.removeEventListener("transitionend", i), r(), clearTimeout(o)) }, o = setTimeout(i, 1.5 * t); this._preview.addEventListener("transitionend", i) })) } _createPlaceholderElement() { const n = this._placeholderTemplate, t = n ? n.template : null; let r; return t ? (this._placeholderRef = n.viewContainer.createEmbeddedView(t, n.context), this._placeholderRef.detectChanges(), r = nE(this._placeholderRef, this._document)) : r = Y1(this._rootElement), r.style.pointerEvents = "none", r.classList.add("cdk-drag-placeholder"), r } _getPointerPositionInElement(n, t, r) { const i = t === this._rootElement ? null : t, o = i ? i.getBoundingClientRect() : n, s = sa(r) ? r.targetTouches[0] : r, a = this._getViewportScrollPosition(); return { x: o.left - n.left + (s.pageX - o.left - a.left), y: o.top - n.top + (s.pageY - o.top - a.top) } } _getPointerPositionOnPage(n) { const t = this._getViewportScrollPosition(), r = sa(n) ? n.touches[0] || n.changedTouches[0] || { pageX: 0, pageY: 0 } : n, i = r.pageX - t.left, o = r.pageY - t.top; if (this._ownerSVGElement) { const s = this._ownerSVGElement.getScreenCTM(); if (s) { const a = this._ownerSVGElement.createSVGPoint(); return a.x = i, a.y = o, a.matrixTransform(s.inverse()) } } return { x: i, y: o } } _getConstrainedPointerPosition(n) { const t = this._dropContainer ? this._dropContainer.lockAxis : null; let { x: r, y: i } = this.constrainPosition ? this.constrainPosition(n, this, this._initialClientRect, this._pickupPositionInElement) : n; if ("x" === this.lockAxis || "x" === t ? i = this._pickupPositionOnPage.y - (this.constrainPosition ? this._pickupPositionInElement.y : 0) : ("y" === this.lockAxis || "y" === t) && (r = this._pickupPositionOnPage.x - (this.constrainPosition ? this._pickupPositionInElement.x : 0)), this._boundaryRect) { const { x: o, y: s } = this.constrainPosition ? { x: 0, y: 0 } : this._pickupPositionInElement, a = this._boundaryRect, { width: l, height: c } = this._getPreviewRect(), u = a.top + s, d = a.bottom - (c - s); r = tE(r, a.left + o, a.right - (l - o)), i = tE(i, u, d) } return { x: r, y: i } } _updatePointerDirectionDelta(n) { const { x: t, y: r } = n, i = this._pointerDirectionDelta, o = this._pointerPositionAtLastDirectionChange, s = Math.abs(t - o.x), a = Math.abs(r - o.y); return s > this._config.pointerDirectionChangeThreshold && (i.x = t > o.x ? 1 : -1, o.x = t), a > this._config.pointerDirectionChangeThreshold && (i.y = r > o.y ? 1 : -1, o.y = r), i } _toggleNativeDragInteractions() { if (!this._rootElement || !this._handles) return; const n = this._handles.length > 0 || !this.isDragging(); n !== this._nativeInteractionsEnabled && (this._nativeInteractionsEnabled = n, go(this._rootElement, n)) } _removeRootElementListeners(n) { n.removeEventListener("mousedown", this._pointerDown, Zc), n.removeEventListener("touchstart", this._pointerDown, eE), n.removeEventListener("dragstart", this._nativeDragStart, Zc) } _applyRootElementTransform(n, t) { const r = Kc(n, t), i = this._rootElement.style; null == this._initialTransform && (this._initialTransform = i.transform && "none" != i.transform ? i.transform : ""), i.transform = Wc(r, this._initialTransform) } _applyPreviewTransform(n, t) { const r = this._previewTemplate?.template ? void 0 : this._initialTransform, i = Kc(n, t); this._preview.style.transform = Wc(i, r) } _getDragDistance(n) { const t = this._pickupPositionOnPage; return t ? { x: n.x - t.x, y: n.y - t.y } : { x: 0, y: 0 } } _cleanupCachedDimensions() { this._boundaryRect = this._previewRect = void 0, this._parentPositions.clear() } _containInsideBoundaryOnResize() { let { x: n, y: t } = this._passiveTransform; if (0 === n && 0 === t || this.isDragging() || !this._boundaryElement) return; const r = this._rootElement.getBoundingClientRect(), i = this._boundaryElement.getBoundingClientRect(); if (0 === i.width && 0 === i.height || 0 === r.width && 0 === r.height) return; const o = i.left - r.left, s = r.right - i.right, a = i.top - r.top, l = r.bottom - i.bottom; i.width > r.width ? (o > 0 && (n += o), s > 0 && (n -= s)) : n = 0, i.height > r.height ? (a > 0 && (t += a), l > 0 && (t -= l)) : t = 0, (n !== this._passiveTransform.x || t !== this._passiveTransform.y) && this.setFreeDragPosition({ y: t, x: n }) } _getDragStartDelay(n) { const t = this.dragStartDelay; return "number" == typeof t ? t : sa(n) ? t.touch : t ? t.mouse : 0 } _updateOnScroll(n) { const t = this._parentPositions.handleScroll(n); if (t) { const r = qc(n); this._boundaryRect && r !== this._boundaryElement && r.contains(this._boundaryElement) && oa(this._boundaryRect, t.top, t.left), this._pickupPositionOnPage.x += t.left, this._pickupPositionOnPage.y += t.top, this._dropContainer || (this._activeTransform.x -= t.left, this._activeTransform.y -= t.top, this._applyRootElementTransform(this._activeTransform.x, this._activeTransform.y)) } } _getViewportScrollPosition() { return this._parentPositions.positions.get(this._document)?.scrollPosition || this._parentPositions.getViewportScrollPosition() } _getShadowRoot() { return void 0 === this._cachedShadowRoot && (this._cachedShadowRoot = U1(this._rootElement)), this._cachedShadowRoot } _getPreviewInsertionPoint(n, t) { const r = this._previewContainer || "global"; if ("parent" === r) return n; if ("global" === r) { const i = this._document; return t || i.fullscreenElement || i.webkitFullscreenElement || i.mozFullScreenElement || i.msFullscreenElement || i.body } return Tt(r) } _getPreviewRect() { return (!this._previewRect || !this._previewRect.width && !this._previewRect.height) && (this._previewRect = this._preview ? this._preview.getBoundingClientRect() : this._initialClientRect), this._previewRect } _getTargetHandle(n) { return this._handles.find(t => n.target && (n.target === t || t.contains(n.target))) } } function Kc(e, n) { return `translate3d(${Math.round(e)}px, ${Math.round(n)}px, 0)` } function tE(e, n, t) { return Math.max(n, Math.min(t, e)) } function sa(e) { return "t" === e.type[0] } function nE(e, n) { const t = e.rootNodes; if (1 === t.length && t[0].nodeType === n.ELEMENT_NODE) return t[0]; const r = n.createElement("div"); return t.forEach(i => r.appendChild(i)), r } function rE(e, n) { e.style.width = `${n.width}px`, e.style.height = `${n.height}px`, e.style.transform = Kc(n.left, n.top) } function Vp(e, n, t) { const r = aa(n, e.length - 1), i = aa(t, e.length - 1); if (r === i) return; const o = e[r], s = i < r ? -1 : 1; for (let a = r; a !== i; a += s)e[a] = e[a + s]; e[i] = o } function aa(e, n) { return Math.max(0, Math.min(n, e)) } class l5 { constructor(n, t) { this._element = n, this._dragDropRegistry = t, this._itemPositions = [], this.orientation = "vertical", this._previousSwap = { drag: null, delta: 0, overlaps: !1 } } start(n) { this.withItems(n) } sort(n, t, r, i) { const o = this._itemPositions, s = this._getItemIndexFromPointerPosition(n, t, r, i); if (-1 === s && o.length > 0) return null; const a = "horizontal" === this.orientation, l = o.findIndex(C => C.drag === n), c = o[s], d = c.clientRect, p = l > s ? 1 : -1, m = this._getItemOffsetPx(o[l].clientRect, d, p), v = this._getSiblingOffsetPx(l, o, p), y = o.slice(); return Vp(o, l, s), o.forEach((C, T) => { if (y[T] === C) return; const w = C.drag === n, P = w ? m : v, L = w ? n.getPlaceholderElement() : C.drag.getRootElement(); C.offset += P, a ? (L.style.transform = Wc(`translate3d(${Math.round(C.offset)}px, 0, 0)`, C.initialTransform), oa(C.clientRect, 0, P)) : (L.style.transform = Wc(`translate3d(0, ${Math.round(C.offset)}px, 0)`, C.initialTransform), oa(C.clientRect, P, 0)) }), this._previousSwap.overlaps = Lp(d, t, r), this._previousSwap.drag = c.drag, this._previousSwap.delta = a ? i.x : i.y, { previousIndex: l, currentIndex: s } } enter(n, t, r, i) { const o = null == i || i < 0 ? this._getItemIndexFromPointerPosition(n, t, r) : i, s = this._activeDraggables, a = s.indexOf(n), l = n.getPlaceholderElement(); let c = s[o]; if (c === n && (c = s[o + 1]), !c && (null == o || -1 === o || o < s.length - 1) && this._shouldEnterAsFirstChild(t, r) && (c = s[0]), a > -1 && s.splice(a, 1), c && !this._dragDropRegistry.isDragging(c)) { const u = c.getRootElement(); u.parentElement.insertBefore(l, u), s.splice(o, 0, n) } else Tt(this._element).appendChild(l), s.push(n); l.style.transform = "", this._cacheItemPositions() } withItems(n) { this._activeDraggables = n.slice(), this._cacheItemPositions() } withSortPredicate(n) { this._sortPredicate = n } reset() { this._activeDraggables.forEach(n => { const t = n.getRootElement(); if (t) { const r = this._itemPositions.find(i => i.drag === n)?.initialTransform; t.style.transform = r || "" } }), this._itemPositions = [], this._activeDraggables = [], this._previousSwap.drag = null, this._previousSwap.delta = 0, this._previousSwap.overlaps = !1 } getActiveItemsSnapshot() { return this._activeDraggables } getItemIndex(n) { return ("horizontal" === this.orientation && "rtl" === this.direction ? this._itemPositions.slice().reverse() : this._itemPositions).findIndex(r => r.drag === n) } updateOnScroll(n, t) { this._itemPositions.forEach(({ clientRect: r }) => { oa(r, n, t) }), this._itemPositions.forEach(({ drag: r }) => { this._dragDropRegistry.isDragging(r) && r._sortFromLastPointerPosition() }) } _cacheItemPositions() { const n = "horizontal" === this.orientation; this._itemPositions = this._activeDraggables.map(t => { const r = t.getVisibleElement(); return { drag: t, offset: 0, initialTransform: r.style.transform || "", clientRect: Fp(r) } }).sort((t, r) => n ? t.clientRect.left - r.clientRect.left : t.clientRect.top - r.clientRect.top) } _getItemOffsetPx(n, t, r) { const i = "horizontal" === this.orientation; let o = i ? t.left - n.left : t.top - n.top; return -1 === r && (o += i ? t.width - n.width : t.height - n.height), o } _getSiblingOffsetPx(n, t, r) { const i = "horizontal" === this.orientation, o = t[n].clientRect, s = t[n + -1 * r]; let a = o[i ? "width" : "height"] * r; if (s) { const l = i ? "left" : "top", c = i ? "right" : "bottom"; -1 === r ? a -= s.clientRect[l] - o[c] : a += o[l] - s.clientRect[c] } return a } _shouldEnterAsFirstChild(n, t) { if (!this._activeDraggables.length) return !1; const r = this._itemPositions, i = "horizontal" === this.orientation; if (r[0].drag !== this._activeDraggables[0]) { const s = r[r.length - 1].clientRect; return i ? n >= s.right : t >= s.bottom } { const s = r[0].clientRect; return i ? n <= s.left : t <= s.top } } _getItemIndexFromPointerPosition(n, t, r, i) { const o = "horizontal" === this.orientation, s = this._itemPositions.findIndex(({ drag: a, clientRect: l }) => a !== n && ((!i || a !== this._previousSwap.drag || !this._previousSwap.overlaps || (o ? i.x : i.y) !== this._previousSwap.delta) && (o ? t >= Math.floor(l.left) && t < Math.floor(l.right) : r >= Math.floor(l.top) && r < Math.floor(l.bottom)))); return -1 !== s && this._sortPredicate(s, n) ? s : -1 } } class c5 { constructor(n, t, r, i, o) { this._dragDropRegistry = t, this._ngZone = i, this._viewportRuler = o, this.disabled = !1, this.sortingDisabled = !1, this.autoScrollDisabled = !1, this.autoScrollStep = 2, this.enterPredicate = () => !0, this.sortPredicate = () => !0, this.beforeStarted = new X, this.entered = new X, this.exited = new X, this.dropped = new X, this.sorted = new X, this.receivingStarted = new X, this.receivingStopped = new X, this._isDragging = !1, this._draggables = [], this._siblings = [], this._activeSiblings = new Set, this._viewportScrollSubscription = Pe.EMPTY, this._verticalScrollDirection = 0, this._horizontalScrollDirection = 0, this._stopScrollTimers = new X, this._cachedShadowRoot = null, this._startScrollInterval = () => { this._stopScrolling(), function XB(e = 0, n = zc) { return e < 0 && (e = 0), L1(e, e, n) }(0, O1).pipe(Ss(this._stopScrollTimers)).subscribe(() => { const s = this._scrollNode, a = this.autoScrollStep; 1 === this._verticalScrollDirection ? s.scrollBy(0, -a) : 2 === this._verticalScrollDirection && s.scrollBy(0, a), 1 === this._horizontalScrollDirection ? s.scrollBy(-a, 0) : 2 === this._horizontalScrollDirection && s.scrollBy(a, 0) }) }, this.element = Tt(n), this._document = r, this.withScrollableParents([this.element]), t.registerDropContainer(this), this._parentPositions = new K1(r), this._sortStrategy = new l5(this.element, t), this._sortStrategy.withSortPredicate((s, a) => this.sortPredicate(s, a, this)) } dispose() { this._stopScrolling(), this._stopScrollTimers.complete(), this._viewportScrollSubscription.unsubscribe(), this.beforeStarted.complete(), this.entered.complete(), this.exited.complete(), this.dropped.complete(), this.sorted.complete(), this.receivingStarted.complete(), this.receivingStopped.complete(), this._activeSiblings.clear(), this._scrollNode = null, this._parentPositions.clear(), this._dragDropRegistry.removeDropContainer(this) } isDragging() { return this._isDragging } start() { this._draggingStarted(), this._notifyReceivingSiblings() } enter(n, t, r, i) { this._draggingStarted(), null == i && this.sortingDisabled && (i = this._draggables.indexOf(n)), this._sortStrategy.enter(n, t, r, i), this._cacheParentPositions(), this._notifyReceivingSiblings(), this.entered.next({ item: n, container: this, currentIndex: this.getItemIndex(n) }) } exit(n) { this._reset(), this.exited.next({ item: n, container: this }) } drop(n, t, r, i, o, s, a, l = {}) { this._reset(), this.dropped.next({ item: n, currentIndex: t, previousIndex: r, container: this, previousContainer: i, isPointerOverContainer: o, distance: s, dropPoint: a, event: l }) } withItems(n) { const t = this._draggables; return this._draggables = n, n.forEach(r => r._withDropContainer(this)), this.isDragging() && (t.filter(i => i.isDragging()).every(i => -1 === n.indexOf(i)) ? this._reset() : this._sortStrategy.withItems(this._draggables)), this } withDirection(n) { return this._sortStrategy.direction = n, this } connectedTo(n) { return this._siblings = n.slice(), this } withOrientation(n) { return this._sortStrategy.orientation = n, this } withScrollableParents(n) { const t = Tt(this.element); return this._scrollableElements = -1 === n.indexOf(t) ? [t, ...n] : n.slice(), this } getScrollableParents() { return this._scrollableElements } getItemIndex(n) { return this._isDragging ? this._sortStrategy.getItemIndex(n) : this._draggables.indexOf(n) } isReceiving() { return this._activeSiblings.size > 0 } _sortItem(n, t, r, i) { if (this.sortingDisabled || !this._clientRect || !Z1(this._clientRect, .05, t, r)) return; const o = this._sortStrategy.sort(n, t, r, i); o && this.sorted.next({ previousIndex: o.previousIndex, currentIndex: o.currentIndex, container: this, item: n }) } _startScrollingIfNecessary(n, t) { if (this.autoScrollDisabled) return; let r, i = 0, o = 0; if (this._parentPositions.positions.forEach((s, a) => { a === this._document || !s.clientRect || r || Z1(s.clientRect, .05, n, t) && ([i, o] = function u5(e, n, t, r) { const i = sE(n, r), o = aE(n, t); let s = 0, a = 0; if (i) { const l = e.scrollTop; 1 === i ? l > 0 && (s = 1) : e.scrollHeight - l > e.clientHeight && (s = 2) } if (o) { const l = e.scrollLeft; 1 === o ? l > 0 && (a = 1) : e.scrollWidth - l > e.clientWidth && (a = 2) } return [s, a] }(a, s.clientRect, n, t), (i || o) && (r = a)) }), !i && !o) { const { width: s, height: a } = this._viewportRuler.getViewportSize(), l = { width: s, height: a, top: 0, right: s, bottom: a, left: 0 }; i = sE(l, t), o = aE(l, n), r = window } r && (i !== this._verticalScrollDirection || o !== this._horizontalScrollDirection || r !== this._scrollNode) && (this._verticalScrollDirection = i, this._horizontalScrollDirection = o, this._scrollNode = r, (i || o) && r ? this._ngZone.runOutsideAngular(this._startScrollInterval) : this._stopScrolling()) } _stopScrolling() { this._stopScrollTimers.next() } _draggingStarted() { const n = Tt(this.element).style; this.beforeStarted.next(), this._isDragging = !0, this._initialScrollSnap = n.msScrollSnapType || n.scrollSnapType || "", n.scrollSnapType = n.msScrollSnapType = "none", this._sortStrategy.start(this._draggables), this._cacheParentPositions(), this._viewportScrollSubscription.unsubscribe(), this._listenToScrollEvents() } _cacheParentPositions() { const n = Tt(this.element); this._parentPositions.cache(this._scrollableElements), this._clientRect = this._parentPositions.positions.get(n).clientRect } _reset() { this._isDragging = !1; const n = Tt(this.element).style; n.scrollSnapType = n.msScrollSnapType = this._initialScrollSnap, this._siblings.forEach(t => t._stopReceiving(this)), this._sortStrategy.reset(), this._stopScrolling(), this._viewportScrollSubscription.unsubscribe(), this._parentPositions.clear() } _isOverContainer(n, t) { return null != this._clientRect && Lp(this._clientRect, n, t) } _getSiblingContainerFromPosition(n, t, r) { return this._siblings.find(i => i._canReceive(n, t, r)) } _canReceive(n, t, r) { if (!this._clientRect || !Lp(this._clientRect, t, r) || !this.enterPredicate(n, this)) return !1; const i = this._getShadowRoot().elementFromPoint(t, r); if (!i) return !1; const o = Tt(this.element); return i === o || o.contains(i) } _startReceiving(n, t) { const r = this._activeSiblings; !r.has(n) && t.every(i => this.enterPredicate(i, this) || this._draggables.indexOf(i) > -1) && (r.add(n), this._cacheParentPositions(), this._listenToScrollEvents(), this.receivingStarted.next({ initiator: n, receiver: this, items: t })) } _stopReceiving(n) { this._activeSiblings.delete(n), this._viewportScrollSubscription.unsubscribe(), this.receivingStopped.next({ initiator: n, receiver: this }) } _listenToScrollEvents() { this._viewportScrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe(n => { if (this.isDragging()) { const t = this._parentPositions.handleScroll(n); t && this._sortStrategy.updateOnScroll(t.top, t.left) } else this.isReceiving() && this._cacheParentPositions() }) } _getShadowRoot() { if (!this._cachedShadowRoot) { const n = U1(Tt(this.element)); this._cachedShadowRoot = n || this._document } return this._cachedShadowRoot } _notifyReceivingSiblings() { const n = this._sortStrategy.getActiveItemsSnapshot().filter(t => t.isDragging()); this._siblings.forEach(t => t._startReceiving(this, n)) } } function sE(e, n) { const { top: t, bottom: r, height: i } = e, o = .05 * i; return n >= t - o && n <= t + o ? 1 : n >= r - o && n <= r + o ? 2 : 0 } function aE(e, n) { const { left: t, right: r, width: i } = e, o = .05 * i; return n >= t - o && n <= t + o ? 1 : n >= r - o && n <= r + o ? 2 : 0 } const Yc = ia({ passive: !1, capture: !0 }); let d5 = (() => { class e { constructor(t, r) { this._ngZone = t, this._dropInstances = new Set, this._dragInstances = new Set, this._activeDragInstances = [], this._globalListeners = new Map, this._draggingPredicate = i => i.isDragging(), this.pointerMove = new X, this.pointerUp = new X, this.scroll = new X, this._preventDefaultWhileDragging = i => { this._activeDragInstances.length > 0 && i.preventDefault() }, this._persistentTouchmoveListener = i => { this._activeDragInstances.length > 0 && (this._activeDragInstances.some(this._draggingPredicate) && i.preventDefault(), this.pointerMove.next(i)) }, this._document = r } registerDropContainer(t) { this._dropInstances.has(t) || this._dropInstances.add(t) } registerDragItem(t) { this._dragInstances.add(t), 1 === this._dragInstances.size && this._ngZone.runOutsideAngular(() => { this._document.addEventListener("touchmove", this._persistentTouchmoveListener, Yc) }) } removeDropContainer(t) { this._dropInstances.delete(t) } removeDragItem(t) { this._dragInstances.delete(t), this.stopDragging(t), 0 === this._dragInstances.size && this._document.removeEventListener("touchmove", this._persistentTouchmoveListener, Yc) } startDragging(t, r) { if (!(this._activeDragInstances.indexOf(t) > -1) && (this._activeDragInstances.push(t), 1 === this._activeDragInstances.length)) { const i = r.type.startsWith("touch"); this._globalListeners.set(i ? "touchend" : "mouseup", { handler: o => this.pointerUp.next(o), options: !0 }).set("scroll", { handler: o => this.scroll.next(o), options: !0 }).set("selectstart", { handler: this._preventDefaultWhileDragging, options: Yc }), i || this._globalListeners.set("mousemove", { handler: o => this.pointerMove.next(o), options: Yc }), this._ngZone.runOutsideAngular(() => { this._globalListeners.forEach((o, s) => { this._document.addEventListener(s, o.handler, o.options) }) }) } } stopDragging(t) { const r = this._activeDragInstances.indexOf(t); r > -1 && (this._activeDragInstances.splice(r, 1), 0 === this._activeDragInstances.length && this._clearGlobalListeners()) } isDragging(t) { return this._activeDragInstances.indexOf(t) > -1 } scrolled(t) { const r = [this.scroll]; return t && t !== this._document && r.push(new be(i => this._ngZone.runOutsideAngular(() => { const s = a => { this._activeDragInstances.length && i.next(a) }; return t.addEventListener("scroll", s, !0), () => { t.removeEventListener("scroll", s, !0) } }))), fa(...r) } ngOnDestroy() { this._dragInstances.forEach(t => this.removeDragItem(t)), this._dropInstances.forEach(t => this.removeDropContainer(t)), this._clearGlobalListeners(), this.pointerMove.complete(), this.pointerUp.complete() } _clearGlobalListeners() { this._globalListeners.forEach((t, r) => { this._document.removeEventListener(r, t.handler, t.options) }), this._globalListeners.clear() } static { this.\u0275fac = function (r) { return new (r || e)(k(le), k(We)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); const f5 = { dragStartThreshold: 5, pointerDirectionChangeThreshold: 5 }; let Bp = (() => { class e { constructor(t, r, i, o) { this._document = t, this._ngZone = r, this._viewportRuler = i, this._dragDropRegistry = o } createDrag(t, r = f5) { return new s5(t, r, this._document, this._ngZone, this._viewportRuler, this._dragDropRegistry) } createDropList(t) { return new c5(t, this._dragDropRegistry, this._document, this._ngZone, this._viewportRuler) } static { this.\u0275fac = function (r) { return new (r || e)(k(We), k(le), k(vB), k(d5)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac, providedIn: "root" }) } } return e })(); const Up = new A("CDK_DRAG_PARENT"), Hp = new A("CdkDragHandle"), lE = new A("CdkDragPlaceholder"); let cE = (() => { class e { constructor(t) { this.templateRef = t } static { this.\u0275fac = function (r) { return new (r || e)(D(rn)) } } static { this.\u0275dir = j({ type: e, selectors: [["ng-template", "cdkDragPlaceholder", ""]], inputs: { data: "data" }, standalone: !0, features: [fe([{ provide: lE, useExisting: e }])] }) } } return e })(); const uE = new A("CdkDragPreview"); let dE = (() => { class e { get matchSize() { return this._matchSize } set matchSize(t) { this._matchSize = yr(t) } constructor(t) { this.templateRef = t, this._matchSize = !1 } static { this.\u0275fac = function (r) { return new (r || e)(D(rn)) } } static { this.\u0275dir = j({ type: e, selectors: [["ng-template", "cdkDragPreview", ""]], inputs: { data: "data", matchSize: "matchSize" }, standalone: !0, features: [fe([{ provide: uE, useExisting: e }])] }) } } return e })(); const fE = new A("CDK_DRAG_CONFIG"), hE = new A("CdkDropList"); let $p = (() => { class e { static { this._dragInstances = [] } get disabled() { return this._disabled || this.dropContainer && this.dropContainer.disabled } set disabled(t) { this._disabled = yr(t), this._dragRef.disabled = this._disabled } constructor(t, r, i, o, s, a, l, c, u, d, p) { this.element = t, this.dropContainer = r, this._ngZone = o, this._viewContainerRef = s, this._dir = l, this._changeDetectorRef = u, this._selfHandle = d, this._parentDrag = p, this._destroyed = new X, this.started = new se, this.released = new se, this.ended = new se, this.entered = new se, this.exited = new se, this.dropped = new se, this.moved = new be(m => { const v = this._dragRef.moved.pipe(re(y => ({ source: this, pointerPosition: y.pointerPosition, event: y.event, delta: y.delta, distance: y.distance }))).subscribe(m); return () => { v.unsubscribe() } }), this._dragRef = c.createDrag(t, { dragStartThreshold: a && null != a.dragStartThreshold ? a.dragStartThreshold : 5, pointerDirectionChangeThreshold: a && null != a.pointerDirectionChangeThreshold ? a.pointerDirectionChangeThreshold : 5, zIndex: a?.zIndex }), this._dragRef.data = this, e._dragInstances.push(this), a && this._assignDefaults(a), r && (this._dragRef._withDropContainer(r._dropListRef), r.addItem(this)), this._syncInputs(this._dragRef), this._handleEvents(this._dragRef) } getPlaceholderElement() { return this._dragRef.getPlaceholderElement() } getRootElement() { return this._dragRef.getRootElement() } reset() { this._dragRef.reset() } getFreeDragPosition() { return this._dragRef.getFreeDragPosition() } setFreeDragPosition(t) { this._dragRef.setFreeDragPosition(t) } ngAfterViewInit() { this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.pipe(Cn(1), Ss(this._destroyed)).subscribe(() => { this._updateRootElement(), this._setupHandlesListener(), this.freeDragPosition && this._dragRef.setFreeDragPosition(this.freeDragPosition) }) }) } ngOnChanges(t) { const r = t.rootElementSelector, i = t.freeDragPosition; r && !r.firstChange && this._updateRootElement(), i && !i.firstChange && this.freeDragPosition && this._dragRef.setFreeDragPosition(this.freeDragPosition) } ngOnDestroy() { this.dropContainer && this.dropContainer.removeItem(this); const t = e._dragInstances.indexOf(this); t > -1 && e._dragInstances.splice(t, 1), this._ngZone.runOutsideAngular(() => { this._destroyed.next(), this._destroyed.complete(), this._dragRef.dispose() }) } _updateRootElement() { const t = this.element.nativeElement; let r = t; this.rootElementSelector && (r = void 0 !== t.closest ? t.closest(this.rootElementSelector) : t.parentElement?.closest(this.rootElementSelector)), this._dragRef.withRootElement(r || t) } _getBoundaryElement() { const t = this.boundaryElement; return t ? "string" == typeof t ? this.element.nativeElement.closest(t) : Tt(t) : null } _syncInputs(t) { t.beforeStarted.subscribe(() => { if (!t.isDragging()) { const r = this._dir, i = this.dragStartDelay, o = this._placeholderTemplate ? { template: this._placeholderTemplate.templateRef, context: this._placeholderTemplate.data, viewContainer: this._viewContainerRef } : null, s = this._previewTemplate ? { template: this._previewTemplate.templateRef, context: this._previewTemplate.data, matchSize: this._previewTemplate.matchSize, viewContainer: this._viewContainerRef } : null; t.disabled = this.disabled, t.lockAxis = this.lockAxis, t.dragStartDelay = "object" == typeof i && i ? i : R1(i), t.constrainPosition = this.constrainPosition, t.previewClass = this.previewClass, t.withBoundaryElement(this._getBoundaryElement()).withPlaceholderTemplate(o).withPreviewTemplate(s).withPreviewContainer(this.previewContainer || "global"), r && t.withDirection(r.value) } }), t.beforeStarted.pipe(Cn(1)).subscribe(() => { if (this._parentDrag) return void t.withParent(this._parentDrag._dragRef); let r = this.element.nativeElement.parentElement; for (; r;) { if (r.classList.contains("cdk-drag")) { t.withParent(e._dragInstances.find(i => i.element.nativeElement === r)?._dragRef || null); break } r = r.parentElement } }) } _handleEvents(t) { t.started.subscribe(r => { this.started.emit({ source: this, event: r.event }), this._changeDetectorRef.markForCheck() }), t.released.subscribe(r => { this.released.emit({ source: this, event: r.event }) }), t.ended.subscribe(r => { this.ended.emit({ source: this, distance: r.distance, dropPoint: r.dropPoint, event: r.event }), this._changeDetectorRef.markForCheck() }), t.entered.subscribe(r => { this.entered.emit({ container: r.container.data, item: this, currentIndex: r.currentIndex }) }), t.exited.subscribe(r => { this.exited.emit({ container: r.container.data, item: this }) }), t.dropped.subscribe(r => { this.dropped.emit({ previousIndex: r.previousIndex, currentIndex: r.currentIndex, previousContainer: r.previousContainer.data, container: r.container.data, isPointerOverContainer: r.isPointerOverContainer, item: this, distance: r.distance, dropPoint: r.dropPoint, event: r.event }) }) } _assignDefaults(t) { const { lockAxis: r, dragStartDelay: i, constrainPosition: o, previewClass: s, boundaryElement: a, draggingDisabled: l, rootElementSelector: c, previewContainer: u } = t; this.disabled = l ?? !1, this.dragStartDelay = i || 0, r && (this.lockAxis = r), o && (this.constrainPosition = o), s && (this.previewClass = s), a && (this.boundaryElement = a), c && (this.rootElementSelector = c), u && (this.previewContainer = u) } _setupHandlesListener() { this._handles.changes.pipe(sc(this._handles), Ue(t => { const r = t.filter(i => i._parentDrag === this).map(i => i.element); this._selfHandle && this.rootElementSelector && r.push(this.element), this._dragRef.withHandles(r) }), Vt(t => fa(...t.map(r => r._stateChanges.pipe(sc(r))))), Ss(this._destroyed)).subscribe(t => { const r = this._dragRef, i = t.element.nativeElement; t.disabled ? r.disableHandle(i) : r.enableHandle(i) }) } static { this.\u0275fac = function (r) { return new (r || e)(D(tt), D(hE, 12), D(We), D(le), D(Wt), D(fE, 8), D(G1, 8), D(Bp), D(Pr), D(Hp, 10), D(Up, 12)) } } static { this.\u0275dir = j({ type: e, selectors: [["", "cdkDrag", ""]], contentQueries: function (r, i, o) { if (1 & r && (vs(o, uE, 5), vs(o, lE, 5), vs(o, Hp, 5)), 2 & r) { let s; Gi(s = qi()) && (i._previewTemplate = s.first), Gi(s = qi()) && (i._placeholderTemplate = s.first), Gi(s = qi()) && (i._handles = s) } }, hostAttrs: [1, "cdk-drag"], hostVars: 4, hostBindings: function (r, i) { 2 & r && zt("cdk-drag-disabled", i.disabled)("cdk-drag-dragging", i._dragRef.isDragging()) }, inputs: { data: ["cdkDragData", "data"], lockAxis: ["cdkDragLockAxis", "lockAxis"], rootElementSelector: ["cdkDragRootElement", "rootElementSelector"], boundaryElement: ["cdkDragBoundary", "boundaryElement"], dragStartDelay: ["cdkDragStartDelay", "dragStartDelay"], freeDragPosition: ["cdkDragFreeDragPosition", "freeDragPosition"], disabled: ["cdkDragDisabled", "disabled"], constrainPosition: ["cdkDragConstrainPosition", "constrainPosition"], previewClass: ["cdkDragPreviewClass", "previewClass"], previewContainer: ["cdkDragPreviewContainer", "previewContainer"] }, outputs: { started: "cdkDragStarted", released: "cdkDragReleased", ended: "cdkDragEnded", entered: "cdkDragEntered", exited: "cdkDragExited", dropped: "cdkDragDropped", moved: "cdkDragMoved" }, exportAs: ["cdkDrag"], standalone: !0, features: [fe([{ provide: Up, useExisting: e }]), kt] }) } } return e })(); const zp = new A("CdkDropListGroup"); let pE = (() => { class e { constructor() { this._items = new Set, this._disabled = !1 } get disabled() { return this._disabled } set disabled(t) { this._disabled = yr(t) } ngOnDestroy() { this._items.clear() } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275dir = j({ type: e, selectors: [["", "cdkDropListGroup", ""]], inputs: { disabled: ["cdkDropListGroupDisabled", "disabled"] }, exportAs: ["cdkDropListGroup"], standalone: !0, features: [fe([{ provide: zp, useExisting: e }])] }) } } return e })(), g5 = 0, Qc = (() => { class e { static { this._dropLists = [] } get disabled() { return this._disabled || !!this._group && this._group.disabled } set disabled(t) { this._dropListRef.disabled = this._disabled = yr(t) } constructor(t, r, i, o, s, a, l) { this.element = t, this._changeDetectorRef = i, this._scrollDispatcher = o, this._dir = s, this._group = a, this._destroyed = new X, this.connectedTo = [], this.id = "cdk-drop-list-" + g5++, this.enterPredicate = () => !0, this.sortPredicate = () => !0, this.dropped = new se, this.entered = new se, this.exited = new se, this.sorted = new se, this._unsortedItems = new Set, this._dropListRef = r.createDropList(t), this._dropListRef.data = this, l && this._assignDefaults(l), this._dropListRef.enterPredicate = (c, u) => this.enterPredicate(c.data, u.data), this._dropListRef.sortPredicate = (c, u, d) => this.sortPredicate(c, u.data, d.data), this._setupInputSyncSubscription(this._dropListRef), this._handleEvents(this._dropListRef), e._dropLists.push(this), a && a._items.add(this) } addItem(t) { this._unsortedItems.add(t), this._dropListRef.isDragging() && this._syncItemsWithRef() } removeItem(t) { this._unsortedItems.delete(t), this._dropListRef.isDragging() && this._syncItemsWithRef() } getSortedItems() { return Array.from(this._unsortedItems).sort((t, r) => t._dragRef.getVisibleElement().compareDocumentPosition(r._dragRef.getVisibleElement()) & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1) } ngOnDestroy() { const t = e._dropLists.indexOf(this); t > -1 && e._dropLists.splice(t, 1), this._group && this._group._items.delete(this), this._unsortedItems.clear(), this._dropListRef.dispose(), this._destroyed.next(), this._destroyed.complete() } _setupInputSyncSubscription(t) { this._dir && this._dir.change.pipe(sc(this._dir.value), Ss(this._destroyed)).subscribe(r => t.withDirection(r)), t.beforeStarted.subscribe(() => { const r = function W4(e) { return Array.isArray(e) ? e : [e] }(this.connectedTo).map(i => "string" == typeof i ? e._dropLists.find(s => s.id === i) : i); if (this._group && this._group._items.forEach(i => { -1 === r.indexOf(i) && r.push(i) }), !this._scrollableParentsResolved) { const i = this._scrollDispatcher.getAncestorScrollContainers(this.element).map(o => o.getElementRef().nativeElement); this._dropListRef.withScrollableParents(i), this._scrollableParentsResolved = !0 } t.disabled = this.disabled, t.lockAxis = this.lockAxis, t.sortingDisabled = yr(this.sortingDisabled), t.autoScrollDisabled = yr(this.autoScrollDisabled), t.autoScrollStep = R1(this.autoScrollStep, 2), t.connectedTo(r.filter(i => i && i !== this).map(i => i._dropListRef)).withOrientation(this.orientation) }) } _handleEvents(t) { t.beforeStarted.subscribe(() => { this._syncItemsWithRef(), this._changeDetectorRef.markForCheck() }), t.entered.subscribe(r => { this.entered.emit({ container: this, item: r.item.data, currentIndex: r.currentIndex }) }), t.exited.subscribe(r => { this.exited.emit({ container: this, item: r.item.data }), this._changeDetectorRef.markForCheck() }), t.sorted.subscribe(r => { this.sorted.emit({ previousIndex: r.previousIndex, currentIndex: r.currentIndex, container: this, item: r.item.data }) }), t.dropped.subscribe(r => { this.dropped.emit({ previousIndex: r.previousIndex, currentIndex: r.currentIndex, previousContainer: r.previousContainer.data, container: r.container.data, item: r.item.data, isPointerOverContainer: r.isPointerOverContainer, distance: r.distance, dropPoint: r.dropPoint, event: r.event }), this._changeDetectorRef.markForCheck() }), fa(t.receivingStarted, t.receivingStopped).subscribe(() => this._changeDetectorRef.markForCheck()) } _assignDefaults(t) { const { lockAxis: r, draggingDisabled: i, sortingDisabled: o, listAutoScrollDisabled: s, listOrientation: a } = t; this.disabled = i ?? !1, this.sortingDisabled = o ?? !1, this.autoScrollDisabled = s ?? !1, this.orientation = a || "vertical", r && (this.lockAxis = r) } _syncItemsWithRef() { this._dropListRef.withItems(this.getSortedItems().map(t => t._dragRef)) } static { this.\u0275fac = function (r) { return new (r || e)(D(tt), D(Bp), D(Pr), D(mB), D(G1, 8), D(zp, 12), D(fE, 8)) } } static { this.\u0275dir = j({ type: e, selectors: [["", "cdkDropList", ""], ["cdk-drop-list"]], hostAttrs: [1, "cdk-drop-list"], hostVars: 7, hostBindings: function (r, i) { 2 & r && (nt("id", i.id), zt("cdk-drop-list-disabled", i.disabled)("cdk-drop-list-dragging", i._dropListRef.isDragging())("cdk-drop-list-receiving", i._dropListRef.isReceiving())) }, inputs: { connectedTo: ["cdkDropListConnectedTo", "connectedTo"], data: ["cdkDropListData", "data"], orientation: ["cdkDropListOrientation", "orientation"], id: "id", lockAxis: ["cdkDropListLockAxis", "lockAxis"], disabled: ["cdkDropListDisabled", "disabled"], sortingDisabled: ["cdkDropListSortingDisabled", "sortingDisabled"], enterPredicate: ["cdkDropListEnterPredicate", "enterPredicate"], sortPredicate: ["cdkDropListSortPredicate", "sortPredicate"], autoScrollDisabled: ["cdkDropListAutoScrollDisabled", "autoScrollDisabled"], autoScrollStep: ["cdkDropListAutoScrollStep", "autoScrollStep"] }, outputs: { dropped: "cdkDropListDropped", entered: "cdkDropListEntered", exited: "cdkDropListExited", sorted: "cdkDropListSorted" }, exportAs: ["cdkDropList"], standalone: !0, features: [fe([{ provide: zp, useValue: void 0 }, { provide: hE, useExisting: e }])] }) } } return e })(), m5 = (() => { class e { static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275mod = bt({ type: e }) } static { this.\u0275inj = ct({ providers: [Bp], imports: [yB] }) } } return e })(); function _5(e, n) { if (1 & e && (ge(0), f(1, "span", 18), g(2), h(), me()), 2 & e) { const t = E(); _(2), U(" ", (null == t.tasks ? null : t.tasks.length) || 0, " items ") } } function v5(e, n) { 1 & e && M(0, "span", 19) } function y5(e, n) { 1 & e && (f(0, "div", 20), M(1, "span", 21), g(2, " Loading... "), h()) } function b5(e, n) { if (1 & e && (f(0, "div", 22), g(1), h()), 2 & e) { const t = E(); _(1), te(t.error) } } function D5(e, n) { 1 & e && (f(0, "div", 24)(1, "div", 25)(2, "div", 26), M(3, "div", 27), f(4, "div", 28), M(5, "span", 29)(6, "span", 30)(7, "span", 31), h(), M(8, "div", 32), h(), M(9, "div", 33), h()()) } const C5 = function () { return [1, 2, 3, 4, 5] }; function w5(e, n) { 1 & e && (ge(0), I(1, D5, 10, 0, "div", 23), me()), 2 & e && (_(1), b("ngForOf", Gt(1, C5))) } function E5(e, n) { 1 & e && (f(0, "div", 37), g(1, " No backlog items yet. Add one above. "), h()) } const I5 = function (e, n, t) { return { "border-sky-200 text-sky-700 bg-sky-50": e, "border-amber-200 text-amber-700 bg-amber-50": n, "border-rose-200 text-rose-700 bg-rose-50": t } }, S5 = function (e, n, t, r) { return { "bg-emerald-50 text-emerald-700 border-emerald-200": e, "bg-amber-50 text-amber-700 border-amber-200": n, "bg-orange-50 text-orange-700 border-orange-200": t, "bg-red-50 text-red-700 border-red-200": r } }, T5 = function (e) { return ["/tasks", e] }; function x5(e, n) { if (1 & e && (f(0, "div", 38)(1, "div", 39)(2, "div", 40)(3, "div", 41), g(4), h(), f(5, "div", 42)(6, "span", 43), g(7), h(), f(8, "span", 44), g(9), h(), f(10, "span", 44), g(11), h()(), f(12, "div", 45), g(13), h()(), f(14, "a", 46), g(15, " Open "), h()()()), 2 & e) { const t = n.$implicit; _(4), te(t.title), _(3), U(" ", t.key || "TASK-" + t.id, " "), _(1), b("ngClass", hs(8, I5, "TASK" === (t.issueType || "TASK"), "STORY" === t.issueType, "BUG" === t.issueType)), _(1), U(" ", t.issueType || "TASK", " "), _(1), b("ngClass", Rl(12, S5, "LOW" === (t.priority || "MEDIUM"), "MEDIUM" === (t.priority || "MEDIUM"), "HIGH" === t.priority, "CRITICAL" === t.priority)), _(1), U(" ", t.priority || "MEDIUM", " "), _(2), U(" ", t.description, " "), _(1), b("routerLink", Mf(17, T5, t.id)) } } function M5(e, n) { if (1 & e) { const t = ve(); ge(0), f(1, "button", 52), R("click", function () { const o = V(t).$implicit; return B(E(3).setPage(o)) }), g(2), h(), me() } if (2 & e) { const t = n.$implicit, r = E(3); _(1), b("ngClass", t === r.currentPage ? "bg-slate-900 text-white border-slate-900" : "bg-white text-slate-700 border-slate-300 hover:bg-slate-50"), _(1), U(" ", t, " ") } } function A5(e, n) { if (1 & e) { const t = ve(); f(0, "div", 47)(1, "div", 48), g(2), h(), f(3, "div", 49)(4, "button", 50), R("click", function () { return V(t), B(E(2).prevPage()) }), g(5, " Prev "), h(), I(6, M5, 3, 2, "ng-container", 51), f(7, "button", 50), R("click", function () { return V(t), B(E(2).nextPage()) }), g(8, " Next "), h()()() } if (2 & e) { const t = E(2); _(2), Ui(" Showing ", t.pageStart + 1, "\u2013", t.pageEnd, " of ", t.tasks.length, " "), _(2), b("disabled", 1 === t.currentPage), _(2), b("ngForOf", t.pages), _(1), b("disabled", t.currentPage === t.totalPages) } } function k5(e, n) { if (1 & e && (I(0, E5, 2, 0, "div", 34), I(1, x5, 16, 19, "div", 35), I(2, A5, 9, 6, "div", 36)), 2 & e) { const t = E(); b("ngIf", !(null != t.tasks && t.tasks.length)), _(1), b("ngForOf", t.pagedTasks)("ngForTrackBy", t.trackById), _(1), b("ngIf", null == t.tasks ? null : t.tasks.length) } } let gE = (() => { class e { get totalPages() { return Math.max(1, Math.ceil(this.tasks.length / this.pageSize)) } get pageStart() { return (this.currentPage - 1) * this.pageSize } get pageEnd() { return Math.min(this.pageStart + this.pageSize, this.tasks.length) } get pagedTasks() { return this.tasks.slice(this.pageStart, this.pageEnd) } get pages() { return Array.from({ length: this.totalPages }, (t, r) => r + 1) } setPage(t) { this.currentPage = Math.min(Math.max(1, t), this.totalPages) } prevPage() { this.setPage(this.currentPage - 1) } nextPage() { this.setPage(this.currentPage + 1) } trackById(t, r) { return r.id ?? t } constructor(t) { this.api = t, this.tasks = [], this.loading = !1, this.error = "", this.newTitle = "", this.editingTaskId = null, this.editingTitleValue = "", this.savingEdit = !1, this.pageSize = 5, this.currentPage = 1 } ngOnInit() { this.load() } load() { this.loading = !0, this.api.getTasks().subscribe({ next: t => { this.loading = !1, this.error = "", this.tasks = [...t.filter(r => !r.status || "OPEN" === r.status)].sort((r, i) => (r.order ?? 0) - (i.order ?? 0)), this.currentPage > this.totalPages && (this.currentPage = this.totalPages) }, error: t => { this.loading = !1, this.error = t?.error?.message || t?.message || "Failed to load backlog" } }) } drop(t) { Vp(this.tasks, this.pageStart + t.previousIndex, this.pageStart + t.currentIndex), this.tasks.forEach((o, s) => { o.id && o.order !== s && this.api.updateTask(o.id, { ...o, order: s }).subscribe({ next: () => { }, error: () => { } }) }) } create() { const t = this.newTitle.trim(); t && this.api.createTask({ title: t, status: "OPEN", order: this.tasks.length, issueType: "TASK", priority: "MEDIUM" }).subscribe({ next: i => { this.tasks = [...this.tasks, i], this.newTitle = "", this.setPage(this.totalPages) }, error: () => { } }) } startInlineEdit(t, r) { r?.stopPropagation(), t?.id && (this.editingTaskId = t.id, this.editingTitleValue = (t.title || "").toString(), setTimeout(() => { const i = document.getElementById(`bl-edit-title-${t.id}`); i?.focus(), i?.select() }, 0)) } cancelInlineEdit(t) { t?.stopPropagation(), this.savingEdit = !1, this.editingTaskId = null, this.editingTitleValue = "" } saveInlineEdit(t, r) { if (r?.stopPropagation(), !t?.id) return; const i = (this.editingTitleValue || "").trim(); if (!i || i === t.title) return void this.cancelInlineEdit(); this.savingEdit = !0; const o = { ...t, title: i }; this.api.updateTask(t.id, o).subscribe({ next: s => { t.title = s?.title ?? i, this.savingEdit = !1, this.cancelInlineEdit() }, error: () => { this.savingEdit = !1, this.cancelInlineEdit() } }) } static { this.\u0275fac = function (r) { return new (r || e)(D(gr)) } } static { this.\u0275cmp = rt({ type: e, selectors: [["app-backlog"]], decls: 25, vars: 7, consts: [[1, "space-y-5"], [1, "relative", "overflow-hidden", "rounded-2xl", "border", "border-slate-200", "bg-white"], [1, "h-1", "w-full", "bg-gradient-to-r", "from-sky-400", "via-violet-500", "to-emerald-500"], [1, "px-4", "md:px-6", "py-4", "flex", "items-center", "justify-between"], [1, "flex", "items-center", "gap-2"], [1, "text-xl"], [1, "text-xl", "font-semibold"], [4, "ngIf", "ngIfElse"], ["countSkeleton", ""], ["class", "text-sm text-slate-500 flex items-center gap-2", 4, "ngIf"], [1, "flex", "gap-2", "items-center", "rounded-xl", "border", "border-slate-200", "bg-white", "p-2", "shadow-sm", 3, "ngSubmit"], [1, "pl-2", "text-slate-400"], ["placeholder", "Create backlog item...", "name", "backlogTitle", 1, "flex-1", "border-0", "focus:ring-0", "bg-transparent", "text-sm", "placeholder:text-slate-400", 3, "ngModel", "ngModelChange"], ["type", "submit", 1, "px-3", "py-2", "rounded-lg", "text-white", "bg-gradient-to-r", "from-slate-900", "to-slate-700", "hover:from-slate-800", "hover:to-slate-700"], ["class", "text-red-600 text-sm", 4, "ngIf"], ["cdkDropList", "", 1, "rounded-2xl", "border", "border-slate-200", "bg-white", "overflow-hidden", 3, "cdkDropListDropped"], [1, "h-1", "w-full", "bg-gradient-to-r", "from-emerald-400", "via-sky-400", "to-violet-500"], ["listLoaded", ""], [1, "ml-2", "text-xs", "px-2", "py-0.5", "rounded-full", "border", "bg-slate-50", "text-slate-600"], [1, "ml-2", "inline-block", "h-5", "w-20", "rounded-full", "bg-slate-200", "animate-pulse"], [1, "text-sm", "text-slate-500", "flex", "items-center", "gap-2"], [1, "inline-block", "w-3", "h-3", "border-2", "border-slate-400/60", "border-t-transparent", "rounded-full", "animate-spin"], [1, "text-red-600", "text-sm"], ["class", "p-4 border-b border-slate-100 last:border-b-0", 4, "ngFor", "ngForOf"], [1, "p-4", "border-b", "border-slate-100", "last:border-b-0"], [1, "flex", "items-start", "justify-between", "gap-3", "animate-pulse"], [1, "min-w-0", "flex-1"], [1, "h-4", "bg-slate-200", "rounded", "w-2/3"], [1, "mt-2", "flex", "flex-wrap", "items-center", "gap-2"], [1, "h-5", "w-24", "rounded-full", "bg-slate-100"], [1, "h-5", "w-16", "rounded-full", "bg-slate-100"], [1, "h-5", "w-20", "rounded-full", "bg-slate-100"], [1, "mt-2", "h-3", "bg-slate-100", "rounded", "w-3/4"], [1, "h-8", "w-16", "rounded-lg", "bg-slate-100"], ["class", "p-8 text-center text-slate-500", 4, "ngIf"], ["class", "p-4 border-b border-slate-100 last:border-b-0 cursor-grab active:cursor-grabbing bg-white hover:bg-slate-50 transition", "cdkDrag", "", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "flex items-center justify-between px-4 py-3 bg-white", 4, "ngIf"], [1, "p-8", "text-center", "text-slate-500"], ["cdkDrag", "", 1, "p-4", "border-b", "border-slate-100", "last:border-b-0", "cursor-grab", "active:cursor-grabbing", "bg-white", "hover:bg-slate-50", "transition"], [1, "flex", "items-start", "justify-between", "gap-3"], [1, "min-w-0"], [1, "font-semibold", "text-slate-800", "truncate"], [1, "mt-1", "flex", "flex-wrap", "items-center", "gap-2", "text-xs"], [1, "px-2", "py-0.5", "rounded-full", "border", "bg-slate-50", "text-slate-600"], [1, "px-2", "py-0.5", "rounded-full", "border", "bg-white", 3, "ngClass"], [1, "mt-1", "text-xs", "text-slate-500", "line-clamp-1"], [1, "shrink-0", "px-3", "py-1.5", "text-sm", "rounded-lg", "border", "border-slate-300", "bg-white", "hover:bg-slate-50", 3, "routerLink"], [1, "flex", "items-center", "justify-between", "px-4", "py-3", "bg-white"], [1, "text-sm", "text-slate-600"], [1, "flex", "items-center", "gap-1"], [1, "px-3", "py-1.5", "rounded-md", "border", "border-slate-300", "bg-white", "text-slate-700", "hover:bg-slate-50", "disabled:opacity-50", 3, "disabled", "click"], [4, "ngFor", "ngForOf"], [1, "px-3", "py-1.5", "rounded-md", "border", 3, "ngClass", "click"]], template: function (r, i) { if (1 & r && (f(0, "div", 0)(1, "div", 1), M(2, "div", 2), f(3, "div", 3)(4, "div", 4)(5, "span", 5), g(6, "\u{1f5c2}\ufe0f"), h(), f(7, "div", 6), g(8, "Backlog"), h(), I(9, _5, 3, 1, "ng-container", 7), I(10, v5, 1, 0, "ng-template", null, 8, qe), h(), I(12, y5, 3, 0, "div", 9), h()(), f(13, "form", 10), R("ngSubmit", function () { return i.create() }), f(14, "span", 11), g(15, "\uff0b"), h(), f(16, "input", 12), R("ngModelChange", function (s) { return i.newTitle = s }), h(), f(17, "button", 13), g(18, " Add "), h()(), I(19, b5, 2, 1, "div", 14), f(20, "div", 15), R("cdkDropListDropped", function (s) { return i.drop(s) }), M(21, "div", 16), I(22, w5, 2, 2, "ng-container", 7), I(23, k5, 3, 4, "ng-template", null, 17, qe), h()()), 2 & r) { const o = Ve(11), s = Ve(24); _(9), b("ngIf", !i.loading)("ngIfElse", o), _(3), b("ngIf", i.loading), _(4), b("ngModel", i.newTitle), _(3), b("ngIf", i.error), _(3), b("ngIf", i.loading)("ngIfElse", s) } }, dependencies: [Xi, Fr, Dn, Gr, Kn, Hr, $r, In, Js, Qs, Qc, $p], encapsulation: 2 }) } } return e })(); function R5(e, n) { if (1 & e && (f(0, "div", 23), g(1), h()), 2 & e) { const t = E(); _(1), U(" ", t.toastMsg, " ") } } function P5(e, n) { if (1 & e && (ge(0), g(1), me()), 2 & e) { const t = E(); _(1), U(" ", (null == t.project ? null : t.project.name) || "Board", " ") } } function N5(e, n) { 1 & e && M(0, "span", 24) } function O5(e, n) { if (1 & e && (ge(0), g(1), me()), 2 & e) { const t = E(3); _(1), U(" \u2022 matching \u201c", t.projectSearch, "\u201d ") } } function F5(e, n) { 1 & e && (f(0, "div", 35), g(1, " No matching projects. Try a different search. "), h()) } function L5(e, n) { if (1 & e) { const t = ve(); f(0, "button", 38), R("click", function () { const o = V(t).$implicit; return B(E(4).goToProject(o)) }), f(1, "span", 39), g(2, " \u{1f4c1} "), h(), f(3, "div", 40)(4, "div", 41), g(5), h(), f(6, "div", 42), g(7, "Open board"), h()(), f(8, "span", 43), g(9, "\u203a"), h()() } if (2 & e) { const t = n.$implicit; _(5), U(" ", t.name, " ") } } function j5(e, n) { if (1 & e && (f(0, "div", 36), I(1, L5, 10, 1, "button", 37), h()), 2 & e) { const t = E(3); _(1), b("ngForOf", t.projectsPaged)("ngForTrackBy", t.trackProjectById) } } function V5(e, n) { if (1 & e) { const t = ve(); ge(0), f(1, "button", 49), R("click", function () { const o = V(t).$implicit; return B(E(4).setProjectsPage(o)) }), g(2), h(), me() } if (2 & e) { const t = n.$implicit, r = E(4); _(1), b("ngClass", t === r.projectsPage ? "bg-slate-900 text-white border-slate-900" : "bg-white text-slate-700 border-slate-300 hover:bg-slate-50"), nt("aria-current", t === r.projectsPage ? "page" : null), _(1), U(" ", t, " ") } } function B5(e, n) { if (1 & e) { const t = ve(); f(0, "div", 44)(1, "div", 27), g(2), h(), f(3, "div", 45)(4, "button", 46), R("click", function () { return V(t), B(E(3).prevProjectsPage()) }), g(5, " Prev "), h(), I(6, V5, 3, 3, "ng-container", 47), f(7, "button", 48), R("click", function () { return V(t), B(E(3).nextProjectsPage()) }), g(8, " Next "), h()()() } if (2 & e) { const t = E(3); _(2), Ui(" Showing ", t.filteredProjects.length ? t.projectsPageStart + 1 : 0, "\u2013", t.projectsPageEnd, " of ", t.filteredProjects.length, " "), _(2), b("disabled", 1 === t.projectsPage), _(2), b("ngForOf", t.projectsPages), _(1), b("disabled", t.projectsPage === t.projectsTotalPages) } } function U5(e, n) { if (1 & e) { const t = ve(); ge(0), f(1, "div", 26)(2, "div", 27)(3, "span", 28), g(4), h(), g(5), I(6, O5, 2, 1, "ng-container", 21), h(), f(7, "div", 29)(8, "input", 30), R("ngModelChange", function (i) { return V(t), B(E(2).projectSearch = i) })("ngModelChange", function (i) { return V(t), B(E(2).onProjectSearchChange(i)) }), h(), f(9, "span", 31), g(10, "\u{1f50e}"), h()()(), I(11, F5, 2, 0, "div", 32), I(12, j5, 2, 2, "div", 33), I(13, B5, 9, 6, "div", 34), me() } if (2 & e) { const t = E(2); _(4), te(t.filteredProjects.length), _(1), U(" project", 1 === t.filteredProjects.length ? "" : "s", " "), _(1), b("ngIf", t.projectSearch), _(2), b("ngModel", t.projectSearch), _(3), b("ngIf", (null == t.projects ? null : t.projects.length) && !t.filteredProjects.length), _(1), b("ngIf", t.filteredProjects.length), _(1), b("ngIf", t.filteredProjects.length) } } function H5(e, n) { if (1 & e && (f(0, "div", 25), I(1, U5, 14, 7, "ng-container", 9), h()), 2 & e) { const t = E(), r = Ve(25); _(1), b("ngIf", !t.loadingProjects)("ngIfElse", r) } } function $5(e, n) { 1 & e && (f(0, "div", 51)(1, "div", 52), M(2, "span", 53), f(3, "div", 40), M(4, "div", 54)(5, "div", 55), h(), M(6, "span", 56), h()()) } const z5 = function () { return [1, 2, 3, 4, 5, 6, 7, 8, 9] }; function G5(e, n) { 1 & e && (f(0, "div", 36), I(1, $5, 7, 0, "div", 50), h()), 2 & e && (_(1), b("ngForOf", Gt(1, z5))) } function q5(e, n) { 1 & e && (f(0, "div", 57), g(1, " No projects yet. Create or select a project to view its board. "), h()) } function W5(e, n) { if (1 & e && (f(0, "div", 61)(1, "div", 62), g(2), h(), f(3, "span", 63), g(4), h()()), 2 & e) { const t = n.$implicit, r = E(3); b("title", (t.name || t.email) + " \u2022 " + t.email), _(2), U(" ", r.initialsOf(t.name || t.email), " "), _(2), U(" ", t.name || t.email, " ") } } function Z5(e, n) { if (1 & e && (ge(0), f(1, "div", 58)(2, "div", 59), g(3, "Members"), h(), I(4, W5, 5, 3, "div", 60), h(), me()), 2 & e) { const t = E(2); _(4), b("ngForOf", t.members) } } function K5(e, n) { if (1 & e && (f(0, "div", 25), I(1, Z5, 5, 1, "ng-container", 9), h()), 2 & e) { const t = E(), r = Ve(29); _(1), b("ngIf", !t.loadingMembers && t.members.length)("ngIfElse", r) } } function Y5(e, n) { 1 & e && M(0, "div", 65) } const Q5 = function () { return [1, 2, 3, 4, 5] }; function X5(e, n) { 1 & e && (f(0, "div", 58)(1, "div", 59), g(2, "Members"), h(), I(3, Y5, 1, 0, "div", 64), h()), 2 & e && (_(3), b("ngForOf", Gt(1, Q5))) } function J5(e, n) { if (1 & e && (f(0, "div", 80), g(1), h()), 2 & e) { const t = E().$implicit; _(1), U(" No issues in ", t.label, " \u2014 drag here or add below. ") } } function eU(e, n) { if (1 & e && (f(0, "span", 101), g(1), h()), 2 & e) { const t = E(2).$implicit; _(1), U(" ", t.key, " ") } } const mE = function (e, n, t, r) { return { "bg-emerald-50 text-emerald-700 border-emerald-200": e, "bg-amber-50 text-amber-700 border-amber-200": n, "bg-orange-50 text-orange-700 border-orange-200": t, "bg-red-50 text-red-700 border-red-200": r } }; function tU(e, n) { if (1 & e && (f(0, "span", 102), g(1), h()), 2 & e) { const t = E(2).$implicit; b("ngClass", Rl(2, mE, "LOW" === t.priority, "MEDIUM" === t.priority, "HIGH" === t.priority, "CRITICAL" === t.priority)), _(1), U(" ", t.priority, " ") } } function nU(e, n) { if (1 & e) { const t = ve(); ge(0), f(1, "div", 92)(2, "div", 93), g(3), h(), f(4, "button", 94), R("click", function (i) { V(t); const o = E().$implicit; return B(E(4).startTitleEdit(o, i)) }), Ee(), f(5, "svg", 95), M(6, "path", 96)(7, "path", 97), h()()(), Le(), f(8, "div", 98), I(9, eU, 2, 1, "span", 99), I(10, tU, 2, 7, "span", 100), h(), me() } if (2 & e) { const t = E().$implicit; _(3), te(t.title), _(6), b("ngIf", t.key), _(1), b("ngIf", t.priority) } } function rU(e, n) { 1 & e && (Ee(), f(0, "svg", 95), M(1, "path", 119), h()) } function iU(e, n) { 1 & e && (Ee(), f(0, "svg", 120), M(1, "circle", 121)(2, "path", 122), h()) } function oU(e, n) { if (1 & e && (f(0, "span", 123), g(1), h()), 2 & e) { const t = E(2).$implicit; _(1), U(" ", t.key, " ") } } function sU(e, n) { if (1 & e && (f(0, "span", 124), g(1), h()), 2 & e) { const t = E(2).$implicit; b("ngClass", Rl(2, mE, "LOW" === t.priority, "MEDIUM" === t.priority, "HIGH" === t.priority, "CRITICAL" === t.priority)), _(1), U(" ", t.priority, " ") } } function aU(e, n) { if (1 & e) { const t = ve(); f(0, "div", 103), R("click", function (i) { return i.stopPropagation() }), M(1, "div", 104), f(2, "div", 11)(3, "div", 105)(4, "span", 106), Ee(), f(5, "svg", 95), M(6, "path", 96)(7, "path", 97), h()(), Le(), f(8, "input", 107), R("input", function (i) { return V(t), B(E(5).editingTitleValue = i.target.value) })("keydown.enter", function (i) { V(t); const o = E().$implicit; return B(E(4).saveTitle(o, i)) })("keydown.escape", function (i) { return V(t), B(E(5).cancelTitleEdit(i)) }), h()(), f(9, "button", 108), R("click", function (i) { V(t); const o = E().$implicit; return B(E(4).saveTitle(o, i)) }), I(10, rU, 2, 0, "svg", 109), I(11, iU, 3, 0, "svg", 110), f(12, "span", 111), g(13), h()(), f(14, "button", 112), R("click", function (i) { return V(t), B(E(5).cancelTitleEdit(i)) }), Ee(), f(15, "svg", 95), M(16, "path", 113), h(), Le(), f(17, "span", 111), g(18, "Cancel"), h()()(), f(19, "div", 114)(20, "div", 11), I(21, oU, 2, 1, "span", 115), I(22, sU, 2, 7, "span", 116), h(), f(23, "div", 117)(24, "span", 7), g(25, "\u21a9"), h(), f(26, "span"), g(27, "Enter to save"), h(), f(28, "span", 118), g(29, "\u2022"), h(), f(30, "span", 7), g(31, "Esc"), h(), f(32, "span"), g(33, "to cancel"), h()()()() } if (2 & e) { const t = E().$implicit, r = E(4); _(8), ss("id", "edit-title-", t.id, ""), b("value", r.editingTitleValue), _(1), b("disabled", r.savingTitle), _(1), b("ngIf", !r.savingTitle), _(1), b("ngIf", r.savingTitle), _(2), te(r.savingTitle ? "Saving\u2026" : "Save"), _(1), b("disabled", r.savingTitle), _(7), b("ngIf", t.key), _(1), b("ngIf", t.priority) } } function lU(e, n) { if (1 & e && (f(0, "span"), g(1), h()), 2 & e) { const t = n.ngIf, r = E(5); _(1), te(r.initialsOf(t)) } } function cU(e, n) { 1 & e && (f(0, "span"), g(1, "\u{1f464}"), h()) } function uU(e, n) { 1 & e && (f(0, "div", 134), g(1, "\u2714"), h()) } function dU(e, n) { if (1 & e) { const t = ve(); f(0, "button", 129), R("click", function (i) { const s = V(t).$implicit, a = E(2).$implicit; return B(E(4).assignTo(a, s, i)) }), f(1, "div", 130), g(2), h(), f(3, "div", 83)(4, "div", 131), g(5), h(), f(6, "div", 132), g(7), h()(), I(8, uU, 2, 0, "div", 133), h() } if (2 & e) { const t = n.$implicit, r = E(2).$implicit, i = E(4); _(2), U(" ", i.initialsOf(t.name || t.email), " "), _(3), te(t.name || t.email), _(2), te(t.email), _(1), b("ngIf", i.isAssignedTo(r, t)) } } function fU(e, n) { 1 & e && (f(0, "div", 135), g(1, " Assigning... "), h()) } function hU(e, n) { if (1 & e && (f(0, "div", 125), R("click", function (r) { return r.stopPropagation() }), f(1, "div", 126), g(2, "Assign to"), h(), I(3, dU, 9, 4, "button", 127), I(4, fU, 2, 0, "div", 128), h()), 2 & e) { const t = E().$implicit, r = E(4); _(3), b("ngForOf", r.members), _(1), b("ngIf", r.assigningTaskId === (null == t ? null : t.id)) } } function pU(e, n) { if (1 & e && (f(0, "div", 136)(1, "span", 7), g(2, "\u{1f464}"), h(), f(3, "span", 137), g(4), h()()), 2 & e) { const t = E().$implicit; _(4), te(t.assigneeName) } } function gU(e, n) { if (1 & e && (f(0, "div", 136)(1, "span", 7), g(2, "\u{1f4c4}"), h(), f(3, "span", 138), g(4), h()()), 2 & e) { const t = E().$implicit; _(4), te(t.issueType) } } function mU(e, n) { if (1 & e && (f(0, "div", 136)(1, "span", 7), g(2, "\u23f3"), h(), f(3, "span"), g(4), qt(5, "date"), h()()), 2 & e) { const t = E().$implicit; _(4), te(Af(5, 1, t.dueDate, "MMM d")) } } function _U(e, n) { if (1 & e && (f(0, "div", 139)(1, "div", 28), g(2), h()()), 2 & e) { const t = E().$implicit; _(2), te(t.title) } } function vU(e, n) { 1 & e && M(0, "div", 140) } const yU = function (e, n, t) { return { "border-l-sky-400": e, "border-l-amber-500": n, "border-l-emerald-500": t } }; function bU(e, n) { if (1 & e) { const t = ve(); f(0, "div", 81), R("click", function () { const o = V(t).$implicit; return B(E(4).onCardClick(o)) })("cdkDragStarted", function () { return V(t), B(E(4).onDragStarted()) })("cdkDragEnded", function () { return V(t), B(E(4).onDragEnded()) }), f(1, "div", 82)(2, "div", 83), I(3, nU, 11, 3, "ng-container", 9), I(4, aU, 34, 9, "ng-template", null, 84, qe), h(), f(6, "div", 85)(7, "button", 86), R("click", function (i) { const s = V(t).$implicit; return B(E(4).openAssigneeMenu(s, i)) }), I(8, lU, 2, 1, "span", 21), I(9, cU, 2, 0, "span", 21), h(), I(10, hU, 5, 2, "div", 87), h()(), f(11, "div", 88)(12, "div", 5), I(13, pU, 5, 1, "div", 89), I(14, gU, 5, 1, "div", 89), h(), I(15, mU, 6, 4, "div", 89), h(), I(16, _U, 3, 1, "ng-template", 90), I(17, vU, 1, 0, "ng-template", 91), h() } if (2 & e) { const t = n.$implicit, r = Ve(5), i = E().$implicit, o = E(3); Un("display", o.matchesFilter(t) ? null : "none"), b("ngClass", hs(12, yU, "OPEN" === i.key, "IN_PROGRESS" === i.key, "DONE" === i.key)), _(3), b("ngIf", o.editingTitleTaskId !== (null == t ? null : t.id))("ngIfElse", r), _(4), b("title", t.assigneeName ? "Assigned to " + t.assigneeName : "Assign"), _(1), b("ngIf", t.assigneeName), _(1), b("ngIf", !t.assigneeName), _(1), b("ngIf", o.assigneeMenuForTaskId === (null == t ? null : t.id)), _(3), b("ngIf", t.assigneeName), _(1), b("ngIf", t.issueType), _(1), b("ngIf", t.dueDate) } } function DU(e, n) { if (1 & e) { const t = ve(); f(0, "form", 141), R("ngSubmit", function () { V(t); const i = E().$implicit; return B(E(3).createQuick(i.key)) }), f(1, "span", 142), g(2, "\uff0b"), h(), f(3, "input", 143), R("ngModelChange", function (i) { V(t); const o = E().$implicit; return B(E(3).onNewTitleChange(o.key, i)) }), h(), f(4, "button", 144), g(5, "Add"), h()() } if (2 & e) { const t = E().$implicit, r = E(3); _(3), ss("name", "newTitle-", t.key, ""), b("ngModel", r.newTitle[t.key]) } } const CU = function (e, n, t) { return { "bg-sky-500": e, "bg-amber-500": n, "bg-emerald-500": t } }, wU = function () { return [] }; function EU(e, n) { if (1 & e) { const t = ve(); f(0, "div", 69)(1, "div", 70)(2, "div", 71)(3, "div", 11), M(4, "span", 72), f(5, "span", 73), g(6), h(), f(7, "span", 74), g(8), h()()()(), f(9, "div", 75, 76), R("cdkDropListDropped", function (i) { const s = V(t).$implicit; return B(E(3).drop(i, s.key)) }), I(11, J5, 2, 1, "div", 77), I(12, bU, 18, 16, "div", 78), h(), I(13, DU, 6, 2, "form", 79), h() } if (2 & e) { const t = n.$implicit, r = Ve(10), i = E(3); _(4), b("ngClass", hs(11, CU, "OPEN" === t.key, "IN_PROGRESS" === t.key, "DONE" === t.key)), _(2), te(t.label), _(2), U(" ", i.count(t.key), " "), _(1), b("id", "list-" + t.key)("cdkDropListData", i.columns[t.key])("cdkDropListConnectedTo", i.dropListReady ? i.dropListRefsExcept(r) : Gt(15, wU))("cdkDropListEnterPredicate", i.alwaysAllow), _(2), b("ngIf", !i.count(t.key)), _(1), b("ngForOf", i.columns[t.key])("ngForTrackBy", i.trackByTask), _(1), b("ngIf", i.projectId) } } function IU(e, n) { if (1 & e && (ge(0), f(1, "div", 67), I(2, EU, 14, 16, "div", 68), h(), me()), 2 & e) { const t = E(2); _(2), b("ngForOf", t.STATUS_META) } } function SU(e, n) { 1 & e && (f(0, "div", 154)(1, "div", 155), M(2, "div", 156), f(3, "div", 157), M(4, "div", 158)(5, "div", 159), h(), f(6, "div", 160), M(7, "div", 161)(8, "div", 159), h()()()) } const _E = function () { return [1, 2, 3] }; function TU(e, n) { 1 & e && (f(0, "div", 69)(1, "div", 146)(2, "div", 147), M(3, "span", 148)(4, "span", 149)(5, "span", 150), h()(), f(6, "div", 151), I(7, SU, 9, 0, "div", 152), M(8, "div", 153), h()()), 2 & e && (_(7), b("ngForOf", Gt(1, _E))) } function xU(e, n) { 1 & e && (f(0, "div", 145), I(1, TU, 9, 2, "div", 68), h()), 2 & e && (_(1), b("ngForOf", Gt(1, _E))) } function MU(e, n) { if (1 & e && (ge(0), I(1, IU, 3, 1, "ng-container", 9), I(2, xU, 2, 2, "ng-template", null, 66, qe), me()), 2 & e) { const t = Ve(3), r = E(); _(1), b("ngIf", !r.loading)("ngIfElse", t) } } function AU(e, n) { if (1 & e && (f(0, "div", 177), g(1), h()), 2 & e) { const t = E(2); _(1), U(" ", t.inviteError, " ") } } function kU(e, n) { if (1 & e) { const t = ve(); f(0, "div", 162)(1, "div", 163), R("click", function () { return V(t), B(E().closeInvite) }), h(), f(2, "form", 164), R("ngSubmit", function () { return V(t), B(E().submitInvite()) }), f(3, "div", 71)(4, "div", 165), g(5, "Invite member"), h(), f(6, "button", 166), R("click", function () { return V(t), B(E().closeInvite()) }), g(7, "\u2715"), h()(), f(8, "div", 167)(9, "label", 168), g(10, "Email"), h(), f(11, "input", 169), R("ngModelChange", function (i) { return V(t), B(E().inviteEmail = i) }), h()(), f(12, "div", 167)(13, "label", 168), g(14, "Role"), h(), f(15, "select", 170), R("ngModelChange", function (i) { return V(t), B(E().inviteRole = i) }), f(16, "option", 171), g(17, "Member"), h(), f(18, "option", 172), g(19, "Admin"), h()()(), I(20, AU, 2, 1, "div", 173), f(21, "div", 174)(22, "button", 175), R("click", function () { return V(t), B(E().closeInvite()) }), g(23, "Cancel"), h(), f(24, "button", 176), g(25), h()()()() } if (2 & e) { const t = E(); _(11), b("ngModel", t.inviteEmail), _(4), b("ngModel", t.inviteRole), _(5), b("ngIf", t.inviteError), _(4), b("disabled", t.inviting || !t.inviteEmail), _(1), U(" ", t.inviting ? "Sending..." : "Send invite", " ") } } const vE = ["OPEN", "IN_PROGRESS", "DONE"]; function yE(e) { const n = (e ?? "OPEN").toString().trim().toUpperCase().replace(/\s+/g, "_"); return vE.includes(n) ? n : "OPEN" } let Xc = (() => { class e { get filteredProjects() { const t = this.projectSearch.trim().toLowerCase(); return t ? this.projects.filter(r => { const i = (r?.name || "").toLowerCase(), o = (r?.description || "").toLowerCase(); return i.includes(t) || o.includes(t) }) : this.projects } get projectsTotalPages() { return Math.max(1, Math.ceil(this.filteredProjects.length / this.projectsPageSize)) } get projectsPageStart() { return (this.projectsPage - 1) * this.projectsPageSize } get projectsPageEnd() { return Math.min(this.projectsPageStart + this.projectsPageSize, this.filteredProjects.length) } get projectsPaged() { return this.filteredProjects.slice(this.projectsPageStart, this.projectsPageEnd) } get projectsPages() { return Array.from({ length: this.projectsTotalPages }, (t, r) => r + 1) } setProjectsPage(t) { this.projectsPage = Math.min(Math.max(1, t), this.projectsTotalPages) } prevProjectsPage() { this.setProjectsPage(this.projectsPage - 1) } nextProjectsPage() { this.setProjectsPage(this.projectsPage + 1) } onProjectSearchChange(t) { this.projectSearch = t, this.projectsPage = 1 } constructor(t, r, i, o) { this.api = t, this.route = r, this.router = i, this.cdr = o, this.loading = !1, this.loadingProjects = !0, this.loadingMembers = !1, this.error = "", this.filter = "", this.editingTitleTaskId = null, this.editingTitleValue = "", this.savingTitle = !1, this.projects = [], this.projectSearch = "", this.projectsPageSize = 9, this.projectsPage = 1, this.trackProjectById = (s, a) => a.id ?? a.name, this.members = [], this.assigneeMenuForTaskId = null, this.assigningTaskId = null, this.columns = { OPEN: [], IN_PROGRESS: [], DONE: [] }, this.newTitle = { OPEN: "", IN_PROGRESS: "", DONE: "" }, this.STATUS_META = [{ key: "OPEN", label: "To Do" }, { key: "IN_PROGRESS", label: "In Progress" }, { key: "DONE", label: "Done" }], this.dropListReady = !1, this.dragActive = !1, this.suppressClicksUntil = 0, this.inviteOpen = !1, this.inviteEmail = "", this.inviteRole = "MEMBER", this.inviting = !1, this.inviteError = "", this.toastMsg = "", this.alwaysAllow = () => !0, this.trackByTask = (s, a) => a.id ?? a.title } ngOnInit() { this.loadProjectsList(), this.route.paramMap.subscribe(t => { const r = t.get("id") || t.get("projectId"); this.projectId = r ? +r : void 0, this.projectId ? (this.loadMembers(), this.load()) : (this.project = void 0, this.members = [], this.columns = { OPEN: [], IN_PROGRESS: [], DONE: [] }, this.error = "") }) } ngAfterViewInit() { this.dropListReady = !0, this.cdr.detectChanges() } loadProjectsList() { this.loadingProjects = !0, this.api.getProjects().pipe(Yt(() => this.loadingProjects = !1)).subscribe({ next: t => { this.projects = t || [], this.projectId && (this.project = this.projects.find(r => r.id === this.projectId)), this.projectsPage > this.projectsTotalPages && (this.projectsPage = this.projectsTotalPages) }, error: () => this.projects = [] }) } goToProject(t) { t?.id && this.router.navigate(["/projects", t.id, "board"]) } loadMembers() { this.projectId && (this.loadingMembers = !0, this.api.getProjectMembers(this.projectId).pipe(Yt(() => this.loadingMembers = !1)).subscribe({ next: t => this.members = t || [], error: () => this.members = [] })) } initialsOf(t) { const r = (t || "").trim(); if (!r) return "U"; const o = (r.includes("@") ? r.split("@")[0] : r).split(/[.\s_-]+/).filter(Boolean); return (o[0]?.[0] || "").toUpperCase() + (o[1]?.[0] || "").toUpperCase() || (r[0] || "U").toUpperCase() } decorateTask(t) { const r = t?.assignee, i = r ? [r.firstname, r.lastname].filter(Boolean).join(" ") || r.email : t.assigneeName || t.assignee?.name || ""; return { ...t, assigneeId: r?.id ?? t.assigneeId ?? null, assigneeName: i || "" } } load() { this.projectId && (this.loading = !0, this.api.getTasksByProject(this.projectId).pipe(Yt(() => this.loading = !1)).subscribe({ next: t => { this.error = ""; const r = Array.isArray(t) ? t : t?.items || t?.data || []; this.columns = { OPEN: [], IN_PROGRESS: [], DONE: [] }; for (const i of r) { const o = this.decorateTask(i), s = yE(o.status); this.columns[s].push(o) } Object.keys(this.columns).forEach(i => { this.columns[i] = this.sortByOrder(this.columns[i]) }) }, error: t => { this.error = t?.error?.message || t?.message || "Failed to load board" } })) } dropListRefsExcept(t) { return (this.dropLists?.toArray() ?? []).filter(i => i !== t) } onDragStarted() { this.dragActive = !0 } onDragEnded() { this.dragActive = !1, this.suppressClicksUntil = Date.now() + 150 } onCardClick(t) { if (this.dragActive || Date.now() < this.suppressClicksUntil) return; const r = t?.id; r && this.router.navigate([{ outlets: { primary: this.projectId ? ["projects", this.projectId, "board"] : ["board"], modal: ["tasks", r] } }]) } sortByOrder(t) { return [...t].sort((r, i) => (r?.order ?? 0) - (i?.order ?? 0)) } matchesFilter(t) { if (!this.filter) return !0; const r = this.filter.toLowerCase(); return [(t.key ?? "").toString(), (t.title ?? "").toString(), (t.description ?? "").toString(), (t.assigneeName ?? t?.assignee?.name ?? "").toString()].some(l => l.toLowerCase().includes(r)) } count(t) { return this.columns[t].reduce((r, i) => r + (this.matchesFilter(i) ? 1 : 0), 0) } drop(t, r) { if (t.previousContainer === t.container) return Vp(t.container.data, t.previousIndex, t.currentIndex), void this.persistOrder(t.container.data, r); !function a5(e, n, t, r) { const i = aa(t, e.length - 1), o = aa(r, n.length); e.length && n.splice(o, 0, e.splice(i, 1)[0]) }(t.previousContainer.data, t.container.data, t.previousIndex, t.currentIndex); const i = t.container.data[t.currentIndex]; i?.id && (i.status = r, i.order = t.currentIndex, this.api.updateTask(i.id, { title: i.title, description: i.description, status: r, order: i.order }).subscribe({ next: () => { this.persistOrder(t.container.data, r); const o = this.getStatusFromListId(t.previousContainer.id); o && this.persistOrder(t.previousContainer.data, o) }, error: () => { } })) } persistOrder(t, r) { t.forEach((i, o) => { !i?.id || i.order === o && yE(i.status) === r || this.api.updateTask(i.id, { title: i.title, description: i.description, status: r, order: o }).subscribe({ next: () => { }, error: () => { } }) }) } getStatusFromListId(t) { const i = t.replace("list-", "").toUpperCase().replace(/\s+/g, "_"); return vE.includes(i) ? i : null } onNewTitleChange(t, r) { this.newTitle[t] = r } createQuick(t) { if (!this.projectId) return void this.showToast("Select a project above (or open via Projects) to create issues."); const r = (this.newTitle[t] || "").trim(); r && this.api.createTask({ title: r, description: "", status: t, order: this.columns[t].length }, this.projectId).subscribe({ next: o => { this.columns[t] = [...this.columns[t], this.decorateTask(o)], this.newTitle[t] = "" }, error: () => { } }) } invite() { this.projectId ? (this.inviteEmail = "", this.inviteRole = "MEMBER", this.inviteError = "", this.inviteOpen = !0) : this.showToast("Open/select a project first to invite members.") } closeInvite() { this.inviteOpen = !1 } submitInvite() { if (!this.projectId) return; const t = (this.inviteEmail || "").trim(); t ? /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(t) ? (this.inviting = !0, this.api.inviteMember(this.projectId, t, this.inviteRole).subscribe({ next: () => { this.inviting = !1, this.inviteOpen = !1, this.showToast("Invitation sent!") }, error: i => { this.inviting = !1, this.inviteError = i?.error || i?.message || "Invite failed" } })) : this.inviteError = "Invalid email address" : this.inviteError = "Please enter an email" } openAssigneeMenu(t, r) { r?.stopPropagation(), this.assigneeMenuForTaskId = t?.id ?? null } closeAssigneeMenu() { this.assigneeMenuForTaskId = null } isAssignedTo(t, r) { return (t?.assigneeId ?? t?.assignee?.id ?? null) === r.userId } assignTo(t, r, i) { i?.stopPropagation(), t?.id && r?.userId && (this.assigningTaskId = t.id, this.api.assignTask(t.id, r.userId).subscribe({ next: o => { const s = o?.assignee; t.assigneeId = s?.id ?? r.userId, t.assigneeName = [s?.firstname, s?.lastname].filter(Boolean).join(" ") || s?.email || r.name || r.email || "", this.assigningTaskId = null, this.assigneeMenuForTaskId = null, this.showToast("Assigned successfully") }, error: o => { this.assigningTaskId = null, this.showToast(o?.error?.message || o?.message || "Failed to assign") } })) } showToast(t) { this.toastMsg = t, setTimeout(() => this.toastMsg = "", 2e3) } onEsc() { this.inviteOpen && this.closeInvite(), null != this.assigneeMenuForTaskId && this.closeAssigneeMenu() } onDocumentClick() { null != this.assigneeMenuForTaskId && this.closeAssigneeMenu() } startTitleEdit(t, r) { r?.stopPropagation(), t?.id && (this.assigneeMenuForTaskId = null, this.editingTitleTaskId = t.id, this.editingTitleValue = (t.title || "").toString(), setTimeout(() => { const i = document.getElementById(`edit-title-${t.id}`); i?.focus(), i?.select() }, 0)) } cancelTitleEdit(t) { t?.stopPropagation(), this.savingTitle = !1, this.editingTitleTaskId = null, this.editingTitleValue = "" } saveTitle(t, r) { if (r?.stopPropagation(), !t?.id) return; const i = (this.editingTitleValue || "").trim(); i && i !== t.title ? (this.savingTitle = !0, this.api.updateTask(t.id, { title: i, description: t.description ?? "", status: t.status || "OPEN", order: "number" == typeof t.order ? t.order : 0 }).subscribe({ next: s => { t.title = s?.title ?? i, this.savingTitle = !1, this.cancelTitleEdit(), this.showToast("Title updated") }, error: s => { this.savingTitle = !1, this.showToast(s?.error?.message || s?.message || "Failed to update title") } })) : this.cancelTitleEdit() } static { this.\u0275fac = function (r) { return new (r || e)(D(gr), D(ln), D(Re), D(Pr)) } } static { this.\u0275cmp = rt({ type: e, selectors: [["app-board"]], viewQuery: function (r, i) { if (1 & r && function s0(e, n, t) { const r = oe(); r.firstCreatePass && (l0(r, new r0(e, n, t), -1), 2 == (2 & n) && (r.staticViewQueries = !0)), a0(r, S(), n) }(Qc, 5), 2 & r) { let o; Gi(o = qi()) && (i.dropLists = o) } }, hostBindings: function (r, i) { 1 & r && R("keydown.escape", function () { return i.onEsc() }, 0, hl)("click", function () { return i.onDocumentClick() }, !1, hl) }, decls: 32, vars: 11, consts: [[1, "space-y-5"], ["class", "fixed top-4 right-4 z-50 px-3 py-2 rounded-lg bg-emerald-600 text-white shadow", 4, "ngIf"], [1, "relative", "overflow-hidden", "rounded-2xl", "border", "border-slate-200", "bg-gradient-to-r", "from-slate-50", "via-white", "to-slate-50"], [1, "absolute", "inset-0", "opacity-40", "pointer-events-none", 2, "background-image", "radial-gradient(circle at 10% 10%, rgba(56,189,248,0.15), transparent 40%), radial-gradient(circle at 90% 30%, rgba(251,191,36,0.15), transparent 35%), radial-gradient(circle at 50% 80%, rgba(16,185,129,0.18), transparent 30%)"], [1, "relative", "z-10", "px-4", "md:px-6", "py-4", "md:py-5", "flex", "flex-col", "md:flex-row", "md:items-center", "md:justify-between", "gap-3"], [1, "flex", "items-center", "gap-3"], ["routerLink", "/projects", 1, "text-slate-500", "hover:underline"], [1, "text-slate-400"], [1, "text-xl", "md:text-2xl", "font-semibold", "tracking-tight"], [4, "ngIf", "ngIfElse"], ["projectNameSkeleton", ""], [1, "flex", "items-center", "gap-2"], [1, "relative"], ["placeholder", "Search issues...", 1, "w-64", "md:w-80", "pl-9", "pr-3", "py-2", "rounded-lg", "border", "border-slate-300", "bg-white/80", "backdrop-blur", "placeholder:text-slate-400", "focus:outline-none", "focus:ring-2", "focus:ring-sky-300", 3, "ngModel", "ngModelChange"], [1, "absolute", "left-2.5", "top-1/2", "-translate-y-1/2", "text-slate-400"], [1, "px-3", "py-2", "rounded-lg", "border", "border-slate-300", "bg-white", "hover:bg-slate-50", 3, "disabled", "click"], [1, "px-3", "py-2", "rounded-lg", "bg-slate-900", "text-white", "hover:bg-slate-800", "disabled:opacity-40", 3, "disabled", "click"], ["class", "-mx-1 px-1", 4, "ngIf"], ["projectsSkeleton", ""], ["class", "p-10 text-center text-slate-500 border border-dashed rounded-2xl bg-white", 4, "ngIf"], ["membersSkeleton", ""], [4, "ngIf"], ["class", "fixed inset-0 z-50 flex items-center justify-center p-4", 4, "ngIf"], [1, "fixed", "top-4", "right-4", "z-50", "px-3", "py-2", "rounded-lg", "bg-emerald-600", "text-white", "shadow"], [1, "inline-block", "h-6", "w-36", "rounded", "bg-slate-200", "animate-pulse"], [1, "-mx-1", "px-1"], [1, "mb-3", "flex", "flex-col", "sm:flex-row", "sm:items-center", "sm:justify-between", "gap-2"], [1, "text-sm", "text-slate-600"], [1, "font-medium"], [1, "relative", "w-full", "sm:w-80"], ["placeholder", "Search projects...", "aria-label", "Search projects", 1, "w-full", "pl-9", "pr-3", "py-2", "rounded-lg", "border", "border-slate-300", "bg-white", "placeholder:text-slate-400", "focus:outline-none", "focus:ring-2", "focus:ring-sky-300", 3, "ngModel", "ngModelChange"], [1, "absolute", "left-3", "top-1/2", "-translate-y-1/2", "text-slate-400"], ["class", "p-8 text-center text-slate-500 border border-dashed rounded-2xl bg-white", 4, "ngIf"], ["class", "grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 xl:grid-cols-3 gap-4", 4, "ngIf"], ["class", "flex items-center justify-between mt-3", 4, "ngIf"], [1, "p-8", "text-center", "text-slate-500", "border", "border-dashed", "rounded-2xl", "bg-white"], [1, "grid", "grid-cols-1", "sm:grid-cols-2", "md:grid-cols-3", "xl:grid-cols-3", "gap-4"], ["class", "w-full text-left p-5 md:p-6 rounded-2xl border border-slate-200 transition shadow-sm hover:shadow-md bg-white flex items-start gap-3", 3, "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "w-full", "text-left", "p-5", "md:p-6", "rounded-2xl", "border", "border-slate-200", "transition", "shadow-sm", "hover:shadow-md", "bg-white", "flex", "items-start", "gap-3", 3, "click"], [1, "inline-flex", "items-center", "justify-center", "w-12", "h-12", "md:w-14", "md:h-14", "rounded-full", "border", "border-slate-300", "bg-slate-50", "text-2xl"], [1, "min-w-0", "flex-1"], [1, "font-semibold", "text-slate-800", "text-base", "md:text-lg", "truncate"], [1, "text-xs", "text-slate-500", "mt-0.5"], [1, "shrink-0", "text-slate-400", "text-lg"], [1, "flex", "items-center", "justify-between", "mt-3"], [1, "flex", "items-center", "gap-1"], ["aria-label", "Previous projects page", 1, "px-3", "py-1.5", "rounded-md", "border", "border-slate-300", "bg-white", "text-slate-700", "hover:bg-slate-50", "disabled:opacity-50", 3, "disabled", "click"], [4, "ngFor", "ngForOf"], ["aria-label", "Next projects page", 1, "px-3", "py-1.5", "rounded-md", "border", "border-slate-300", "bg-white", "text-slate-700", "hover:bg-slate-50", "disabled:opacity-50", 3, "disabled", "click"], [1, "px-3", "py-1.5", "rounded-md", "border", 3, "ngClass", "click"], ["class", "w-full p-5 md:p-6 rounded-2xl border border-slate-200 bg-white", 4, "ngFor", "ngForOf"], [1, "w-full", "p-5", "md:p-6", "rounded-2xl", "border", "border-slate-200", "bg-white"], [1, "flex", "items-start", "gap-3", "animate-pulse"], [1, "inline-flex", "w-14", "h-14", "rounded-full", "bg-slate-200"], [1, "h-4", "bg-slate-200", "rounded", "w-3/4", "mb-2"], [1, "h-3", "bg-slate-100", "rounded", "w-1/3"], [1, "w-4", "h-4", "rounded", "bg-slate-200"], [1, "p-10", "text-center", "text-slate-500", "border", "border-dashed", "rounded-2xl", "bg-white"], [1, "flex", "items-center", "gap-2", "overflow-x-auto", "pb-2"], [1, "text-xs", "text-slate-500", "pl-1", "pr-2"], ["class", "inline-flex items-center gap-2 px-2 py-1 rounded-full border bg-white shadow-sm hover:shadow transition", 3, "title", 4, "ngFor", "ngForOf"], [1, "inline-flex", "items-center", "gap-2", "px-2", "py-1", "rounded-full", "border", "bg-white", "shadow-sm", "hover:shadow", "transition", 3, "title"], [1, "w-6", "h-6", "rounded-full", "border", "border-slate-300", "bg-slate-100", "grid", "place-items-center", "text-[10px]", "font-semibold", "text-slate-700"], [1, "text-xs", "font-medium", "text-slate-700", "hidden", "sm:inline"], ["class", "h-7 w-24 rounded-full bg-slate-200 animate-pulse", 4, "ngFor", "ngForOf"], [1, "h-7", "w-24", "rounded-full", "bg-slate-200", "animate-pulse"], ["boardLoading", ""], ["cdkDropListGroup", "", 1, "grid", "md:grid-cols-3", "gap-4", "md:gap-6", "overflow-x-auto", "pb-2"], ["class", "rounded-2xl bg-white border border-slate-200/70 shadow-sm overflow-hidden", 4, "ngFor", "ngForOf"], [1, "rounded-2xl", "bg-white", "border", "border-slate-200/70", "shadow-sm", "overflow-hidden"], [1, "px-3", "py-2", "bg-gradient-to-r", "rounded-t-2xl", "border-b", "border-slate-200", "from-white", "to-slate-50/60", "sticky", "top-0", "z-10", "backdrop-blur"], [1, "flex", "items-center", "justify-between"], [1, "inline-block", "w-2", "h-2", "rounded-full", 3, "ngClass"], [1, "text-sm", "font-semibold"], [1, "text-slate-500", "text-xs", "font-medium", "px-2", "py-0.5", "rounded-full", "border", "bg-white"], ["cdkDropList", "", 1, "min-h-[360px]", "p-3", "space-y-2", 3, "id", "cdkDropListData", "cdkDropListConnectedTo", "cdkDropListEnterPredicate", "cdkDropListDropped"], ["listRef", "cdkDropList"], ["class", "text-xs text-slate-400 text-center border border-dashed rounded-xl py-8 bg-slate-50/60", 4, "ngIf"], ["class", "group bg-white rounded-xl border border-slate-200 p-3 shadow-sm hover:shadow transition\n                     cursor-grab active:cursor-grabbing select-none\n                     border-l-4", "cdkDrag", "", 3, "display", "ngClass", "click", "cdkDragStarted", "cdkDragEnded", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "m-3 mt-0 flex items-center gap-2 p-2 bg-slate-50 rounded-xl border border-slate-200", 3, "ngSubmit", 4, "ngIf"], [1, "text-xs", "text-slate-400", "text-center", "border", "border-dashed", "rounded-xl", "py-8", "bg-slate-50/60"], ["cdkDrag", "", 1, "group", "bg-white", "rounded-xl", "border", "border-slate-200", "p-3", "shadow-sm", "hover:shadow", "transition", "cursor-grab", "active:cursor-grabbing", "select-none", "border-l-4", 3, "ngClass", "click", "cdkDragStarted", "cdkDragEnded"], [1, "flex", "items-start", "justify-between", "gap-3"], [1, "min-w-0"], ["inlineTitleEditor", ""], [1, "relative", "shrink-0"], ["type", "button", 1, "w-7", "h-7", "rounded-full", "border", "border-slate-200", "bg-white", "grid", "place-items-center", "text-[11px]", "font-semibold", "text-slate-700", "hover:bg-slate-50", 3, "title", "click"], ["class", "absolute right-0 mt-2 z-20 w-56 bg-white border border-slate-200 rounded-xl shadow-lg", 3, "click", 4, "ngIf"], [1, "mt-2", "flex", "items-center", "justify-between", "text-xs", "text-slate-500"], ["class", "inline-flex items-center gap-1", 4, "ngIf"], ["cdkDragPreview", ""], ["cdkDragPlaceholder", ""], [1, "flex", "items-center", "gap-1", "min-w-0"], [1, "font-semibold", "text-slate-800", "truncate"], ["type", "button", "title", "Edit title", 1, "shrink-0", "ml-1", "inline-flex", "items-center", "justify-center", "rounded", "hover:bg-slate-100", "text-slate-500", "hover:text-slate-700", "p-1", "h-6", "w-6", 3, "click"], ["xmlns", "http://www.w3.org/2000/svg", "fill", "none", "viewBox", "0 0 24 24", "stroke", "currentColor", "stroke-width", "1.5", "aria-hidden", "true", 1, "h-4", "w-4"], ["stroke-linecap", "round", "stroke-linejoin", "round", "d", "M16.862 3.487a2.25 2.25 0 013.182 3.182l-9.193 9.193-3.49.308.308-3.49 9.193-9.193z"], ["stroke-linecap", "round", "stroke-linejoin", "round", "d", "M19.5 10.5L13.5 4.5"], [1, "mt-1", "flex", "items-center", "gap-2", "text-xs", "text-slate-500"], ["class", "px-1.5 py-0.5 rounded bg-slate-100 border text-[11px] tracking-wide", 4, "ngIf"], ["class", "px-1.5 py-0.5 rounded border text-[11px]", 3, "ngClass", 4, "ngIf"], [1, "px-1.5", "py-0.5", "rounded", "bg-slate-100", "border", "text-[11px]", "tracking-wide"], [1, "px-1.5", "py-0.5", "rounded", "border", "text-[11px]", 3, "ngClass"], [1, "relative", "p-3", "rounded-xl", "border", "border-slate-200", "bg-white/90", "backdrop-blur", "shadow-sm", "ring-1", "ring-slate-100", 3, "click"], [1, "h-0.5", "w-full", "bg-gradient-to-r", "from-sky-400", "via-violet-500", "to-emerald-500", "rounded-full", "mb-2"], [1, "relative", "flex-1"], [1, "absolute", "left-2", "top-1/2", "-translate-y-1/2", "text-slate-400"], ["placeholder", "Update title...", "aria-label", "Edit title", 1, "w-full", "rounded-lg", "border", "border-slate-300", "bg-white", "pl-8", "pr-3", "py-2", "focus:outline-none", "focus:ring-2", "focus:ring-sky-300", "focus:border-sky-300", 3, "id", "value", "input", "keydown.enter", "keydown.escape"], ["type", "button", "title", "Save", 1, "inline-flex", "items-center", "gap-1.5", "px-3", "py-1.5", "rounded-lg", "text-white", "bg-gradient-to-r", "from-sky-600", "to-indigo-600", "hover:from-sky-700", "hover:to-indigo-700", "disabled:opacity-50", "shadow", 3, "disabled", "click"], ["xmlns", "http://www.w3.org/2000/svg", "class", "h-4 w-4", "fill", "none", "viewBox", "0 0 24 24", "stroke", "currentColor", "stroke-width", "1.5", "aria-hidden", "true", 4, "ngIf"], ["class", "h-4 w-4 animate-spin text-white", "viewBox", "0 0 24 24", "aria-hidden", "true", 4, "ngIf"], [1, "hidden", "sm:inline"], ["type", "button", "title", "Cancel", 1, "inline-flex", "items-center", "gap-1.5", "px-3", "py-1.5", "rounded-lg", "border", "border-slate-300", "bg-white", "text-slate-700", "hover:bg-slate-50", "disabled:opacity-50", 3, "disabled", "click"], ["stroke-linecap", "round", "stroke-linejoin", "round", "d", "M6 18L18 6M6 6l12 12"], [1, "mt-2", "flex", "items-center", "justify-between", "text-[11px]", "text-slate-500"], ["class", "px-1.5 py-0.5 rounded-full bg-slate-50 border border-slate-200 text-slate-600", 4, "ngIf"], ["class", "px-1.5 py-0.5 rounded-full border", 3, "ngClass", 4, "ngIf"], [1, "hidden", "sm:flex", "items-center", "gap-1"], [1, "mx-1", "text-slate-300"], ["stroke-linecap", "round", "stroke-linejoin", "round", "d", "M4.5 12.75l4.5 4.5 10.5-10.5"], ["viewBox", "0 0 24 24", "aria-hidden", "true", 1, "h-4", "w-4", "animate-spin", "text-white"], ["cx", "12", "cy", "12", "r", "10", "stroke", "currentColor", "stroke-width", "3", "fill", "none", 1, "opacity-25"], ["fill", "currentColor", "d", "M4 12a8 8 0 018-8v3a5 5 0 00-5 5H4z", 1, "opacity-75"], [1, "px-1.5", "py-0.5", "rounded-full", "bg-slate-50", "border", "border-slate-200", "text-slate-600"], [1, "px-1.5", "py-0.5", "rounded-full", "border", 3, "ngClass"], [1, "absolute", "right-0", "mt-2", "z-20", "w-56", "bg-white", "border", "border-slate-200", "rounded-xl", "shadow-lg", 3, "click"], [1, "px-3", "py-2", "text-xs", "text-slate-500", "border-b"], ["type", "button", "class", "w-full flex items-center gap-2 px-3 py-2 text-left hover:bg-slate-50", 3, "click", 4, "ngFor", "ngForOf"], ["class", "px-3 py-2 text-[11px] text-slate-400 border-t", 4, "ngIf"], ["type", "button", 1, "w-full", "flex", "items-center", "gap-2", "px-3", "py-2", "text-left", "hover:bg-slate-50", 3, "click"], [1, "w-6", "h-6", "rounded-full", "border", "border-slate-200", "bg-slate-100", "grid", "place-items-center", "text-[10px]", "font-semibold", "text-slate-700"], [1, "text-xs", "font-medium", "text-slate-800", "truncate"], [1, "text-[10px]", "text-slate-500", "truncate"], ["class", "ml-auto text-[10px] text-slate-400", 4, "ngIf"], [1, "ml-auto", "text-[10px]", "text-slate-400"], [1, "px-3", "py-2", "text-[11px]", "text-slate-400", "border-t"], [1, "inline-flex", "items-center", "gap-1"], [1, "truncate", "max-w-[120px]"], [1, "uppercase", "tracking-wide"], [1, "bg-white", "rounded-xl", "border", "border-sky-400", "shadow-xl", "px-3", "py-2", "opacity-95"], [1, "h-12", "rounded-xl", "border-2", "border-dashed", "border-slate-300", "bg-slate-50"], [1, "m-3", "mt-0", "flex", "items-center", "gap-2", "p-2", "bg-slate-50", "rounded-xl", "border", "border-slate-200", 3, "ngSubmit"], [1, "text-slate-400", "pl-1"], ["placeholder", "Add new issue...", 1, "flex-1", "bg-transparent", "border-0", "focus:ring-0", "text-sm", "placeholder:text-slate-400", 3, "ngModel", "name", "ngModelChange"], ["type", "submit", 1, "px-3", "py-1.5", "text-xs", "bg-slate-900", "text-white", "rounded", "hover:bg-slate-800"], [1, "grid", "md:grid-cols-3", "gap-4", "md:gap-6", "overflow-x-auto", "pb-2"], [1, "px-3", "py-2", "bg-gradient-to-r", "rounded-t-2xl", "border-b", "border-slate-200", "from-white", "to-slate-50/60"], [1, "flex", "items-center", "gap-2", "animate-pulse"], [1, "inline-block", "w-2", "h-2", "rounded-full", "bg-slate-200"], [1, "h-4", "w-24", "rounded", "bg-slate-200"], [1, "h-4", "w-10", "rounded", "bg-slate-100"], [1, "p-3", "space-y-2"], ["class", "rounded-xl border border-slate-200 p-3", 4, "ngFor", "ngForOf"], [1, "h-10", "rounded-xl", "border", "border-dashed", "border-slate-200", "bg-slate-50"], [1, "rounded-xl", "border", "border-slate-200", "p-3"], [1, "space-y-2", "animate-pulse"], [1, "h-4", "w-2/3", "bg-slate-200", "rounded"], [1, "flex", "gap-2"], [1, "h-3", "w-14", "bg-slate-100", "rounded"], [1, "h-3", "w-12", "bg-slate-100", "rounded"], [1, "flex", "justify-between"], [1, "h-3", "w-24", "bg-slate-100", "rounded"], [1, "fixed", "inset-0", "z-50", "flex", "items-center", "justify-center", "p-4"], [1, "absolute", "inset-0", "bg-slate-900/30", 3, "click"], [1, "relative", "z-10", "w-full", "max-w-md", "bg-white", "rounded-2xl", "border", "border-slate-200", "shadow-xl", "p-4", "md:p-5", "space-y-4", 3, "ngSubmit"], [1, "text-base", "font-semibold"], ["type", "button", 1, "text-slate-400", "hover:text-slate-700", 3, "click"], [1, "space-y-2"], [1, "text-xs", "text-slate-500"], ["type", "email", "name", "inviteEmail", "required", "", "autofocus", "", "placeholder", "user@example.com", 1, "w-full", "px-3", "py-2", "rounded-lg", "border", "border-slate-300", "bg-white/90", "placeholder:text-slate-400", "focus:outline-none", "focus:ring-2", "focus:ring-sky-300", 3, "ngModel", "ngModelChange"], ["name", "inviteRole", 1, "w-full", "px-3", "py-2", "rounded-lg", "border", "border-slate-300", "bg-white", "focus:outline-none", "focus:ring-2", "focus:ring-sky-300", 3, "ngModel", "ngModelChange"], ["value", "MEMBER"], ["value", "ADMIN"], ["class", "text-xs text-red-600", 4, "ngIf"], [1, "flex", "justify-end", "gap-2", "pt-2"], ["type", "button", 1, "px-3", "py-2", "rounded-lg", "border", "border-slate-300", "bg-white", "hover:bg-slate-50", 3, "click"], ["type", "submit", 1, "px-3", "py-2", "rounded-lg", "bg-slate-900", "text-white", "hover:bg-slate-800", "disabled:opacity-40", 3, "disabled"], [1, "text-xs", "text-red-600"]], template: function (r, i) { if (1 & r && (f(0, "div", 0), I(1, R5, 2, 1, "div", 1), f(2, "div", 2), M(3, "div", 3), f(4, "div", 4)(5, "div", 5)(6, "a", 6), g(7, "Projects"), h(), f(8, "span", 7), g(9, "/"), h(), f(10, "div", 8), I(11, P5, 2, 1, "ng-container", 9), h(), I(12, N5, 1, 0, "ng-template", null, 10, qe), h(), f(14, "div", 11)(15, "div", 12)(16, "input", 13), R("ngModelChange", function (s) { return i.filter = s }), h(), f(17, "span", 14), g(18, "\u{1f50e}"), h()(), f(19, "button", 15), R("click", function () { return i.load() }), g(20, "Refresh"), h(), f(21, "button", 16), R("click", function () { return i.invite() }), g(22, "Invite"), h()()()(), I(23, H5, 2, 2, "div", 17), I(24, G5, 2, 2, "ng-template", null, 18, qe), I(26, q5, 2, 0, "div", 19), I(27, K5, 2, 2, "div", 17), I(28, X5, 4, 2, "ng-template", null, 20, qe), I(30, MU, 4, 2, "ng-container", 21), h(), I(31, kU, 26, 5, "div", 22)), 2 & r) { const o = Ve(13); _(1), b("ngIf", i.toastMsg), _(10), b("ngIf", !(i.projectId && (i.loading || i.loadingProjects)))("ngIfElse", o), _(5), b("ngModel", i.filter), _(3), b("disabled", !i.projectId), _(2), b("disabled", !i.projectId), _(2), b("ngIf", !i.projectId), _(3), b("ngIf", !(i.projectId || i.loadingProjects || i.projects && i.projects.length)), _(1), b("ngIf", i.projectId), _(3), b("ngIf", i.projectId), _(1), b("ngIf", i.inviteOpen) } }, dependencies: [Xi, Fr, Dn, Gr, wp, Ip, Kn, ea, Hr, $r, jc, In, Js, Qs, Qc, pE, $p, dE, cE, yh], encapsulation: 2 }) } } return e })(); const RU = [{ path: "", component: (() => { class e { constructor(t) { this.auth = t } static { this.\u0275fac = function (r) { return new (r || e)(D(Tn)) } } static { this.\u0275cmp = rt({ type: e, selectors: [["app-app-layout"]], decls: 69, vars: 0, consts: [[1, "min-h-screen", "grid", "grid-cols-[260px_1fr]", "bg-slate-50"], [1, "relative", "bg-white", "border-r", "border-slate-200", "p-4", "flex", "flex-col"], [1, "absolute", "inset-y-0", "left-0", "w-1", "bg-gradient-to-b", "from-sky-400", "via-violet-500", "to-emerald-500", "rounded-r"], [1, "flex", "items-center", "gap-3", "mb-6", "pl-2"], [1, "inline-flex", "items-center", "justify-center", "w-9", "h-9", "rounded-lg", "bg-slate-900", "text-white", "shadow-sm"], [1, "text-xl", "font-bold", "bg-gradient-to-r", "from-slate-900", "to-slate-600", "bg-clip-text", "text-transparent"], [1, "space-y-1"], [1, "text-[11px]", "uppercase", "tracking-wider", "text-slate-400", "px-2", "mb-1"], ["routerLink", "/dashboard", "routerLinkActive", "bg-slate-100", 1, "group", "flex", "items-center", "gap-3", "px-3", "py-2", "rounded-lg", "hover:bg-slate-50", "border", "border-transparent", "hover:border-slate-200", "transition"], [1, "w-7", "h-7", "grid", "place-items-center", "rounded-md", "bg-slate-100", "text-slate-600"], ["viewBox", "0 0 24 24", "fill", "none", "stroke", "currentColor", "stroke-width", "1.8", "stroke-linecap", "round", "stroke-linejoin", "round", "aria-hidden", "true", 1, "w-5", "h-5"], ["d", "M3 10l9-7 9 7"], ["d", "M5 10v10a2 2 0 0 0 2 2h4v-6h2v6h4a2 2 0 0 0 2-2V10"], [1, "font-medium", "text-slate-800"], ["routerLink", "/board", "routerLinkActive", "bg-slate-100", 1, "group", "flex", "items-center", "gap-3", "px-3", "py-2", "rounded-lg", "hover:bg-slate-50", "border", "border-transparent", "hover:border-slate-200", "transition"], ["viewBox", "0 0 24 24", "fill", "none", "stroke", "currentColor", "stroke-width", "1.8", "aria-hidden", "true", 1, "w-5", "h-5"], ["x", "3", "y", "4", "width", "6", "height", "16", "rx", "1.5"], ["x", "10", "y", "4", "width", "4", "height", "16", "rx", "1.5"], ["x", "15", "y", "4", "width", "6", "height", "16", "rx", "1.5"], ["routerLink", "/backlog", "routerLinkActive", "bg-slate-100", 1, "group", "flex", "items-center", "gap-3", "px-3", "py-2", "rounded-lg", "hover:bg-slate-50", "border", "border-transparent", "hover:border-slate-200", "transition"], [1, "w-7", "h-7", "grid", "place-items-center", "rounded-md", "bg-amber-50", "text-amber-600"], ["viewBox", "0 0 24 24", "fill", "none", "stroke", "currentColor", "stroke-width", "1.8", "stroke-linecap", "round", "aria-hidden", "true", 1, "w-5", "h-5"], ["x", "5", "y", "3", "width", "14", "height", "18", "rx", "2"], ["d", "M8 8h8M8 12h8M8 16h8"], ["routerLink", "/projects/summary", "routerLinkActive", "bg-slate-100", 1, "group", "flex", "items-center", "gap-3", "px-3", "py-2", "rounded-lg", "hover:bg-slate-50", "border", "border-transparent", "hover:border-slate-200", "transition"], [1, "w-7", "h-7", "grid", "place-items-center", "rounded-md", "bg-emerald-50", "text-emerald-600"], ["cx", "12", "cy", "12", "r", "9"], ["d", "M8.5 12.5l2.5 2.5 4.5-5"], ["routerLink", "/projects", "routerLinkActive", "bg-slate-100", 1, "group", "flex", "items-center", "gap-3", "px-3", "py-2", "rounded-lg", "hover:bg-slate-50", "border", "border-transparent", "hover:border-slate-200", "transition"], [1, "w-7", "h-7", "grid", "place-items-center", "rounded-md", "bg-sky-50", "text-sky-600"], ["d", "M3 7a2 2 0 0 1 2-2h4l2 2h6a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7z"], ["routerLink", "/profile", "routerLinkActive", "bg-slate-100", 1, "group", "flex", "items-center", "gap-3", "px-3", "py-2", "rounded-lg", "hover:bg-slate-50", "border", "border-transparent", "hover:border-slate-200", "transition"], [1, "w-7", "h-7", "grid", "place-items-center", "rounded-md", "bg-violet-50", "text-violet-600"], ["cx", "12", "cy", "8", "r", "3"], ["d", "M4 20a8 8 0 0 1 16 0"], [1, "mt-auto", "pt-6", "text-xs", "text-slate-400", "px-2"], [1, "border-t", "border-slate-200", "pt-4"], [1, "mt-1"], [1, "p-4", "md:p-6"], [1, "sticky", "top-0", "z-10", "-mt-2", "mb-6"], [1, "rounded-xl", "border", "border-slate-200", "bg-white/90", "backdrop-blur", "px-4", "py-3", "flex", "items-center", "justify-between", "shadow-sm"], [1, "text-xl", "md:text-2xl", "font-semibold", "text-slate-800", "tracking-tight"], [1, "px-3", "py-2", "text-sm", "rounded-lg", "text-white", "bg-gradient-to-r", "from-slate-900", "to-slate-700", "hover:from-slate-800", "hover:to-slate-700", 3, "click"], [1, "relative"], ["name", "modal"]], template: function (r, i) { 1 & r && (f(0, "div", 0)(1, "aside", 1), M(2, "div", 2), f(3, "div", 3)(4, "div", 4), g(5, "TL"), h(), f(6, "div", 5), g(7, " TaskLink "), h()(), f(8, "nav", 6)(9, "div", 7), g(10, "Navigation"), h(), f(11, "a", 8)(12, "span", 9), Ee(), f(13, "svg", 10), M(14, "path", 11)(15, "path", 12), h()(), Le(), f(16, "span", 13), g(17, "Dashboard"), h()(), f(18, "a", 14)(19, "span", 9), Ee(), f(20, "svg", 15), M(21, "rect", 16)(22, "rect", 17)(23, "rect", 18), h()(), Le(), f(24, "span", 13), g(25, "Board"), h()(), f(26, "a", 19)(27, "span", 20), Ee(), f(28, "svg", 21), M(29, "rect", 22)(30, "path", 23), h()(), Le(), f(31, "span", 13), g(32, "Backlog"), h()(), f(33, "a", 24)(34, "span", 25), Ee(), f(35, "svg", 10), M(36, "circle", 26)(37, "path", 27), h()(), Le(), f(38, "span", 13), g(39, "Summary"), h()(), f(40, "a", 28)(41, "span", 29), Ee(), f(42, "svg", 10), M(43, "path", 30), h()(), Le(), f(44, "span", 13), g(45, "Projects"), h()(), f(46, "a", 31)(47, "span", 32), Ee(), f(48, "svg", 10), M(49, "circle", 33)(50, "path", 34), h()(), Le(), f(51, "span", 13), g(52, "Profile"), h()()(), f(53, "div", 35)(54, "div", 36)(55, "div"), g(56, "\xa9 TaskLink"), h(), f(57, "div", 37), g(58, "v1.0.0"), h()()()(), f(59, "main", 38)(60, "div", 39)(61, "div", 40)(62, "h1", 41), g(63, "TaskLink"), h(), f(64, "button", 42), R("click", function () { return i.auth.logout() }), g(65, " Logout "), h()()(), f(66, "div", 43), M(67, "router-outlet")(68, "router-outlet", 44), h()()()) }, dependencies: [Fs, In, QC], encapsulation: 2 }) } } return e })(), canActivate: [e4], children: [{ path: "", redirectTo: "dashboard", pathMatch: "full" }, { path: "dashboard", component: Iw }, { path: "board", component: Xc }, { path: "projects/:id/board", component: Xc }, { path: "backlog", component: gE }, { path: "tasks", component: Bc }, { path: "tasks/:id", component: Sp }, { path: "projects", component: k1 }, { path: "profile", component: A1 }, { path: "projects/summary", component: Bc }, { path: "projects/:id/summary", component: Bc }] }, { path: "accept-invite", component: Tp }, { path: "invite/:token", component: Tp }, { path: "", component: (() => { class e { static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275cmp = rt({ type: e, selectors: [["app-auth-layout"]], decls: 8, vars: 0, consts: [[1, "min-h-screen", "flex", "items-center", "justify-center", "bg-gradient-to-b", "from-slate-50", "to-slate-100"], [1, "w-full", "max-w-md", "bg-white", "shadow-xl", "rounded-xl", "p-8"], [1, "mb-6", "text-center"], [1, "text-2xl", "font-bold", "text-brand-600"], [1, "text-sm", "text-slate-500"]], template: function (r, i) { 1 & r && (f(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3), g(4, "TaskLink"), h(), f(5, "div", 4), g(6, "Stay on top of your work"), h()(), M(7, "router-outlet"), h()()) }, dependencies: [Fs] }) } } return e })(), canActivate: [G4], children: [{ path: "login", component: WV }, { path: "register", component: JV }] }, { path: "**", component: t4 }]; let PU = (() => { class e { static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275mod = bt({ type: e }) } static { this.\u0275inj = ct({ imports: [ow.forRoot(RU), ow] }) } } return e })(), NU = (() => { class e { constructor() { this.title = "tasklink-frontend" } static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275cmp = rt({ type: e, selectors: [["app-root"]], decls: 1, vars: 0, template: function (r, i) { 1 & r && M(0, "router-outlet") }, dependencies: [Fs] }) } } return e })(), OU = (() => { class e { constructor(t) { this.auth = t } intercept(t, r) { const i = /\/auth\/(login|register)/i.test(t.url), o = this.auth.getToken?.(); return !i && o && (t = t.clone({ setHeaders: { Authorization: `Bearer ${o}` } })), r.handle(t) } static { this.\u0275fac = function (r) { return new (r || e)(k(Tn)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac }) } } return e })(), FU = (() => { class e { constructor(t) { this.auth = t } intercept(t, r) { return r.handle(t).pipe(dr(i => (401 === i.status && this.auth.logout(), Ji(() => i)))) } static { this.\u0275fac = function (r) { return new (r || e)(k(Tn)) } } static { this.\u0275prov = F({ token: e, factory: e.\u0275fac }) } } return e })(), LU = (() => { class e { static { this.\u0275fac = function (r) { return new (r || e) } } static { this.\u0275mod = bt({ type: e, bootstrap: [NU] }) } static { this.\u0275inj = ct({ providers: [{ provide: ap, useClass: OU, multi: !0 }, { provide: ap, useClass: FU, multi: !0 }], imports: [SF, HV, A3, PU, UV, m5] }) } } return e })(); EF().bootstrapModule(LU).catch(e => console.error(e)) } }, ne => { ne(ne.s = 629) }]);